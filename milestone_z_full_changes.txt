
===== FILE: .eslintrc.cjs =====
const UI_TEXT_REGEX = '[A-Za-zÀ-ÖØ-öø-ÿА-Яа-яЁёÇĞÜİÖŞçğıöş]';

/** @type {import('eslint').Linter.Config} */
module.exports = {
  root: true,
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true,
    },
  },
  ignorePatterns: [
    '**/node_modules/**',
    '**/dist/**',
    '**/.expo/**',
    '**/coverage/**',
    '**/*.d.ts',
    'apps/mobile/src/shared/i18n/locales/*.json',
  ],
  overrides: [
    {
      files: [
        '**/*.tsx',
        '**/navigation/**/*.ts',
        '**/navigation/**/*.tsx',
      ],
      excludedFiles: ['**/*.test.ts', '**/*.test.tsx', '**/__tests__/**'],
      rules: {
        'no-restricted-syntax': [
          'error',
          {
            selector: `JSXText[value=/${UI_TEXT_REGEX}/]`,
            message: 'Hardcoded UI text is forbidden. Use t("...") keys.',
          },
          {
            selector: `JSXExpressionContainer > Literal[value=/${UI_TEXT_REGEX}/]`,
            message: 'Hardcoded UI text is forbidden. Use t("...") keys.',
          },
          {
            selector: 'JSXExpressionContainer > TemplateLiteral[expressions.length=0]',
            message: 'Hardcoded UI text is forbidden. Use t("...") keys.',
          },
          {
            selector:
              `JSXAttribute[name.name=/^(placeholder|accessibilityLabel|title|headerTitle|tabBarLabel|label|subtitle|description)$/] > Literal[value=/${UI_TEXT_REGEX}/]`,
            message: 'UI attribute text must come from i18n: use t("...").',
          },
          {
            selector:
              `JSXAttribute[name.name=/^(placeholder|accessibilityLabel|title|headerTitle|tabBarLabel|label|subtitle|description)$/] JSXExpressionContainer > Literal[value=/${UI_TEXT_REGEX}/]`,
            message: 'UI attribute text must come from i18n: use t("...").',
          },
          {
            selector:
              `Property[key.name=/^(title|headerTitle|tabBarLabel|label|placeholder|subtitle|description|accessibilityLabel)$/] > Literal[value=/${UI_TEXT_REGEX}/]`,
            message: 'Navigation/UI config strings must use i18n keys.',
          },
          {
            selector:
              `Property[key.value=/^(title|headerTitle|tabBarLabel|label|placeholder|subtitle|description|accessibilityLabel)$/] > Literal[value=/${UI_TEXT_REGEX}/]`,
            message: 'Navigation/UI config strings must use i18n keys.',
          },
          {
            selector:
              `CallExpression[callee.object.name='Alert'][callee.property.name='alert'] > Literal[value=/${UI_TEXT_REGEX}/]`,
            message: 'Alert text must use i18n: Alert.alert(t("...")).',
          },
          {
            selector:
              "CallExpression[callee.object.name='Alert'][callee.property.name='alert'] > TemplateLiteral[expressions.length=0]",
            message: 'Alert text must use i18n: Alert.alert(t("...")).',
          },
        ],
      },
    },
  ],
};

===== FILE: README.md =====
# FinSight Monorepo

Monorepo structure:
- `apps/api`: Fastify + TypeScript + MongoDB (Mongoose)
- `apps/mobile`: Expo React Native + TypeScript
- `packages/shared`: shared Zod schemas + typed API client

## Deploy To Render

### API service settings
- Service type: `Web Service` (Node)
- Root directory: repo root (`/`)
- Build command:
```bash
pnpm install --frozen-lockfile && pnpm -C apps/api build
```
- Start command:
```bash
pnpm start:api
```
- Health check path:
```text
/health
```

### Required API environment variables
- `NODE_ENV=production`
- `PORT` (Render injects this automatically)
- `MONGODB_URI` (MongoDB Atlas connection string)
- `JWT_ACCESS_SECRET` (minimum 16 chars)
- `JWT_REFRESH_SECRET` (minimum 16 chars)
- `ACCESS_TTL_MIN` (example: `15`)
- `REFRESH_TTL_DAYS` (example: `30`)
- `CRON_SECRET` (minimum 16 chars; protects `/recurring/run-due`)
- `CORS_ORIGINS` (comma-separated, no spaces unless trimmed)

Example `CORS_ORIGINS`:
```text
https://finsight.app,https://www.finsight.app
```

### Render API behavior notes
- API binds to `0.0.0.0` and uses `PORT`.
- Startup fails fast if env config is invalid.
- Security middleware in production:
  - `@fastify/helmet`
  - global rate limiting
  - strict CORS origin allowlist

## Operations

### Trigger recurring runner securely
Use either `x-cron-secret` or `Authorization: Bearer <CRON_SECRET>`.

Header secret form:
```bash
curl -X POST "https://<your-render-service>/recurring/run-due" \
  -H "x-cron-secret: $CRON_SECRET"
```

Bearer form:
```bash
curl -X POST "https://<your-render-service>/recurring/run-due" \
  -H "Authorization: Bearer $CRON_SECRET"
```

### Local smoke test
Start the API, then run:
```bash
pnpm smoke:api
```

Optional custom base URL:
```bash
API_BASE_URL="http://127.0.0.1:4000" pnpm smoke:api
```

## i18n Lint Policy (CI Hard-Fail)

FinSight enforces strict i18n in mobile UI code. User-facing text must never be hardcoded.

### What to do instead
- Use `t('...')` for all screen text, button labels, placeholders, headers, empty states, alerts, and accessibility labels.
- Add translation keys under:
  - `/Users/umutugur/finsight/apps/mobile/src/shared/i18n/locales/en.json`
  - `/Users/umutugur/finsight/apps/mobile/src/shared/i18n/locales/tr.json`
  - `/Users/umutugur/finsight/apps/mobile/src/shared/i18n/locales/ru.json`
- Keep keys grouped by domain (`auth`, `dashboard`, `transactions`, `groups`, etc.).

### What is allowed
- Test files (`*.test.ts`, `*.test.tsx`)
- Translation JSON files
- Non-user-facing technical constants (ids, enum-like internal values, symbols/punctuation)

### Run locally
```bash
pnpm lint:i18n
```

or only mobile package:
```bash
pnpm -C apps/mobile lint:i18n
```

`lint:i18n` fails the build when forbidden raw UI strings are introduced.

## i18n Key Convention

Use this key format:

```text
<namespace>.<screenOrDomain>.<component>.<purpose>
```

Examples:
- `common.buttons.save`
- `auth.login.form.title`
- `auth.login.form.email.label`
- `groups.detail.summary.totalSpending`
- `errors.auth.invalidCredentials`

### Locale file structure

Locale files live under:
- `/Users/umutugur/finsight/apps/mobile/src/shared/i18n/locales/en.json`
- `/Users/umutugur/finsight/apps/mobile/src/shared/i18n/locales/tr.json`
- `/Users/umutugur/finsight/apps/mobile/src/shared/i18n/locales/ru.json`

Required top-level namespaces:
- `common`
- `auth`
- `dashboard`
- `transactions`
- `analytics`
- `groups`
- `advisor`
- `profile`
- `settings`
- `errors`

### How to add translations

1. Add the new key in all 3 locale files (`en`, `tr`, `ru`) using the same path.
2. Prefer reusing existing keys before creating a new one.
3. Use `t('...')` (or `useT` helper) in UI code; do not hardcode text.
4. For navigation labels/titles, use i18n keys (for example keys from `/Users/umutugur/finsight/apps/mobile/src/shared/i18n/keys.ts`).
5. Run:

```bash
pnpm lint:i18n
pnpm -C apps/mobile exec tsc --noEmit
```

===== FILE: apps/mobile/App.tsx =====
import 'react-native-gesture-handler';

import { AppRoot } from './src/app/AppRoot';

export default function App() {
  return <AppRoot />;
}

===== FILE: apps/mobile/babel.config.js =====
module.exports = function (api) {
  api.cache(true);

  return {
    presets: ['babel-preset-expo'],
    plugins: [
      [
        'module-resolver',
        {
          root: ['./'],
          alias: {
            '@app': './src/app',
            '@core': './src/core',
            '@shared': './src/shared',
            '@features': './src/features',
          },
        },
      ],
    ],
  };
};

===== FILE: apps/mobile/package.json =====
{
  "name": "mobile",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "dev": "expo start --port 8089",
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "lint": "pnpm lint:i18n",
    "lint:i18n": "eslint --config ../../.eslintrc.cjs --ext .ts,.tsx src --max-warnings=0"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.3",
    "@mintly/shared": "workspace:*",
    "@hookform/resolvers": "^5.2.2",
    "@react-native-async-storage/async-storage": "^2.2.0",
    "@react-navigation/bottom-tabs": "^7.8.6",
    "@react-navigation/native": "^7.1.17",
    "@react-navigation/native-stack": "^7.3.25",
    "@tanstack/react-query": "^5.90.5",
    "expo": "~54.0.33",
    "expo-camera": "~17.0.8",
    "expo-localization": "^17.0.8",
    "expo-secure-store": "~15.0.7",
    "expo-status-bar": "~3.0.9",
    "i18next": "^25.8.11",
    "react": "19.1.0",
    "react-hook-form": "^7.66.0",
    "react-i18next": "^16.5.4",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-safe-area-context": "5.6.1",
    "react-native-screens": "~4.16.0",
    "zod": "^4.3.6"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "babel-plugin-module-resolver": "^5.0.2",
    "typescript": "~5.9.2"
  },
  "private": true
}

===== FILE: apps/mobile/tsconfig.json =====
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "baseUrl": ".",
    "paths": {
      "@app/*": ["src/app/*"],
      "@core/*": ["src/core/*"],
      "@shared/*": ["src/shared/*"],
      "@features/*": ["src/features/*"]
    }
  }
}

===== FILE: apps/mobile/src/app/AppRoot.tsx =====
import { NavigationContainer } from '@react-navigation/native';
import { StatusBar } from 'expo-status-bar';
import { SafeAreaProvider } from 'react-native-safe-area-context';

import { AuthProvider } from '@app/providers/AuthProvider';
import { QueryProvider } from '@app/providers/QueryProvider';
import { ThemeProvider } from '@app/providers/ThemeProvider';
import { I18nProvider } from '@shared/i18n';
import { AppNavigator } from '@core/navigation/AppNavigator';

export function AppRoot() {
  return (
    <I18nProvider>
      <ThemeProvider initialPreference="light">
        <SafeAreaProvider>
          <NavigationContainer>
            <QueryProvider>
              <AuthProvider>
                <AppNavigator />
              </AuthProvider>
            </QueryProvider>
          </NavigationContainer>
          <StatusBar style="auto" />
        </SafeAreaProvider>
      </ThemeProvider>
    </I18nProvider>
  );
}

===== FILE: apps/mobile/src/app/providers/AuthProvider.tsx =====
import {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef,
  useState,
  type ReactNode,
} from 'react';

import {
  ApiClientError,
  loginInputSchema,
  registerInputSchema,
  type AuthUser,
  type LoginInput,
  type MeResponse,
  type RegisterInput,
} from '@mintly/shared';
import { useQueryClient } from '@tanstack/react-query';
import * as SecureStore from 'expo-secure-store';
import i18n from 'i18next';

import { apiClient } from '@core/api/client';
import { apiErrorText } from '@shared/utils/apiErrorText';

const ACCESS_TOKEN_KEY = 'finsight.accessToken';
const REFRESH_TOKEN_KEY = 'finsight.refreshToken';

type AuthStatus = 'loading' | 'authenticated' | 'unauthenticated';
type SessionUser = MeResponse['user'];

interface AuthContextValue {
  status: AuthStatus;
  user: SessionUser | null;
  accessToken: string | null;
  refreshToken: string | null;
  authError: string | null;
  login: (input: LoginInput) => Promise<boolean>;
  register: (input: RegisterInput) => Promise<boolean>;
  logout: () => Promise<void>;
  withAuth: <T>(runner: (accessToken: string) => Promise<T>) => Promise<T>;
  refreshUser: () => Promise<SessionUser | null>;
  clearAuthError: () => void;
}

const AuthContext = createContext<AuthContextValue | null>(null);

async function persistTokens(accessToken: string, refreshToken: string): Promise<void> {
  await Promise.all([
    SecureStore.setItemAsync(ACCESS_TOKEN_KEY, accessToken),
    SecureStore.setItemAsync(REFRESH_TOKEN_KEY, refreshToken),
  ]);
}

async function clearStoredTokens(): Promise<void> {
  await Promise.all([
    SecureStore.deleteItemAsync(ACCESS_TOKEN_KEY),
    SecureStore.deleteItemAsync(REFRESH_TOKEN_KEY),
  ]);
}

function toSessionUser(user: AuthUser): SessionUser {
  return {
    id: user.id,
    email: user.email,
    name: user.name,
    baseCurrency: null,
  };
}

export function AuthProvider({ children }: { children: ReactNode }) {
  const queryClient = useQueryClient();
  const [status, setStatus] = useState<AuthStatus>('loading');
  const [user, setUser] = useState<SessionUser | null>(null);
  const [accessToken, setAccessToken] = useState<string | null>(null);
  const [refreshToken, setRefreshToken] = useState<string | null>(null);
  const [authError, setAuthError] = useState<string | null>(null);
  const refreshPromiseRef = useRef<Promise<{ accessToken: string; refreshToken: string }> | null>(
    null,
  );

  const clearSession = useCallback(async () => {
    refreshPromiseRef.current = null;
    setUser(null);
    setAccessToken(null);
    setRefreshToken(null);
    await clearStoredTokens();
    queryClient.clear();
    setStatus('unauthenticated');
  }, [queryClient]);

  const setSession = useCallback(
    async (params: {
      accessToken: string;
      refreshToken: string;
      user: SessionUser;
    }) => {
      setAccessToken(params.accessToken);
      setRefreshToken(params.refreshToken);
      setUser(params.user);
      await persistTokens(params.accessToken, params.refreshToken);
      setStatus('authenticated');
    },
    [],
  );

  const refreshTokens = useCallback(async (activeRefreshToken: string) => {
    if (!refreshPromiseRef.current) {
      refreshPromiseRef.current = (async () => {
        const refreshed = await apiClient.refresh({ refreshToken: activeRefreshToken });

        setAccessToken(refreshed.accessToken);
        setRefreshToken(refreshed.refreshToken);
        await persistTokens(refreshed.accessToken, refreshed.refreshToken);
        setStatus('authenticated');

        return {
          accessToken: refreshed.accessToken,
          refreshToken: refreshed.refreshToken,
        };
      })()
        .catch(async (error: unknown) => {
          await clearSession();
          throw error;
        })
        .finally(() => {
          refreshPromiseRef.current = null;
        });
    }

    return refreshPromiseRef.current;
  }, [clearSession]);

  const withAuth = useCallback(
    async <T,>(runner: (token: string) => Promise<T>): Promise<T> => {
      if (!accessToken) {
        throw new ApiClientError({
          code: 'UNAUTHORIZED',
          message: i18n.t('errors.auth.sessionNotAvailable', { defaultValue: 'Session not available' }),
          status: 401,
        });
      }

      try {
        return await runner(accessToken);
      } catch (error) {
        if (!(error instanceof ApiClientError) || error.status !== 401) {
          throw error;
        }

        if (!refreshToken) {
          await clearSession();
          throw error;
        }

        const refreshed = await refreshTokens(refreshToken);
        return runner(refreshed.accessToken);
      }
    },
    [accessToken, clearSession, refreshToken, refreshTokens],
  );

  const refreshUser = useCallback(async (): Promise<SessionUser | null> => {
    try {
      const me = await withAuth((token) => apiClient.getMe(token));
      setUser(me.user);
      return me.user;
    } catch {
      return null;
    }
  }, [withAuth]);

  const restoreSession = useCallback(async () => {
    setStatus('loading');

    const [storedAccessToken, storedRefreshToken] = await Promise.all([
      SecureStore.getItemAsync(ACCESS_TOKEN_KEY),
      SecureStore.getItemAsync(REFRESH_TOKEN_KEY),
    ]);

    if (!storedAccessToken || !storedRefreshToken) {
      await clearSession();
      return;
    }

    try {
      const me = await apiClient.getMe(storedAccessToken);
      await setSession({
        accessToken: storedAccessToken,
        refreshToken: storedRefreshToken,
        user: me.user,
      });
      return;
    } catch (error) {
      if (!(error instanceof ApiClientError) || error.status !== 401) {
        await clearSession();
        return;
      }
    }

    try {
      const refreshed = await apiClient.refresh({ refreshToken: storedRefreshToken });
      const me = await apiClient.getMe(refreshed.accessToken);

      await setSession({
        accessToken: refreshed.accessToken,
        refreshToken: refreshed.refreshToken,
        user: me.user,
      });
    } catch {
      await clearSession();
    }
  }, [clearSession, setSession]);

  useEffect(() => {
    void restoreSession();
  }, [restoreSession]);

  const login = useCallback(
    async (input: LoginInput): Promise<boolean> => {
      const validation = loginInputSchema.safeParse(input);
      if (!validation.success) {
        setAuthError(i18n.t('auth.validation.loginInvalidInput', { defaultValue: 'Please enter a valid email and password.' }));
        return false;
      }

      setAuthError(null);

      try {
        const response = await apiClient.login(validation.data);
        const me = await apiClient
          .getMe(response.accessToken)
          .then((result) => result.user)
          .catch(() => toSessionUser(response.user));

        await setSession({
          accessToken: response.accessToken,
          refreshToken: response.refreshToken,
          user: me,
        });
        return true;
      } catch (error) {
        setAuthError(apiErrorText(error));
        return false;
      }
    },
    [setSession],
  );

  const register = useCallback(
    async (input: RegisterInput): Promise<boolean> => {
      const validation = registerInputSchema.safeParse(input);
      if (!validation.success) {
        setAuthError(i18n.t('auth.validation.registerInvalidInput', { defaultValue: 'Please check your registration details.' }));
        return false;
      }

      setAuthError(null);

      try {
        const response = await apiClient.register(validation.data);
        const me = await apiClient
          .getMe(response.accessToken)
          .then((result) => result.user)
          .catch(() => toSessionUser(response.user));

        await setSession({
          accessToken: response.accessToken,
          refreshToken: response.refreshToken,
          user: me,
        });
        return true;
      } catch (error) {
        setAuthError(apiErrorText(error));
        return false;
      }
    },
    [setSession],
  );

  const logout = useCallback(async () => {
    const activeRefreshToken = refreshToken;

    if (activeRefreshToken) {
      try {
        await apiClient.logout({ refreshToken: activeRefreshToken });
      } catch {
        // Ignore logout request failures and clear local session anyway.
      }
    }

    setAuthError(null);
    await clearSession();
  }, [clearSession, refreshToken]);

  const clearAuthError = useCallback(() => {
    setAuthError(null);
  }, []);

  const value = useMemo<AuthContextValue>(
    () => ({
      status,
      user,
      accessToken,
      refreshToken,
      authError,
      login,
      register,
      logout,
      withAuth,
      refreshUser,
      clearAuthError,
    }),
    [
      status,
      user,
      accessToken,
      refreshToken,
      authError,
      login,
      register,
      logout,
      withAuth,
      refreshUser,
      clearAuthError,
    ],
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth(): AuthContextValue {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used inside AuthProvider');
  }

  return context;
}

===== FILE: apps/mobile/src/app/providers/QueryProvider.tsx =====
import type { ReactNode } from 'react';

import { QueryClientProvider } from '@tanstack/react-query';

import { queryClient } from '@core/api/queryClient';

interface QueryProviderProps {
  children: ReactNode;
}

export function QueryProvider({ children }: QueryProviderProps) {
  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;
}

===== FILE: apps/mobile/src/app/providers/ThemeProvider.tsx =====
export { ThemeProvider, useTheme } from '@shared/theme';

===== FILE: apps/mobile/src/core/api/client.ts =====
import { createApiClient } from '@mintly/shared';

export const apiClient = createApiClient({
  baseUrl: process.env.EXPO_PUBLIC_API_BASE_URL,
});

===== FILE: apps/mobile/src/core/api/queryClient.ts =====
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      staleTime: 30 * 1000,
    },
    mutations: {
      retry: 0,
    },
  },
});

===== FILE: apps/mobile/src/core/api/queryKeys.ts =====
import type { CategoryType } from '@mintly/shared';

export const financeQueryKeys = {
  dashboard: {
    recent: () => ['dashboard', 'recent'] as const,
  },
  accounts: {
    all: () => ['accounts'] as const,
    list: () => ['accounts', 'list'] as const,
  },
  categories: {
    all: () => ['categories'] as const,
    list: () => ['categories', 'list'] as const,
  },
  transactions: {
    all: () => ['transactions'] as const,
    list: (filters: Record<string, unknown>) => ['transactions', 'list', filters] as const,
  },
  recurring: {
    all: () => ['recurring'] as const,
    list: (filters: Record<string, unknown>) => ['recurring', 'list', filters] as const,
  },
  analytics: {
    all: () => ['analytics'] as const,
    month: (month: string) => ['analytics', month] as const,
    summary: (month: string) => ['analytics', month, 'summary'] as const,
    byCategory: (month: string, type: CategoryType) =>
      ['analytics', month, 'by-category', type] as const,
    trend: (month: string, from: string, to: string) =>
      ['analytics', month, 'trend', { from, to }] as const,
  },
  ai: {
    all: () => ['ai'] as const,
    advice: (month: string) => ['ai', 'advice', month] as const,
  },
  reports: {
    all: () => ['reports'] as const,
    weekly: (weekStart?: string) => ['reports', 'weekly', weekStart ?? 'current'] as const,
  },
  groups: {
    all: () => ['groups'] as const,
    list: () => ['groups', 'list'] as const,
    detail: (groupId: string) => ['groups', 'detail', groupId] as const,
    expenses: (groupId: string) => ['groups', 'expenses', groupId] as const,
  },
  budgets: {
    all: () => ['budgets'] as const,
    month: (month: string) => ['budgets', month] as const,
    list: (month: string) => ['budgets', month, 'list'] as const,
  },
};

===== FILE: apps/mobile/src/core/navigation/AddTabButton.tsx =====
import { Pressable, StyleSheet, Text, View, type GestureResponderEvent } from 'react-native';

import { AppIcon } from '@shared/ui';
import { I18N_KEYS } from '@shared/i18n/keys';
import { useT } from '@shared/i18n/t';
import { radius, spacing, typography, useTheme } from '@shared/theme';

interface AddTabButtonProps {
  onPress?: (event: GestureResponderEvent) => void;
}

export function AddTabButton({ onPress }: AddTabButtonProps) {
  const { theme } = useTheme();
  const t = useT();

  return (
    <View style={styles.container}>
      <Pressable
        onPress={onPress}
        style={({ pressed }) => [
          styles.button,
          {
            backgroundColor: theme.colors.primary,
            borderColor: theme.colors.surface,
            shadowColor: theme.shadows.card.shadowColor,
            shadowOpacity: theme.shadows.card.shadowOpacity,
            shadowRadius: theme.shadows.card.shadowRadius,
            shadowOffset: theme.shadows.card.shadowOffset,
            elevation: theme.shadows.card.elevation,
          },
          pressed && styles.buttonPressed,
        ]}
      >
        <AppIcon name="add" size="lg" tone="inverse" />
      </Pressable>
      <Text style={[styles.label, { color: theme.colors.textMuted }]}>
        {t(I18N_KEYS.common.navigation.tabs.add.label)}
      </Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginTop: -20,
    alignItems: 'center',
    gap: spacing.xxs,
  },
  button: {
    width: 58,
    height: 58,
    borderRadius: radius.full,
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 4,
  },
  buttonPressed: {
    opacity: 0.9,
    transform: [{ scale: 0.98 }],
  },
  label: {
    ...typography.caption,
  },
});

===== FILE: apps/mobile/src/core/navigation/AppNavigator.tsx =====
import { useCallback, useEffect, useState } from 'react';
import { ActivityIndicator, StyleSheet, Text, View } from 'react-native';

import { useAuth } from '@app/providers/AuthProvider';
import { OnboardingNavigator } from '@features/onboarding/screens/OnboardingNavigator';
import {
  getOnboardingCompleted,
  setOnboardingCompleted,
} from '@features/onboarding/screens/onboardingStorage';
import { useI18n } from '@shared/i18n';
import { typography, useTheme } from '@shared/theme';

import { AuthStack } from './AuthStack';
import { RootTabs } from './RootTabs';

type OnboardingStatus = 'loading' | 'pending' | 'completed';

export function AppNavigator() {
  const { status } = useAuth();
  const { theme } = useTheme();
  const { t } = useI18n();
  const [onboardingStatus, setOnboardingStatus] = useState<OnboardingStatus>('loading');

  useEffect(() => {
    let isMounted = true;

    void (async () => {
      const completed = await getOnboardingCompleted();
      if (isMounted) {
        setOnboardingStatus(completed ? 'completed' : 'pending');
      }
    })();

    return () => {
      isMounted = false;
    };
  }, []);

  const finishOnboarding = useCallback(() => {
    void (async () => {
      await setOnboardingCompleted(true);
      setOnboardingStatus('completed');
    })();
  }, []);

  if (onboardingStatus === 'loading') {
    return (
      <View style={[styles.splash, { backgroundColor: theme.colors.background }]}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={[styles.splashText, { color: theme.colors.textMuted }]}>{t('app.state.preparing')}</Text>
      </View>
    );
  }

  if (onboardingStatus === 'pending') {
    return <OnboardingNavigator mode="gate" onFinished={finishOnboarding} />;
  }

  if (status === 'loading') {
    return (
      <View style={[styles.splash, { backgroundColor: theme.colors.background }]}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={[styles.splashText, { color: theme.colors.textMuted }]}>{t('app.state.restoring')}</Text>
      </View>
    );
  }

  if (status === 'authenticated') {
    return <RootTabs />;
  }

  return <AuthStack />;
}

const styles = StyleSheet.create({
  splash: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    gap: 12,
  },
  splashText: {
    ...typography.body,
  },
});

===== FILE: apps/mobile/src/core/navigation/AuthStack.tsx =====
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import { ForgotPasswordScreen } from '@features/auth/screens/ForgotPasswordScreen';
import { LoginScreen } from '@features/auth/screens/LoginScreen';
import { RegisterScreen } from '@features/auth/screens/RegisterScreen';

import type { AuthStackParamList } from './types';

const Stack = createNativeStackNavigator<AuthStackParamList>();

export function AuthStack() {
  return (
    <Stack.Navigator
      initialRouteName="Login"
      screenOptions={{
        headerShown: false,
        keyboardHandlingEnabled: false,
      }}
    >
      <Stack.Screen name="Login" component={LoginScreen} />
      <Stack.Screen name="Register" component={RegisterScreen} />
      <Stack.Screen
        name="ForgotPassword"
        component={ForgotPasswordScreen}
      />
    </Stack.Navigator>
  );
}

===== FILE: apps/mobile/src/core/navigation/ModuleStackNavigator.tsx =====
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import { createStackOptions } from './createStackOptions';
import { I18N_KEYS } from '@shared/i18n/keys';
import { useT } from '@shared/i18n/t';
import { moduleLabels } from '@core/stitch/moduleLabels';
import type { StitchModule } from '@core/stitch/screenInventory';
import { getScreenByKey } from '@core/stitch/screenInventory';
import { ModuleHubScreen } from '@features/stitch/screens/ModuleHubScreen';
import { StitchPreviewScreen } from '@features/stitch/screens/StitchPreviewScreen';
import { useTheme } from '@shared/theme';

import type { ModuleStackParamList } from './types';

const Stack = createNativeStackNavigator<ModuleStackParamList>();

interface ModuleStackNavigatorProps {
  title: string;
  subtitle: string;
  modules: StitchModule[];
}

export function ModuleStackNavigator({ title, subtitle, modules }: ModuleStackNavigatorProps) {
  const { theme } = useTheme();
  const t = useT();

  return (
    <Stack.Navigator screenOptions={createStackOptions(theme)}>
      <Stack.Screen name="Hub" options={{ title }}>
        {(props) => <ModuleHubScreen {...props} title={title} subtitle={subtitle} modules={modules} />}
      </Stack.Screen>
      <Stack.Screen
        name="StitchPreview"
        component={StitchPreviewScreen}
        options={({ route }) => {
          const screen = getScreenByKey(route.params.screenKey);
          const previewSuffix = t(I18N_KEYS.common.navigation.preview.screen.header.suffix);
          return {
            title: screen
              ? `${t(moduleLabels[screen.module])} ${previewSuffix}`
              : t(I18N_KEYS.common.navigation.preview.screen.header.title),
          };
        }}
      />
    </Stack.Navigator>
  );
}

===== FILE: apps/mobile/src/core/navigation/RootTabs.tsx =====
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { StyleSheet, Text, View } from 'react-native';

import { AppIcon } from '@shared/ui';
import { I18N_KEYS } from '@shared/i18n/keys';
import { useT } from '@shared/i18n/t';
import { AddTransactionScreen } from '@features/finance/screens/AddTransactionScreen';
import { radius, spacing, typography, useTheme } from '@shared/theme';

import { AddTabButton } from './AddTabButton';
import { AnalyticsStack } from './stacks/AnalyticsStack';
import { GroupsStack } from './stacks/GroupsStack';
import { HomeStack } from './stacks/HomeStack';
import { ProfileStack } from './stacks/ProfileStack';
import { TransactionsStack } from './stacks/TransactionsStack';
import type { RootTabParamList } from './types';

const Tab = createBottomTabNavigator<RootTabParamList>();

function TabItem({
  icon,
  label,
  focused,
}: {
  icon: { active: Parameters<typeof AppIcon>[0]['name']; inactive: Parameters<typeof AppIcon>[0]['name'] };
  label: string;
  focused: boolean;
}) {
  const { theme } = useTheme();

  return (
    <View style={styles.tabItemWrap}>
      <AppIcon name={focused ? icon.active : icon.inactive} size="md" tone={focused ? 'primary' : 'muted'} />
      <Text
        style={[
          styles.tabLabel,
          {
            color: focused ? theme.colors.primary : theme.colors.textMuted,
            fontWeight: focused ? '700' : '600',
          },
        ]}
      >
        {label}
      </Text>
    </View>
  );
}

export function RootTabs() {
  const { theme } = useTheme();
  const t = useT();

  return (
    <Tab.Navigator
      screenOptions={{
        headerShown: false,
        tabBarShowLabel: false,
        tabBarStyle: {
          height: 82,
          paddingBottom: 10,
          paddingTop: 8,
          borderTopWidth: 1,
          borderTopColor: theme.colors.border,
          backgroundColor: theme.colors.surface,
          borderTopLeftRadius: radius.lg,
          borderTopRightRadius: radius.lg,
        },
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.textMuted,
      }}
    >
      <Tab.Screen
        name="HomeTab"
        component={HomeStack}
        options={{
          title: t(I18N_KEYS.common.navigation.tabs.home.label),
          tabBarIcon: ({ focused }) => (
            <TabItem
              focused={focused}
              icon={{ active: 'home', inactive: 'home-outline' }}
              label={t(I18N_KEYS.common.navigation.tabs.home.label)}
            />
          ),
        }}
      />

      <Tab.Screen
        name="TransactionsTab"
        component={TransactionsStack}
        options={{
          title: t(I18N_KEYS.common.navigation.tabs.transactions.label),
          tabBarIcon: ({ focused }) => (
            <TabItem
              focused={focused}
              icon={{ active: 'receipt', inactive: 'receipt-outline' }}
              label={t(I18N_KEYS.common.navigation.tabs.transactions.shortLabel)}
            />
          ),
        }}
      />

      <Tab.Screen
        name="AnalyticsTab"
        component={AnalyticsStack}
        options={{
          title: t(I18N_KEYS.common.navigation.tabs.analytics.label),
          tabBarIcon: ({ focused }) => (
            <TabItem
              focused={focused}
              icon={{ active: 'bar-chart', inactive: 'bar-chart-outline' }}
              label={t(I18N_KEYS.common.navigation.tabs.analytics.shortLabel)}
            />
          ),
        }}
      />

      <Tab.Screen
        name="GroupsTab"
        component={GroupsStack}
        options={{
          title: t(I18N_KEYS.common.navigation.tabs.groups.label),
          tabBarIcon: ({ focused }) => (
            <TabItem
              focused={focused}
              icon={{ active: 'people', inactive: 'people-outline' }}
              label={t(I18N_KEYS.common.navigation.tabs.groups.shortLabel)}
            />
          ),
        }}
      />

      <Tab.Screen
        name="AddTab"
        component={AddTransactionScreen}
        options={{
          title: t(I18N_KEYS.common.navigation.tabs.add.label),
          tabBarButton: ({ onPress }) => <AddTabButton onPress={onPress} />,
          tabBarIcon: () => null,
          headerShown: false,
        }}
      />

      <Tab.Screen
        name="ProfileTab"
        component={ProfileStack}
        options={{
          title: t(I18N_KEYS.common.navigation.tabs.profile.label),
          tabBarIcon: ({ focused }) => (
            <TabItem
              focused={focused}
              icon={{ active: 'person', inactive: 'person-outline' }}
              label={t(I18N_KEYS.common.navigation.tabs.profile.shortLabel)}
            />
          ),
        }}
      />
    </Tab.Navigator>
  );
}

const styles = StyleSheet.create({
  tabItemWrap: {
    alignItems: 'center',
    justifyContent: 'center',
    gap: spacing.xxs,
    minWidth: 50,
    paddingTop: 2,
  },
  tabLabel: {
    ...typography.caption,
    fontSize: 10,
  },
});

===== FILE: apps/mobile/src/core/navigation/createStackOptions.ts =====
import type { NativeStackNavigationOptions } from '@react-navigation/native-stack';

import type { AppTheme } from '@shared/theme';

export function createStackOptions(theme: AppTheme): NativeStackNavigationOptions {
  return {
    keyboardHandlingEnabled: false,
    gestureEnabled: true,
    headerBackButtonDisplayMode: 'minimal',
    headerShadowVisible: false,
    headerTintColor: theme.colors.text,
    headerStyle: {
      backgroundColor: theme.colors.surface,
    },
    headerTitleStyle: {
      fontSize: 18,
      fontWeight: '700',
    },
    contentStyle: {
      backgroundColor: theme.colors.background,
    },
  };
}

===== FILE: apps/mobile/src/core/navigation/stacks/AnalyticsStack.tsx =====
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import { I18N_KEYS } from '@shared/i18n/keys';
import { useT } from '@shared/i18n/t';
import { createStackOptions } from '../createStackOptions';
import { AiAdvisorScreen } from '@features/advisor/screens/AiAdvisorScreen';
import { AnalyticsScreen } from '@features/finance/screens/AnalyticsScreen';
import { BudgetsScreen } from '@features/finance/screens/BudgetsScreen';
import { WeeklyReportScreen } from '@features/advisor/screens/WeeklyReportScreen';
import { useTheme } from '@shared/theme';

export type AnalyticsStackParamList = {
  Analytics: undefined;
  Budgets: undefined;
  AiAdvisor: undefined;
  WeeklyReport: undefined;
};

const Stack = createNativeStackNavigator<AnalyticsStackParamList>();

export function AnalyticsStack() {
  const { theme } = useTheme();
  const t = useT();

  return (
    <Stack.Navigator screenOptions={createStackOptions(theme)}>
      <Stack.Screen
        name="Analytics"
        component={AnalyticsScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.analytics.headerTitle) }}
      />
      <Stack.Screen
        name="AiAdvisor"
        component={AiAdvisorScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.aiAdvisor.headerTitle) }}
      />
      <Stack.Screen
        name="WeeklyReport"
        component={WeeklyReportScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.weeklyReport.headerTitle) }}
      />
      <Stack.Screen
        name="Budgets"
        component={BudgetsScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.budgets.headerTitle) }}
      />
    </Stack.Navigator>
  );
}

===== FILE: apps/mobile/src/core/navigation/stacks/GroupsStack.tsx =====
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import { I18N_KEYS } from '@shared/i18n/keys';
import { useT } from '@shared/i18n/t';
import { AddGroupExpenseScreen } from '@features/groups/screens/AddGroupExpenseScreen';
import { CreateGroupScreen } from '@features/groups/screens/CreateGroupScreen';
import { GroupDetailScreen } from '@features/groups/screens/GroupDetailScreen';
import { GroupsScreen } from '@features/groups/screens/GroupsScreen';
import { SettleUpScreen } from '@features/groups/screens/SettleUpScreen';
import { useTheme } from '@shared/theme';

import { createStackOptions } from '../createStackOptions';

export type GroupsStackParamList = {
  Groups: undefined;
  CreateGroup: undefined;
  GroupDetail: { groupId: string };
  AddGroupExpense: { groupId: string };
  SettleUp: { groupId: string };
};

const Stack = createNativeStackNavigator<GroupsStackParamList>();

export function GroupsStack() {
  const { theme } = useTheme();
  const t = useT();

  return (
    <Stack.Navigator screenOptions={createStackOptions(theme)}>
      <Stack.Screen
        name="Groups"
        component={GroupsScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.groups.headerTitle) }}
      />
      <Stack.Screen
        name="CreateGroup"
        component={CreateGroupScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.createGroup.headerTitle) }}
      />
      <Stack.Screen
        name="GroupDetail"
        component={GroupDetailScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.groupDetail.headerTitle) }}
      />
      <Stack.Screen
        name="AddGroupExpense"
        component={AddGroupExpenseScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.addGroupExpense.headerTitle) }}
      />
      <Stack.Screen
        name="SettleUp"
        component={SettleUpScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.settleUp.headerTitle) }}
      />
    </Stack.Navigator>
  );
}

===== FILE: apps/mobile/src/core/navigation/stacks/HomeStack.tsx =====
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import { I18N_KEYS } from '@shared/i18n/keys';
import { useT } from '@shared/i18n/t';
import { createStackOptions } from '../createStackOptions';
import { DashboardScreen } from '@features/finance/screens/DashboardScreen';
import { useTheme } from '@shared/theme';

export type HomeStackParamList = {
  Dashboard: undefined;
};

const Stack = createNativeStackNavigator<HomeStackParamList>();

export function HomeStack() {
  const { theme } = useTheme();
  const t = useT();

  return (
    <Stack.Navigator screenOptions={createStackOptions(theme)}>
      <Stack.Screen
        name="Dashboard"
        component={DashboardScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.dashboard.headerTitle) }}
      />
    </Stack.Navigator>
  );
}

===== FILE: apps/mobile/src/core/navigation/stacks/ProfileStack.tsx =====
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import { I18N_KEYS } from '@shared/i18n/keys';
import { useT } from '@shared/i18n/t';
import { createStackOptions } from '../createStackOptions';
import { AccountsScreen } from '@features/finance/screens/AccountsScreen';
import { OnboardingNavigator } from '@features/onboarding/screens/OnboardingNavigator';
import { AboutScreen } from '@features/profile/screens/AboutScreen';
import { EditProfileScreen } from '@features/profile/screens/EditProfileScreen';
import { ProfileScreen } from '@features/profile/screens/ProfileScreen';
import { SecurityScreen } from '@features/profile/screens/SecurityScreen';
import { SettingsScreen } from '@features/profile/screens/SettingsScreen';
import { useTheme } from '@shared/theme';

export type ProfileStackParamList = {
  ProfileHome: undefined;
  EditProfile: undefined;
  Settings: undefined;
  Security: undefined;
  About: undefined;
  Accounts: undefined;
  HowItWorks: undefined;
};

const Stack = createNativeStackNavigator<ProfileStackParamList>();

export function ProfileStack() {
  const { theme } = useTheme();
  const t = useT();

  return (
    <Stack.Navigator screenOptions={createStackOptions(theme)}>
      <Stack.Screen
        name="ProfileHome"
        component={ProfileScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.profile.headerTitle) }}
      />
      <Stack.Screen
        name="EditProfile"
        component={EditProfileScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.editProfile.headerTitle) }}
      />
      <Stack.Screen
        name="Settings"
        component={SettingsScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.settings.headerTitle) }}
      />
      <Stack.Screen
        name="Security"
        component={SecurityScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.security.headerTitle) }}
      />
      <Stack.Screen
        name="About"
        component={AboutScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.about.headerTitle) }}
      />
      <Stack.Screen
        name="Accounts"
        component={AccountsScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.accounts.headerTitle) }}
      />
      <Stack.Screen
        name="HowItWorks"
        options={{ headerShown: false }}
      >
        {({ navigation }) => (
          <OnboardingNavigator mode="preview" onFinished={() => navigation.goBack()} />
        )}
      </Stack.Screen>
    </Stack.Navigator>
  );
}

===== FILE: apps/mobile/src/core/navigation/stacks/TransactionsStack.tsx =====
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import { createStackOptions } from '../createStackOptions';
import { I18N_KEYS } from '@shared/i18n/keys';
import { useT } from '@shared/i18n/t';
import { ScanCameraScreen } from '@features/scan/screens/ScanCameraScreen';
import { ScanHomeScreen } from '@features/scan/screens/ScanHomeScreen';
import { ScanReviewScreen } from '@features/scan/screens/ScanReviewScreen';
import { AddGroupExpenseScreen } from '@features/groups/screens/AddGroupExpenseScreen';
import { CreateGroupScreen } from '@features/groups/screens/CreateGroupScreen';
import { GroupDetailScreen } from '@features/groups/screens/GroupDetailScreen';
import { GroupsScreen } from '@features/groups/screens/GroupsScreen';
import { SettleUpScreen } from '@features/groups/screens/SettleUpScreen';
import { RecurringScreen } from '@features/finance/screens/RecurringScreen';
import { TransactionDetailScreen } from '@features/finance/screens/TransactionDetailScreen';
import { TransferScreen } from '@features/finance/screens/TransferScreen';
import { TransactionsScreen } from '@features/finance/screens/TransactionsScreen';
import { useTheme } from '@shared/theme';

export type TransactionsStackParamList = {
  Transactions: undefined;
  TransactionDetail: { transactionId: string };
  Transfer: undefined;
  Recurring: undefined;
  ScanHome: undefined;
  ScanCamera: undefined;
  ScanReview: { photoUri: string };
  Groups: undefined;
  CreateGroup: undefined;
  GroupDetail: { groupId: string };
  AddGroupExpense: { groupId: string };
  SettleUp: { groupId: string };
};

const Stack = createNativeStackNavigator<TransactionsStackParamList>();

export function TransactionsStack() {
  const { theme } = useTheme();
  const t = useT();

  return (
    <Stack.Navigator screenOptions={createStackOptions(theme)}>
      <Stack.Screen
        name="Transactions"
        component={TransactionsScreen}
        options={{ headerShown: false }}
      />
      <Stack.Screen
        name="TransactionDetail"
        component={TransactionDetailScreen}
        options={{ headerShown: false }}
      />
      <Stack.Screen
        name="Transfer"
        component={TransferScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.transfer.headerTitle) }}
      />
      <Stack.Screen
        name="Recurring"
        component={RecurringScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.recurring.headerTitle) }}
      />
      <Stack.Screen
        name="ScanHome"
        component={ScanHomeScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.scanReceipt.headerTitle) }}
      />
      <Stack.Screen
        name="ScanCamera"
        component={ScanCameraScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.camera.headerTitle) }}
      />
      <Stack.Screen
        name="ScanReview"
        component={ScanReviewScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.reviewScan.headerTitle) }}
      />
      <Stack.Screen
        name="Groups"
        component={GroupsScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.groups.headerTitle) }}
      />
      <Stack.Screen
        name="CreateGroup"
        component={CreateGroupScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.createGroup.headerTitle) }}
      />
      <Stack.Screen
        name="GroupDetail"
        component={GroupDetailScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.groupDetail.headerTitle) }}
      />
      <Stack.Screen
        name="AddGroupExpense"
        component={AddGroupExpenseScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.addGroupExpense.headerTitle) }}
      />
      <Stack.Screen
        name="SettleUp"
        component={SettleUpScreen}
        options={{ title: t(I18N_KEYS.common.navigation.stacks.settleUp.headerTitle) }}
      />
    </Stack.Navigator>
  );
}

===== FILE: apps/mobile/src/core/navigation/types.ts =====
import type { NavigatorScreenParams } from '@react-navigation/native';

import type { AnalyticsStackParamList } from './stacks/AnalyticsStack';
import type { GroupsStackParamList } from './stacks/GroupsStack';
import type { HomeStackParamList } from './stacks/HomeStack';
import type { ProfileStackParamList } from './stacks/ProfileStack';
import type { TransactionsStackParamList } from './stacks/TransactionsStack';

export type ModuleStackParamList = {
  Hub: undefined;
  StitchPreview: { screenKey: string };
};

export type RootTabParamList = {
  HomeTab: NavigatorScreenParams<HomeStackParamList>;
  TransactionsTab: NavigatorScreenParams<TransactionsStackParamList>;
  AnalyticsTab: NavigatorScreenParams<AnalyticsStackParamList>;
  GroupsTab: NavigatorScreenParams<GroupsStackParamList>;
  AddTab:
    | {
        prefill?: {
          amount?: string;
          description?: string;
          occurredAt?: string;
        };
      }
    | undefined;
  ProfileTab: NavigatorScreenParams<ProfileStackParamList>;
};

export type AuthStackParamList = {
  DebugInput: undefined;
  Login: undefined;
  Register: undefined;
  ForgotPassword: undefined;
};

===== FILE: apps/mobile/src/core/stitch/moduleLabels.ts =====
import type { StitchModule } from './screenInventory';

export const moduleLabels: Record<StitchModule, string> = {
  dashboard: 'stitch.modules.dashboard',
  transactions: 'stitch.modules.transactions',
  analytics: 'stitch.modules.analytics',
  split: 'stitch.modules.split',
  scan: 'stitch.modules.scan',
  profile: 'stitch.modules.profile',
  auth: 'stitch.modules.auth',
  other: 'stitch.modules.other',
};

===== FILE: apps/mobile/src/core/stitch/screenInventory.ts =====
export type StitchModule = 'dashboard' | 'transactions' | 'analytics' | 'split' | 'scan' | 'profile' | 'auth' | 'other';

export interface StitchScreenDefinition {
  screenKey: string;
  folderName: string;
  folderPath: string;
  module: StitchModule;
  isDark: boolean;
  hasScreenPng: boolean;
  hasCodeHtml: boolean;
}

export const STITCH_SCREENS: StitchScreenDefinition[] = [
  {
    screenKey: "ai_tavsiyeleri_dark_1",
    folderName: "ai_tavsiyeleri_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ai_tavsiyeleri_(dark)_1",
    module: "analytics",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "ai_tavsiyeleri_dark_2",
    folderName: "ai_tavsiyeleri_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ai_tavsiyeleri_(dark)_2",
    module: "analytics",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "ai_tavsiyeleri_dark_3",
    folderName: "ai_tavsiyeleri_(dark)_3",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ai_tavsiyeleri_(dark)_3",
    module: "analytics",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "ai_tavsiyeleri_1",
    folderName: "ai_tavsiyeleri_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ai_tavsiyeleri_1",
    module: "analytics",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "ai_tavsiyeleri_2",
    folderName: "ai_tavsiyeleri_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ai_tavsiyeleri_2",
    module: "analytics",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "ana_ekran_dashboard_1",
    folderName: "ana_ekran_(dashboard)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ana_ekran_(dashboard)_1",
    module: "dashboard",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "ana_ekran_dashboard_2",
    folderName: "ana_ekran_(dashboard)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ana_ekran_(dashboard)_2",
    module: "dashboard",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "arkadaslarim_dark_1",
    folderName: "arkadaşlarım_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/arkadaşlarım_(dark)_1",
    module: "split",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "arkadaslarim_dark_2",
    folderName: "arkadaşlarım_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/arkadaşlarım_(dark)_2",
    module: "split",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "arkadaslarim_1",
    folderName: "arkadaşlarım_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/arkadaşlarım_1",
    module: "split",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "arkadaslarim_2",
    folderName: "arkadaşlarım_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/arkadaşlarım_2",
    module: "split",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "ayarlar_bildirim_baglantili",
    folderName: "ayarlar_(bildirim_bağlantılı)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ayarlar_(bildirim_bağlantılı)",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "ayarlar_dark_1",
    folderName: "ayarlar_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ayarlar_(dark)_1",
    module: "profile",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "ayarlar_dark_2",
    folderName: "ayarlar_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ayarlar_(dark)_2",
    module: "profile",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "ayarlar_destek_baglantili",
    folderName: "ayarlar_(destek_bağlantılı)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ayarlar_(destek_bağlantılı)",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "ayarlar_guncellendi_1",
    folderName: "ayarlar_(güncellendi)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ayarlar_(güncellendi)_1",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "ayarlar_guncellendi_2",
    folderName: "ayarlar_(güncellendi)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ayarlar_(güncellendi)_2",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "ayarlar_1",
    folderName: "ayarlar_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ayarlar_1",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "ayarlar_2",
    folderName: "ayarlar_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ayarlar_2",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "basarili_giris_yonlendirmesi",
    folderName: "başarılı_giriş_yönlendirmesi",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/başarılı_giriş_yönlendirmesi",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "bekleyen_istekler",
    folderName: "bekleyen_i̇stekler",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/bekleyen_i̇stekler",
    module: "other",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "bekleyen_istekler_dark",
    folderName: "bekleyen_i̇stekler_(dark)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/bekleyen_i̇stekler_(dark)",
    module: "other",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "bildirim_ayarlari_dark",
    folderName: "bildirim_ayarları_(dark)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/bildirim_ayarları_(dark)",
    module: "profile",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "borc_kapatma",
    folderName: "borç_kapatma",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/borç_kapatma",
    module: "analytics",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "borc_kapatma_dark_1",
    folderName: "borç_kapatma_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/borç_kapatma_(dark)_1",
    module: "analytics",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "borc_kapatma_dark_2",
    folderName: "borç_kapatma_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/borç_kapatma_(dark)_2",
    module: "analytics",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "borc_kapatma_guncel",
    folderName: "borç_kapatma_(güncel)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/borç_kapatma_(güncel)",
    module: "analytics",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "borc_kapatma_rehberi",
    folderName: "borç_kapatma_rehberi",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/borç_kapatma_rehberi",
    module: "analytics",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "borc_kapatma_rehberi_dark_1",
    folderName: "borç_kapatma_rehberi_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/borç_kapatma_rehberi_(dark)_1",
    module: "analytics",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "borc_kapatma_rehberi_dark_2",
    folderName: "borç_kapatma_rehberi_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/borç_kapatma_rehberi_(dark)_2",
    module: "analytics",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "butce_asimi_bildirimi",
    folderName: "bütçe_aşımı_bildirimi",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/bütçe_aşımı_bildirimi",
    module: "analytics",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "butce_duzenleme",
    folderName: "bütçe_düzenleme",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/bütçe_düzenleme",
    module: "analytics",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "butce_planlama",
    folderName: "bütçe_planlama",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/bütçe_planlama",
    module: "analytics",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "dashboard_dark",
    folderName: "dashboard_(dark)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/dashboard_(dark)",
    module: "dashboard",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "dashboard_koyu_mod_1",
    folderName: "dashboard_(koyu_mod)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/dashboard_(koyu_mod)_1",
    module: "dashboard",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "dashboard_koyu_mod_2",
    folderName: "dashboard_(koyu_mod)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/dashboard_(koyu_mod)_2",
    module: "dashboard",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "dashboard_with_budget_widget",
    folderName: "dashboard_with_budget_widget",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/dashboard_with_budget_widget",
    module: "dashboard",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "dashboard_with_interactive_budget_widget",
    folderName: "dashboard_with_interactive_budget_widget",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/dashboard_with_interactive_budget_widget",
    module: "dashboard",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "detayli_ayarlar_paneli",
    folderName: "detaylı_ayarlar_paneli",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/detaylı_ayarlar_paneli",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "fatura_tarama_dark_1",
    folderName: "fatura_tarama_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/fatura_tarama_(dark)_1",
    module: "scan",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "fatura_tarama_dark_2",
    folderName: "fatura_tarama_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/fatura_tarama_(dark)_2",
    module: "scan",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "fatura_tarama_and_kayit_1",
    folderName: "fatura_tarama_&_kayıt_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/fatura_tarama_&_kayıt_1",
    module: "scan",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "fatura_tarama_and_kayit_2",
    folderName: "fatura_tarama_&_kayıt_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/fatura_tarama_&_kayıt_2",
    module: "scan",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "finansal_saglik_dark_1",
    folderName: "finansal_sağlık_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/finansal_sağlık_(dark)_1",
    module: "analytics",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "finansal_saglik_dark_2",
    folderName: "finansal_sağlık_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/finansal_sağlık_(dark)_2",
    module: "analytics",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "generated_screen",
    folderName: "generated_screen",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/generated_screen",
    module: "other",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "giris_dark",
    folderName: "giriş_(dark)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/giriş_(dark)",
    module: "auth",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "giris_yap_dark",
    folderName: "giriş_yap_(dark)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/giriş_yap_(dark)",
    module: "auth",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "giris_yap_goz_ikonlu",
    folderName: "giriş_yap_(göz_i̇konlu)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/giriş_yap_(göz_i̇konlu)",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "giris_yap_guncellendi_1",
    folderName: "giriş_yap_(güncellendi)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/giriş_yap_(güncellendi)_1",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "giris_yap_guncellendi_2",
    folderName: "giriş_yap_(güncellendi)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/giriş_yap_(güncellendi)_2",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "giris_yap_renk_guncellemesi",
    folderName: "giriş_yap_(renk_güncellemesi)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/giriş_yap_(renk_güncellemesi)",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "giris_yap_yeni_logo_1",
    folderName: "giriş_yap_(yeni_logo)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/giriş_yap_(yeni_logo)_1",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "giris_yap_yeni_logo_2",
    folderName: "giriş_yap_(yeni_logo)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/giriş_yap_(yeni_logo)_2",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "grup_detayi_dark_1",
    folderName: "grup_detayı_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/grup_detayı_(dark)_1",
    module: "split",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "grup_detayi_dark_2",
    folderName: "grup_detayı_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/grup_detayı_(dark)_2",
    module: "split",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "grup_detayi_1",
    folderName: "grup_detayı_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/grup_detayı_1",
    module: "split",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "grup_detayi_2",
    folderName: "grup_detayı_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/grup_detayı_2",
    module: "split",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "grup_harcamasi_ekle",
    folderName: "grup_harcaması_ekle",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/grup_harcaması_ekle",
    module: "split",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "grup_harcamasi_ekle_dark",
    folderName: "grup_harcaması_ekle_(dark)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/grup_harcaması_ekle_(dark)",
    module: "split",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "guncel_islem_gecmisi_borc_kapama_dahil",
    folderName: "güncel_i̇şlem_geçmişi_(borç_kapama_dahil)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/güncel_i̇şlem_geçmişi_(borç_kapama_dahil)",
    module: "transactions",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "guncel_makale_detayi",
    folderName: "güncel_makale_detayı",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/güncel_makale_detayı",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "guncel_yardim_makaleleri",
    folderName: "güncel_yardım_makaleleri",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/güncel_yardım_makaleleri",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "guvenlik_ve_gizlilik_ayarlari",
    folderName: "güvenlik_ve_gizlilik_ayarları",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/güvenlik_ve_gizlilik_ayarları",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "haftalik_finansal_saglik_raporu_1",
    folderName: "haftalık_finansal_sağlık_raporu_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/haftalık_finansal_sağlık_raporu_1",
    module: "analytics",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "haftalik_finansal_saglik_raporu_2",
    folderName: "haftalık_finansal_sağlık_raporu_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/haftalık_finansal_sağlık_raporu_2",
    module: "analytics",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "haftalik_rapor_koyu_mod",
    folderName: "haftalık_rapor_(koyu_mod)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/haftalık_rapor_(koyu_mod)",
    module: "analytics",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "harcama_analizi_koyu_mod_1",
    folderName: "harcama_analizi_(koyu_mod)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/harcama_analizi_(koyu_mod)_1",
    module: "transactions",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "harcama_analizi_koyu_mod_2",
    folderName: "harcama_analizi_(koyu_mod)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/harcama_analizi_(koyu_mod)_2",
    module: "transactions",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "harcama_analizi_detayi_1",
    folderName: "harcama_analizi_detayı_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/harcama_analizi_detayı_1",
    module: "transactions",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "harcama_analizi_detayi_2",
    folderName: "harcama_analizi_detayı_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/harcama_analizi_detayı_2",
    module: "transactions",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "harcama_gruplari_dark_1",
    folderName: "harcama_grupları_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/harcama_grupları_(dark)_1",
    module: "split",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "harcama_gruplari_dark_2",
    folderName: "harcama_grupları_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/harcama_grupları_(dark)_2",
    module: "split",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "harcama_gruplari_gelismis",
    folderName: "harcama_grupları_(gelişmiş)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/harcama_grupları_(gelişmiş)",
    module: "split",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "harcama_gruplari_1",
    folderName: "harcama_grupları_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/harcama_grupları_1",
    module: "split",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "harcama_gruplari_2",
    folderName: "harcama_grupları_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/harcama_grupları_2",
    module: "split",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "harcamayi_bol",
    folderName: "harcamayı_böl",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/harcamayı_böl",
    module: "split",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "harcamayi_bol_dark",
    folderName: "harcamayı_böl_(dark)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/harcamayı_böl_(dark)",
    module: "split",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "hatali_giris_denemesi",
    folderName: "hatalı_giriş_denemesi",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/hatalı_giriş_denemesi",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "hesap_kilitlendi",
    folderName: "hesap_kilitlendi",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/hesap_kilitlendi",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "hos_geldiniz_onboarding_1",
    folderName: "hoş_geldiniz_(onboarding)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/hoş_geldiniz_(onboarding)_1",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "hos_geldiniz_onboarding_2",
    folderName: "hoş_geldiniz_(onboarding)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/hoş_geldiniz_(onboarding)_2",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "islem_detayi_dark_1",
    folderName: "i̇şlem_detayı_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/i̇şlem_detayı_(dark)_1",
    module: "transactions",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "islem_detayi_dark_2",
    folderName: "i̇şlem_detayı_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/i̇şlem_detayı_(dark)_2",
    module: "transactions",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "islem_detayi_1",
    folderName: "i̇şlem_detayı_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/i̇şlem_detayı_1",
    module: "transactions",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "islem_detayi_2",
    folderName: "i̇şlem_detayı_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/i̇şlem_detayı_2",
    module: "transactions",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "islem_gecmisi_dark_1",
    folderName: "i̇şlem_geçmişi_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/i̇şlem_geçmişi_(dark)_1",
    module: "transactions",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "islem_gecmisi_dark_2",
    folderName: "i̇şlem_geçmişi_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/i̇şlem_geçmişi_(dark)_2",
    module: "transactions",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "islem_gecmisi_dark_3",
    folderName: "i̇şlem_geçmişi_(dark)_3",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/i̇şlem_geçmişi_(dark)_3",
    module: "transactions",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "islem_gecmisi_detayi_1",
    folderName: "i̇şlem_geçmişi_detayı_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/i̇şlem_geçmişi_detayı_1",
    module: "transactions",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "islem_gecmisi_detayi_2",
    folderName: "i̇şlem_geçmişi_detayı_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/i̇şlem_geçmişi_detayı_2",
    module: "transactions",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "kapsamli_bildirim_ayarlari",
    folderName: "kapsamlı_bildirim_ayarları",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/kapsamlı_bildirim_ayarları",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "kayit_ol_dark_mode_1",
    folderName: "kayıt_ol_(dark_mode)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/kayıt_ol_(dark_mode)_1",
    module: "auth",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "kayit_ol_dark_mode_2",
    folderName: "kayıt_ol_(dark_mode)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/kayıt_ol_(dark_mode)_2",
    module: "auth",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "kayit_ol_goz_ikonlu",
    folderName: "kayıt_ol_(göz_i̇konlu)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/kayıt_ol_(göz_i̇konlu)",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "kayit_ol_renk_guncellemesi",
    folderName: "kayıt_ol_(renk_güncellemesi)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/kayıt_ol_(renk_güncellemesi)",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "kayit_ol_telefon_eklendi",
    folderName: "kayıt_ol_(telefon_eklendi)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/kayıt_ol_(telefon_eklendi)",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "kayit_ol_yeni_logo_1",
    folderName: "kayıt_ol_(yeni_logo)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/kayıt_ol_(yeni_logo)_1",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "kayit_ol_yeni_logo_2",
    folderName: "kayıt_ol_(yeni_logo)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/kayıt_ol_(yeni_logo)_2",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "makale_detay_sayfasi",
    folderName: "makale_detay_sayfası",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/makale_detay_sayfası",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "makale_detayi_birikim_yontemleri",
    folderName: "makale_detayı_-_birikim_yöntemleri",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/makale_detayı_-_birikim_yöntemleri",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "nakit_odeme_onayi",
    folderName: "nakit_ödeme_onayı",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/nakit_ödeme_onayı",
    module: "transactions",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "nakit_odeme_onayi_dark",
    folderName: "nakit_ödeme_onayı_(dark)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/nakit_ödeme_onayı_(dark)",
    module: "transactions",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "nasil_kullanilir",
    folderName: "nasıl_kullanılır?",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/nasıl_kullanılır?",
    module: "other",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "nasil_kullanilir_dark_1",
    folderName: "nasıl_kullanılır?_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/nasıl_kullanılır?_(dark)_1",
    module: "other",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "nasil_kullanilir_dark_2",
    folderName: "nasıl_kullanılır?_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/nasıl_kullanılır?_(dark)_2",
    module: "other",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "odeme_onayi",
    folderName: "ödeme_onayı",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ödeme_onayı",
    module: "transactions",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "odeme_onayi_dark",
    folderName: "ödeme_onayı_(dark)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/ödeme_onayı_(dark)",
    module: "transactions",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "profil_dark_1",
    folderName: "profil_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/profil_(dark)_1",
    module: "profile",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "profil_dark_2",
    folderName: "profil_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/profil_(dark)_2",
    module: "profile",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "profil_1",
    folderName: "profil_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/profil_1",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "profil_2",
    folderName: "profil_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/profil_2",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "profil_bilgilerini_duzenle",
    folderName: "profil_bilgilerini_düzenle",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/profil_bilgilerini_düzenle",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "profil_duzenle_dark",
    folderName: "profil_düzenle_(dark)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/profil_düzenle_(dark)",
    module: "profile",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "profil_duzenle_1",
    folderName: "profil_düzenle_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/profil_düzenle_1",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "profil_duzenle_2",
    folderName: "profil_düzenle_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/profil_düzenle_2",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "sms_dogrulama_otp_1",
    folderName: "sms_doğrulama_(otp)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/sms_doğrulama_(otp)_1",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "sms_dogrulama_otp_2",
    folderName: "sms_doğrulama_(otp)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/sms_doğrulama_(otp)_2",
    module: "auth",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "sifremi_unuttum_dark_1",
    folderName: "şifremi_unuttum_(dark)_1",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/şifremi_unuttum_(dark)_1",
    module: "auth",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "sifremi_unuttum_dark_2",
    folderName: "şifremi_unuttum_(dark)_2",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/şifremi_unuttum_(dark)_2",
    module: "auth",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: false,
  },
  {
    screenKey: "yardim_makaleleri",
    folderName: "yardım_makaleleri",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/yardım_makaleleri",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "yardim_merkezi_yeni_kategori",
    folderName: "yardım_merkezi_-_yeni_kategori",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/yardım_merkezi_-_yeni_kategori",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "yardim_merkezi_guncellendi",
    folderName: "yardım_merkezi_güncellendi",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/yardım_merkezi_güncellendi",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "yardim_ve_destek_dark",
    folderName: "yardım_ve_destek_(dark)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/yardım_ve_destek_(dark)",
    module: "profile",
    isDark: true,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "yardim_ve_destek_light",
    folderName: "yardım_ve_destek_(light)",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/yardım_ve_destek_(light)",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
  {
    screenKey: "yatirim_ve_tasarruf_makaleleri",
    folderName: "yatırım_ve_tasarruf_makaleleri",
    folderPath: "stitch/export/stitch_ana_ekran_dashboard/yatırım_ve_tasarruf_makaleleri",
    module: "profile",
    isDark: false,
    hasScreenPng: true,
    hasCodeHtml: true,
  },
];

export const STITCH_MODULE_COUNTS: Record<StitchModule, number> = {
  dashboard: 7,
  transactions: 18,
  analytics: 20,
  split: 17,
  scan: 4,
  profile: 30,
  auth: 24,
  other: 6,
};

export function getScreensByModule(modules: StitchModule[]): StitchScreenDefinition[] {
  const set = new Set(modules);
  return STITCH_SCREENS.filter((screen) => set.has(screen.module));
}

export function getScreenByKey(screenKey: string): StitchScreenDefinition | undefined {
  return STITCH_SCREENS.find((screen) => screen.screenKey === screenKey);
}

===== FILE: apps/mobile/src/features/advisor/index.ts =====
export { AiAdvisorScreen } from './screens/AiAdvisorScreen';
export { WeeklyReportScreen } from './screens/WeeklyReportScreen';

===== FILE: apps/mobile/src/features/advisor/screens/AiAdvisorScreen.tsx =====
import { useState } from 'react';
import { ActivityIndicator, Pressable, StyleSheet, Text, View } from 'react-native';

import type { AiAdviceSeverity } from '@mintly/shared';
import { useQuery } from '@tanstack/react-query';

import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { useAuth } from '@app/providers/AuthProvider';
import { Card, ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';
import { formatMonthLabel, getCurrentMonthString, shiftMonth } from '@shared/utils/month';

function formatMoney(amount: number, currency: string, locale: string): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

function withAlpha(hexColor: string, alpha: number): string {
  const color = hexColor.trim();
  const hex = color.startsWith('#') ? color.slice(1) : color;

  if (!/^[0-9a-fA-F]{6}$/.test(hex)) {
    return color;
  }

  const red = Number.parseInt(hex.slice(0, 2), 16);
  const green = Number.parseInt(hex.slice(2, 4), 16);
  const blue = Number.parseInt(hex.slice(4, 6), 16);
  return `rgba(${red}, ${green}, ${blue}, ${Math.max(0, Math.min(alpha, 1))})`;
}

function severityPalette(severity: AiAdviceSeverity, dark: boolean, primary: string, warning: string, success: string) {
  if (severity === 'warning') {
    return {
      border: withAlpha(warning, dark ? 0.6 : 0.35),
      background: withAlpha(warning, dark ? 0.14 : 0.08),
      text: warning,
      labelKey: 'aiAdvisor.severity.warning',
    };
  }

  if (severity === 'success') {
    return {
      border: withAlpha(success, dark ? 0.6 : 0.35),
      background: withAlpha(success, dark ? 0.14 : 0.08),
      text: success,
      labelKey: 'aiAdvisor.severity.success',
    };
  }

  return {
    border: withAlpha(primary, dark ? 0.55 : 0.3),
    background: withAlpha(primary, dark ? 0.16 : 0.09),
    text: primary,
    labelKey: 'aiAdvisor.severity.info',
  };
}

function LoadingState({ dark }: { dark: boolean }) {
  const tone = dark ? '#1D2435' : '#E9EEF8';

  return (
    <View style={styles.loadingWrap}>
      <View style={[styles.loadingBlockLarge, { backgroundColor: tone }]} />
      <View style={[styles.loadingBlock, { backgroundColor: tone }]} />
      <View style={[styles.loadingBlock, { backgroundColor: tone }]} />
      <View style={[styles.loadingBlock, { backgroundColor: tone }]} />
    </View>
  );
}

export function AiAdvisorScreen() {
  const { withAuth, user } = useAuth();
  const { theme, mode } = useTheme();
  const { locale, t } = useI18n();
  const [month, setMonth] = useState(getCurrentMonthString());

  const dark = mode === 'dark';

  const adviceQuery = useQuery({
    queryKey: financeQueryKeys.ai.advice(month),
    queryFn: () => withAuth((token) => apiClient.getAiAdvice({ month }, token)),
  });

  if (adviceQuery.isLoading && !adviceQuery.data) {
    return (
      <ScreenContainer dark={dark}>
        <LoadingState dark={dark} />
      </ScreenContainer>
    );
  }

  if (adviceQuery.isError && !adviceQuery.data) {
    return (
      <ScreenContainer dark={dark}>
        <Card dark={dark} style={styles.errorCard}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>{t('aiAdvisor.state.errorTitle')}</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(adviceQuery.error)}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  const data = adviceQuery.data;
  if (!data) {
    return (
      <ScreenContainer dark={dark}>
        <Card dark={dark}>
          <Text style={[styles.errorText, { color: theme.colors.textMuted }]}>{t('aiAdvisor.state.noData')}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  const currency = data.currency ?? user?.baseCurrency ?? 'TRY';

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.container}>
        <View style={styles.header}>
          <Text style={[styles.title, { color: theme.colors.text }]}>{t('aiAdvisor.title')}</Text>
          <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}>{t('aiAdvisor.subtitle')}</Text>
        </View>

        <View style={styles.monthRow}>
          <Pressable
            accessibilityRole="button"
            onPress={() => setMonth(shiftMonth(month, -1))}
            style={({ pressed }) => [styles.arrowButton, pressed && styles.pressed]}
          >
            <Text style={[styles.arrowText, { color: theme.colors.text }]}>{'<'}</Text>
          </Pressable>

          <Text style={[styles.monthLabel, { color: theme.colors.textMuted }]}>{formatMonthLabel(month)}</Text>

          <Pressable
            accessibilityRole="button"
            onPress={() => setMonth(shiftMonth(month, 1))}
            style={({ pressed }) => [styles.arrowButton, pressed && styles.pressed]}
          >
            <Text style={[styles.arrowText, { color: theme.colors.text }]}>{'>'}</Text>
          </Pressable>
        </View>

        <Card dark={dark} style={styles.totalsCard}>
          <Text style={[styles.totalsLabel, { color: theme.colors.textMuted }]}>{t('aiAdvisor.monthlySnapshot')}</Text>
          <View style={styles.totalsGrid}>
            <View style={styles.totalItem}>
              <Text style={[styles.totalItemLabel, { color: theme.colors.textMuted }]}>{t('aiAdvisor.income')}</Text>
              <Text style={[styles.totalItemValue, { color: theme.colors.income }]}>
                {formatMoney(data.totalIncome, currency, locale)}
              </Text>
            </View>
            <View style={styles.totalItem}>
              <Text style={[styles.totalItemLabel, { color: theme.colors.textMuted }]}>{t('aiAdvisor.expense')}</Text>
              <Text style={[styles.totalItemValue, { color: theme.colors.expense }]}>
                {formatMoney(data.totalExpense, currency, locale)}
              </Text>
            </View>
            <View style={styles.totalItem}>
              <Text style={[styles.totalItemLabel, { color: theme.colors.textMuted }]}>{t('aiAdvisor.net')}</Text>
              <Text
                style={[
                  styles.totalItemValue,
                  { color: data.net >= 0 ? theme.colors.income : theme.colors.expense },
                ]}
              >
                {formatMoney(data.net, currency, locale)}
              </Text>
            </View>
          </View>
        </Card>

        <View style={styles.sectionHeader}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>{t('aiAdvisor.advice')}</Text>
          {adviceQuery.isFetching ? <ActivityIndicator size="small" color={theme.colors.primary} /> : null}
        </View>

        {data.advice.length === 0 ? (
          <Card dark={dark}>
            <Text style={[styles.emptyText, { color: theme.colors.textMuted }]}>{t('aiAdvisor.noAdvice')}</Text>
          </Card>
        ) : null}

        {data.advice.map((item, index) => {
          const palette = severityPalette(
            item.severity,
            dark,
            theme.colors.primary,
            theme.colors.expense,
            theme.colors.income,
          );

          return (
            <Card
              key={`${item.title}-${index}`}
              dark={dark}
              style={[
                styles.adviceCard,
                {
                  borderColor: palette.border,
                  backgroundColor: palette.background,
                },
              ]}
            >
              <View style={styles.adviceTopRow}>
                <Text style={[styles.adviceTitle, { color: theme.colors.text }]}>{item.title}</Text>
                <View style={[styles.severityPill, { backgroundColor: palette.border }]}>
                  <Text style={[styles.severityText, { color: palette.text }]}>{t(palette.labelKey)}</Text>
                </View>
              </View>
              <Text style={[styles.adviceMessage, { color: theme.colors.textMuted }]}>{item.message}</Text>
            </Card>
          );
        })}

        <Card dark={dark} style={styles.actionsCard}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>{t('aiAdvisor.nextActions')}</Text>
          {data.nextActions.length === 0 ? (
            <Text style={[styles.emptyText, { color: theme.colors.textMuted }]}>{t('aiAdvisor.noActions')}</Text>
          ) : (
            <View style={styles.actionsList}>
              {data.nextActions.map((action, index) => (
                <View key={`${action}-${index}`} style={styles.actionRow}>
                  <View style={[styles.actionDot, { backgroundColor: theme.colors.primary }]} />
                  <Text style={[styles.actionText, { color: theme.colors.textMuted }]}>{action}</Text>
                </View>
              ))}
            </View>
          )}
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  header: {
    gap: spacing.xxs,
  },
  title: {
    ...typography.heading,
    fontSize: 26,
  },
  subtitle: {
    ...typography.body,
    fontSize: 14,
  },
  monthRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'center',
  },
  arrowButton: {
    alignItems: 'center',
    height: 30,
    justifyContent: 'center',
    width: 30,
  },
  arrowText: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  monthLabel: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '600',
    letterSpacing: 0.2,
    minWidth: 150,
    textAlign: 'center',
    textTransform: 'uppercase',
  },
  totalsCard: {
    gap: spacing.sm,
  },
  totalsLabel: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
    letterSpacing: 0.4,
    textTransform: 'uppercase',
  },
  totalsGrid: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: spacing.sm,
  },
  totalItem: {
    flex: 1,
    gap: spacing.xxs,
  },
  totalItemLabel: {
    ...typography.caption,
    fontSize: 11,
  },
  totalItemValue: {
    ...typography.subheading,
    fontSize: 16,
    fontWeight: '700',
  },
  sectionHeader: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  sectionTitle: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  adviceCard: {
    gap: spacing.xs,
  },
  adviceTopRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: spacing.xs,
  },
  adviceTitle: {
    ...typography.subheading,
    flex: 1,
    fontSize: 16,
    fontWeight: '700',
  },
  adviceMessage: {
    ...typography.body,
    fontSize: 14,
  },
  severityPill: {
    borderRadius: radius.full,
    paddingHorizontal: spacing.xs,
    paddingVertical: 4,
  },
  severityText: {
    ...typography.caption,
    fontSize: 10,
    fontWeight: '700',
    letterSpacing: 0.3,
    textTransform: 'uppercase',
  },
  actionsCard: {
    gap: spacing.xs,
  },
  actionsList: {
    gap: spacing.xs,
  },
  actionRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  actionDot: {
    borderRadius: radius.full,
    height: 8,
    width: 8,
  },
  actionText: {
    ...typography.body,
    flex: 1,
    fontSize: 14,
  },
  loadingWrap: {
    gap: spacing.sm,
  },
  loadingBlockLarge: {
    borderRadius: radius.lg,
    height: 140,
    width: '100%',
  },
  loadingBlock: {
    borderRadius: radius.md,
    height: 90,
    width: '100%',
  },
  errorCard: {
    gap: spacing.xs,
  },
  errorTitle: {
    ...typography.subheading,
    fontWeight: '700',
  },
  errorText: {
    ...typography.body,
  },
  emptyText: {
    ...typography.body,
  },
  pressed: {
    opacity: 0.85,
  },
});

===== FILE: apps/mobile/src/features/advisor/screens/WeeklyReportScreen.tsx =====
import { useState } from 'react';
import { ActivityIndicator, Pressable, StyleSheet, Text, View } from 'react-native';

import { useQuery } from '@tanstack/react-query';

import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { useAuth } from '@app/providers/AuthProvider';
import { Card, ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

const DAY_MS = 24 * 60 * 60 * 1000;

function toDateOnlyUtc(value: Date): string {
  const year = value.getUTCFullYear();
  const month = String(value.getUTCMonth() + 1).padStart(2, '0');
  const day = String(value.getUTCDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function parseDateOnlyUtc(value: string): Date {
  const [yearRaw, monthRaw, dayRaw] = value.split('-');
  const year = Number(yearRaw);
  const month = Number(monthRaw);
  const day = Number(dayRaw);
  return new Date(Date.UTC(year, month - 1, day, 0, 0, 0, 0));
}

function getCurrentWeekStartString(): string {
  const now = new Date();
  const weekday = now.getUTCDay();
  const offset = weekday === 0 ? -6 : 1 - weekday;
  const monday = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + offset));
  return toDateOnlyUtc(monday);
}

function shiftWeek(weekStart: string, deltaWeeks: number): string {
  const start = parseDateOnlyUtc(weekStart);
  return toDateOnlyUtc(new Date(start.getTime() + deltaWeeks * 7 * DAY_MS));
}

function formatRange(start: string, locale: string): string {
  const startDate = parseDateOnlyUtc(start);
  const endDate = new Date(startDate.getTime() + 6 * DAY_MS);

  const startLabel = startDate.toLocaleDateString(locale, { month: 'short', day: 'numeric', timeZone: 'UTC' });
  const endLabel = endDate.toLocaleDateString(locale, { month: 'short', day: 'numeric', timeZone: 'UTC' });
  return `${startLabel} - ${endLabel}`;
}

function scoreTone(score: number): 'good' | 'medium' | 'risky' {
  if (score >= 80) {
    return 'good';
  }
  if (score >= 60) {
    return 'medium';
  }
  return 'risky';
}

function LoadingState({ dark }: { dark: boolean }) {
  const tone = dark ? '#1D2435' : '#E9EEF8';

  return (
    <View style={styles.loadingWrap}>
      <View style={[styles.loadingScore, { backgroundColor: tone }]} />
      <View style={[styles.loadingBlock, { backgroundColor: tone }]} />
      <View style={[styles.loadingBlock, { backgroundColor: tone }]} />
      <View style={[styles.loadingBlock, { backgroundColor: tone }]} />
    </View>
  );
}

export function WeeklyReportScreen() {
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();
  const { locale, t } = useI18n();
  const [weekStart, setWeekStart] = useState(getCurrentWeekStartString());

  const dark = mode === 'dark';

  const reportQuery = useQuery({
    queryKey: financeQueryKeys.reports.weekly(weekStart),
    queryFn: () => withAuth((token) => apiClient.getWeeklyReport({ weekStart }, token)),
  });

  if (reportQuery.isLoading && !reportQuery.data) {
    return (
      <ScreenContainer dark={dark}>
        <LoadingState dark={dark} />
      </ScreenContainer>
    );
  }

  if (reportQuery.isError && !reportQuery.data) {
    return (
      <ScreenContainer dark={dark}>
        <Card dark={dark} style={styles.errorCard}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>{t('weeklyReport.state.errorTitle')}</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(reportQuery.error)}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  const report = reportQuery.data;
  if (!report) {
    return (
      <ScreenContainer dark={dark}>
        <Card dark={dark}>
          <Text style={[styles.errorText, { color: theme.colors.textMuted }]}>{t('weeklyReport.state.noData')}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  const tone = scoreTone(report.healthScore);
  const scoreColor =
    tone === 'good' ? theme.colors.income : tone === 'medium' ? theme.colors.primary : theme.colors.expense;

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.container}>
        <View style={styles.header}>
          <Text style={[styles.title, { color: theme.colors.text }]}>{t('weeklyReport.title')}</Text>
          <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}>{t('weeklyReport.subtitle')}</Text>
        </View>

        <View style={styles.weekRow}>
          <Pressable
            accessibilityRole="button"
            onPress={() => setWeekStart(shiftWeek(weekStart, -1))}
            style={({ pressed }) => [styles.arrowButton, pressed && styles.pressed]}
          >
            <Text style={[styles.arrowText, { color: theme.colors.text }]}>{'<'}</Text>
          </Pressable>

          <Text style={[styles.weekLabel, { color: theme.colors.textMuted }]}>{formatRange(weekStart, locale)}</Text>

          <Pressable
            accessibilityRole="button"
            onPress={() => setWeekStart(shiftWeek(weekStart, 1))}
            style={({ pressed }) => [styles.arrowButton, pressed && styles.pressed]}
          >
            <Text style={[styles.arrowText, { color: theme.colors.text }]}>{'>'}</Text>
          </Pressable>
        </View>

        <Card dark={dark} style={styles.scoreCard}>
          <View style={[styles.scoreCircle, { borderColor: scoreColor }]}> 
            <Text style={[styles.scoreValue, { color: scoreColor }]}>{report.healthScore}</Text>
            <Text style={[styles.scoreCaption, { color: theme.colors.textMuted }]}>{t('weeklyReport.scoreOutOf')}</Text>
          </View>
          <Text style={[styles.summaryText, { color: theme.colors.text }]}>{report.summaryText}</Text>
          {reportQuery.isFetching ? <ActivityIndicator size="small" color={theme.colors.primary} /> : null}
        </Card>

        <Card dark={dark} style={styles.sectionCard}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>{t('weeklyReport.highlights')}</Text>
          {report.highlights.length === 0 ? (
            <Text style={[styles.emptyText, { color: theme.colors.textMuted }]}>{t('weeklyReport.noHighlights')}</Text>
          ) : (
            <View style={styles.listWrap}>
              {report.highlights.map((item, index) => (
                <View key={`${item}-${index}`} style={styles.listRow}>
                  <View style={[styles.listDot, { backgroundColor: theme.colors.income }]} />
                  <Text style={[styles.listText, { color: theme.colors.textMuted }]}>{item}</Text>
                </View>
              ))}
            </View>
          )}
        </Card>

        <Card dark={dark} style={styles.sectionCard}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>{t('weeklyReport.riskFlags')}</Text>
          {report.riskFlags.length === 0 ? (
            <Text style={[styles.emptyText, { color: theme.colors.textMuted }]}>{t('weeklyReport.noRisks')}</Text>
          ) : (
            <View style={styles.listWrap}>
              {report.riskFlags.map((item, index) => (
                <View key={`${item}-${index}`} style={styles.listRow}>
                  <View style={[styles.listDot, { backgroundColor: theme.colors.expense }]} />
                  <Text style={[styles.listText, { color: theme.colors.textMuted }]}>{item}</Text>
                </View>
              ))}
            </View>
          )}
        </Card>

        <Card dark={dark} style={styles.forecastCard}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>{t('weeklyReport.nextWeekForecast')}</Text>
          <Text style={[styles.forecastText, { color: theme.colors.textMuted }]}>{report.nextWeekForecastText}</Text>
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  header: {
    gap: spacing.xxs,
  },
  title: {
    ...typography.heading,
    fontSize: 26,
  },
  subtitle: {
    ...typography.body,
    fontSize: 14,
  },
  weekRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'center',
  },
  arrowButton: {
    alignItems: 'center',
    height: 30,
    justifyContent: 'center',
    width: 30,
  },
  arrowText: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  weekLabel: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '600',
    letterSpacing: 0.2,
    minWidth: 160,
    textAlign: 'center',
    textTransform: 'uppercase',
  },
  scoreCard: {
    alignItems: 'center',
    gap: spacing.sm,
  },
  scoreCircle: {
    alignItems: 'center',
    borderRadius: radius.full,
    borderWidth: 10,
    height: 132,
    justifyContent: 'center',
    width: 132,
  },
  scoreValue: {
    ...typography.heading,
    fontSize: 38,
    fontWeight: '800',
    lineHeight: 42,
  },
  scoreCaption: {
    ...typography.caption,
    fontSize: 11,
    letterSpacing: 0.4,
  },
  summaryText: {
    ...typography.body,
    textAlign: 'center',
  },
  sectionCard: {
    gap: spacing.xs,
  },
  sectionTitle: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  listWrap: {
    gap: spacing.xs,
  },
  listRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  listDot: {
    borderRadius: radius.full,
    height: 8,
    width: 8,
  },
  listText: {
    ...typography.body,
    flex: 1,
    fontSize: 14,
  },
  forecastCard: {
    gap: spacing.xs,
  },
  forecastText: {
    ...typography.body,
  },
  loadingWrap: {
    gap: spacing.sm,
  },
  loadingScore: {
    borderRadius: radius.lg,
    height: 220,
    width: '100%',
  },
  loadingBlock: {
    borderRadius: radius.md,
    height: 92,
    width: '100%',
  },
  errorCard: {
    gap: spacing.xs,
  },
  errorTitle: {
    ...typography.subheading,
    fontWeight: '700',
  },
  errorText: {
    ...typography.body,
  },
  emptyText: {
    ...typography.body,
  },
  pressed: {
    opacity: 0.85,
  },
});

===== FILE: apps/mobile/src/features/auth/components/AuthCard.tsx =====
import type { ReactNode } from 'react';
import { StyleSheet, View, type StyleProp, type ViewStyle } from 'react-native';

import { radius, spacing, useTheme } from '@shared/theme';

// no touch/keyboard behavior changed by this PR.
interface AuthCardProps {
  children: ReactNode;
  style?: StyleProp<ViewStyle>;
}

export function AuthCard({ children, style }: AuthCardProps) {
  const { theme } = useTheme();
  const isDark = theme.mode === 'dark';

  return (
    <View
      style={[
        styles.card,
        {
          backgroundColor: isDark ? theme.colors.cardBackground : theme.colors.surface,
          borderColor: theme.colors.cardBorder,
          shadowColor: theme.shadows.card.shadowColor,
          shadowOpacity: isDark ? 0.4 : theme.shadows.card.shadowOpacity,
          shadowRadius: isDark ? 20 : theme.shadows.card.shadowRadius,
          shadowOffset: isDark ? { width: 0, height: 12 } : theme.shadows.card.shadowOffset,
          elevation: isDark ? 12 : theme.shadows.card.elevation,
        },
        style,
      ]}
    >
      {children}
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    borderRadius: radius.xl,
    borderWidth: 1,
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.lg,
  },
});

===== FILE: apps/mobile/src/features/auth/components/AuthFooterLinks.tsx =====
import { Pressable, StyleSheet, Text, View } from 'react-native';

import { spacing, typography, useTheme } from '@shared/theme';

// no touch/keyboard behavior changed by this PR.
interface AuthFooterLinksProps {
  prefix: string;
  actionLabel: string;
  onActionPress: () => void;
}

export function AuthFooterLinks({
  prefix,
  actionLabel,
  onActionPress,
}: AuthFooterLinksProps) {
  const { theme } = useTheme();

  return (
    <View style={styles.row}>
      <Text style={[styles.prefix, { color: theme.colors.textMuted }]}>{prefix}</Text>
      <Pressable
        accessibilityRole="button"
        onPress={onActionPress}
        style={({ pressed }) => [pressed && styles.pressed]}
      >
        <Text style={[styles.action, { color: theme.colors.primary }]}>{actionLabel}</Text>
      </Pressable>
    </View>
  );
}

const styles = StyleSheet.create({
  row: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    justifyContent: 'center',
  },
  prefix: {
    ...typography.body,
  },
  action: {
    ...typography.body,
    fontWeight: '700',
  },
  pressed: {
    opacity: 0.8,
  },
});

===== FILE: apps/mobile/src/features/auth/components/AuthHeader.tsx =====
import { StyleSheet, Text, View, type StyleProp, type TextStyle } from 'react-native';

import { spacing, typography, useTheme } from '@shared/theme';

// no touch/keyboard behavior changed by this PR.
interface AuthHeaderProps {
  title: string;
  subtitle?: string;
  align?: 'left' | 'center';
  titleStyle?: StyleProp<TextStyle>;
}

export function AuthHeader({
  title,
  subtitle,
  align = 'left',
  titleStyle,
}: AuthHeaderProps) {
  const { theme } = useTheme();
  const centered = align === 'center';

  return (
    <View style={styles.wrap}>
      <Text
        style={[
          styles.title,
          { color: theme.colors.text },
          centered && styles.centeredText,
          titleStyle,
        ]}
      >
        {title}
      </Text>
      {subtitle ? (
        <Text
          style={[
            styles.subtitle,
            { color: theme.colors.textMuted },
            centered && styles.centeredText,
          ]}
        >
          {subtitle}
        </Text>
      ) : null}
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    gap: spacing.xs,
    marginBottom: spacing.md,
  },
  title: {
    ...typography.heading,
    fontSize: 38,
    lineHeight: 44,
    fontWeight: '800',
    letterSpacing: -0.6,
  },
  subtitle: {
    ...typography.body,
    fontSize: 17,
    lineHeight: 24,
  },
  centeredText: {
    textAlign: 'center',
  },
});

===== FILE: apps/mobile/src/features/auth/components/AuthLayout.tsx =====
import type { ReactNode } from 'react';
import { StyleSheet, View, type StyleProp, type ViewStyle } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

import { spacing, useTheme } from '@shared/theme';
import { ScreenContainer } from '@shared/ui';
import { AuthCard } from './AuthCard';
import { AuthHeader } from './AuthHeader';

// no touch/keyboard behavior changed by this PR.
interface AuthLayoutProps {
  title?: string;
  subtitle?: string;
  children: ReactNode;
  topContent?: ReactNode;
  footer?: ReactNode;
  useCard?: boolean;
  contentStyle?: StyleProp<ViewStyle>;
  cardStyle?: StyleProp<ViewStyle>;
  cardBodyStyle?: StyleProp<ViewStyle>;
  maxWidth?: number;
}

export function AuthLayout({
  title,
  subtitle,
  children,
  topContent,
  footer,
  useCard = true,
  contentStyle,
  cardStyle,
  cardBodyStyle,
  maxWidth = 460,
}: AuthLayoutProps) {
  const { theme } = useTheme();
  const insets = useSafeAreaInsets();
  const isDark = theme.mode === 'dark';

  return (
    <ScreenContainer
      keyboardDismissMode="on-drag"
      keyboardShouldPersistTaps="always"
      safeAreaEdges={['top', 'bottom']}
      showsVerticalScrollIndicator={false}
      contentStyle={[
        styles.scrollContent,
        {
          paddingTop: Math.max(insets.top, spacing.lg),
          paddingBottom: Math.max(insets.bottom, spacing.lg),
        },
      ]}
    >
      {isDark ? (
        <>
          <View
            pointerEvents="none"
            style={[styles.glowTop, { backgroundColor: theme.colors.authGlowTop }]}
          />
          <View
            pointerEvents="none"
            style={[styles.glowBottom, { backgroundColor: theme.colors.authGlowBottom }]}
          />
        </>
      ) : null}
      <View style={[styles.content, contentStyle]}>
        {topContent ? <View style={[styles.block, { maxWidth }]}>{topContent}</View> : null}

        {useCard ? (
          <AuthCard style={[styles.block, { maxWidth }, cardStyle]}>
            {title ? <AuthHeader subtitle={subtitle} title={title} /> : null}
            <View style={[styles.body, cardBodyStyle]}>{children}</View>
          </AuthCard>
        ) : (
          <View style={[styles.block, styles.plainBlock, { maxWidth }]}>{children}</View>
        )}

        {footer ? <View style={[styles.block, { maxWidth }]}>{footer}</View> : null}
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 0,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    gap: spacing.lg,
    zIndex: 1,
  },
  block: {
    alignSelf: 'center',
    width: '100%',
  },
  plainBlock: {
    flex: 1,
    gap: spacing.lg,
  },
  body: {
    gap: spacing.md,
  },
  glowTop: {
    borderRadius: 220,
    height: 320,
    position: 'absolute',
    right: -130,
    top: -160,
    width: 320,
    zIndex: 0,
  },
  glowBottom: {
    borderRadius: 260,
    bottom: -200,
    height: 360,
    left: -180,
    position: 'absolute',
    width: 360,
    zIndex: 0,
  },
});

===== FILE: apps/mobile/src/features/auth/index.ts =====
export { LoginScreen } from './screens/LoginScreen';
export { RegisterScreen } from './screens/RegisterScreen';
export { ForgotPasswordScreen } from './screens/ForgotPasswordScreen';
export { AuthLayout } from './components/AuthLayout';
export { AuthHeader } from './components/AuthHeader';
export { AuthCard } from './components/AuthCard';
export { AuthFooterLinks } from './components/AuthFooterLinks';

===== FILE: apps/mobile/src/features/auth/screens/ForgotPasswordScreen.tsx =====
import { useState } from 'react';
import {
  ActivityIndicator,
  Pressable,
  StyleSheet,
  Text,
  View,
} from 'react-native';

import type { NativeStackScreenProps } from '@react-navigation/native-stack';

import { AuthLayout } from '@features/auth/components/AuthLayout';
import { TextField } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { AuthStackParamList } from '@core/navigation/types';
import { radius, spacing, typography, useTheme } from '@shared/theme';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/sifremi_unuttum_(dark)_1/screen.png
// no touch/keyboard behavior changed by this PR.
type Props = NativeStackScreenProps<AuthStackParamList, 'ForgotPassword'>;

const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

function IconText({
  color,
  size,
  symbol,
}: {
  color: string;
  size: number;
  symbol: string;
}) {
  return <Text style={[styles.iconText, { color, fontSize: size }]}>{symbol}</Text>;
}

export function ForgotPasswordScreen({ navigation }: Props) {
  const { theme } = useTheme();
  const { t } = useI18n();
  const [email, setEmail] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [submitted, setSubmitted] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const submit = async () => {
    setSubmitted(false);
    setError(null);

    if (!email.trim()) {
      setError(t('auth.validation.emailRequired'));
      return;
    }

    if (!EMAIL_REGEX.test(email.trim())) {
      setError(t('auth.validation.emailInvalid'));
      return;
    }

    setIsSubmitting(true);
    await Promise.resolve();
    setIsSubmitting(false);
    setSubmitted(true);
  };

  return (
    <AuthLayout
      contentStyle={styles.content}
      topContent={
        <Pressable
          accessibilityRole="button"
          onPress={() => navigation.goBack()}
          style={styles.backButton}
        >
          <IconText color={theme.colors.text} size={18} symbol="<" />
        </Pressable>
      }
      useCard={false}
    >
      <View style={styles.headerBlock}>
        <Text style={[styles.title, { color: theme.colors.text }]}>{t('auth.forgot.title')}</Text>
        <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}>
          {t('auth.forgot.subtitle')}
        </Text>
      </View>

      <TextField
        autoCapitalize="none"
        autoComplete="email"
        error={error}
        keyboardType="email-address"
        label={t('auth.forgot.fields.emailLabel')}
        leftAdornment={<IconText color={theme.colors.inputIcon} size={15} symbol="@" />}
        onChangeText={(value) => {
          setEmail(value);
          setError(null);
          setSubmitted(false);
        }}
        onSubmitEditing={() => {
          void submit();
        }}
        placeholder={t('auth.forgot.fields.emailPlaceholder')}
        returnKeyType="done"
        textContentType="emailAddress"
        value={email}
      />

      <View style={styles.bottomSection}>
        <Pressable
          accessibilityRole="button"
          disabled={isSubmitting}
          onPress={() => {
            void submit();
          }}
          style={({ pressed }) => [
            styles.submitButton,
            { backgroundColor: theme.colors.buttonPrimaryBackground },
            (pressed || isSubmitting) && styles.submitButtonPressed,
          ]}
        >
          {isSubmitting ? (
            <ActivityIndicator color={theme.colors.buttonPrimaryText} size="small" />
          ) : (
            <View style={styles.submitContent}>
              <Text style={[styles.submitLabel, { color: theme.colors.buttonPrimaryText }]}>
                {t('auth.forgot.submit')}
              </Text>
              <IconText color={theme.colors.buttonPrimaryText} size={14} symbol=">" />
            </View>
          )}
        </Pressable>

        {submitted ? (
          <Text style={[styles.notice, { color: theme.colors.income }]}>
            {t('auth.forgot.success')}
          </Text>
        ) : null}

        <View style={styles.securityWrap}>
          <View style={styles.securityLabelRow}>
            <IconText color={theme.colors.textMuted} size={10} symbol="#" />
            <Text style={[styles.securityLabel, { color: theme.colors.textMuted }]}>
              {t('auth.forgot.secureBadge')}
            </Text>
          </View>
          <View style={[styles.securityBar, { backgroundColor: theme.colors.border }]} />
        </View>
      </View>
    </AuthLayout>
  );
}

const styles = StyleSheet.create({
  iconText: {
    fontWeight: '700',
    lineHeight: 18,
    textAlign: 'center',
  },
  content: {
    justifyContent: 'flex-start',
  },
  backButton: {
    alignItems: 'center',
    height: 36,
    justifyContent: 'center',
    width: 36,
  },
  headerBlock: {
    gap: spacing.sm,
    marginBottom: spacing.md,
  },
  title: {
    ...typography.title,
    fontSize: 50,
    fontWeight: '800',
    letterSpacing: -1,
    lineHeight: 56,
  },
  subtitle: {
    ...typography.body,
    fontSize: 17,
    lineHeight: 27,
    maxWidth: 340,
  },
  bottomSection: {
    flex: 1,
    justifyContent: 'flex-end',
    marginTop: spacing.lg,
  },
  submitButton: {
    alignItems: 'center',
    borderRadius: radius.md,
    height: 52,
    justifyContent: 'center',
  },
  submitButtonPressed: {
    opacity: 0.85,
  },
  submitContent: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    justifyContent: 'center',
  },
  submitLabel: {
    ...typography.subheading,
    fontWeight: '700',
  },
  notice: {
    ...typography.caption,
    marginTop: spacing.sm,
    textAlign: 'center',
  },
  securityWrap: {
    alignItems: 'center',
    gap: spacing.md,
    marginTop: spacing.xxl,
    paddingBottom: spacing.sm,
  },
  securityLabelRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  securityLabel: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 1,
  },
  securityBar: {
    borderRadius: radius.full,
    height: 4,
    width: 44,
  },
});

===== FILE: apps/mobile/src/features/auth/screens/LoginScreen.tsx =====
import { useMemo, useRef, useState } from 'react';
import { ActivityIndicator, Pressable, StyleSheet, Text, TextInput, View } from 'react-native';

import type { NativeStackScreenProps } from '@react-navigation/native-stack';

import { useAuth } from '@app/providers/AuthProvider';
import { AuthFooterLinks } from '@features/auth/components/AuthFooterLinks';
import { AuthLayout } from '@features/auth/components/AuthLayout';
import { AppIcon, TextField } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { AuthStackParamList } from '@core/navigation/types';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/giris_yap_(renk_guncellemesi)/screen.png
// no touch/keyboard behavior changed by this PR.
type Props = NativeStackScreenProps<AuthStackParamList, 'Login'>;

interface LoginErrors {
  email?: string;
  password?: string;
}

const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

function validateLogin(email: string, password: string, t: (key: string) => string): LoginErrors {
  const next: LoginErrors = {};

  if (!email.trim()) {
    next.email = t('auth.validation.emailRequired');
  } else if (!EMAIL_REGEX.test(email.trim())) {
    next.email = t('auth.validation.emailInvalid');
  }

  if (!password) {
    next.password = t('auth.validation.passwordRequired');
  }

  return next;
}

export function LoginScreen({ navigation }: Props) {
  const { theme } = useTheme();
  const { t } = useI18n();
  const { login, authError, clearAuthError } = useAuth();
  const passwordRef = useRef<TextInput | null>(null);

  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [errors, setErrors] = useState<LoginErrors>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [requestError, setRequestError] = useState<string | null>(null);

  const submit = async () => {
    if (isSubmitting) {
      return;
    }

    clearAuthError();
    setRequestError(null);

    const nextErrors = validateLogin(email, password, t);
    setErrors(nextErrors);
    if (nextErrors.email || nextErrors.password) {
      return;
    }

    setIsSubmitting(true);
    try {
      const ok = await login({
        email: email.trim(),
        password,
      });

      if (!ok && !authError) {
        setRequestError(t('auth.login.fallbackError'));
      }
    } catch (error) {
      setRequestError(apiErrorText(error));
    } finally {
      setIsSubmitting(false);
    }
  };

  const globalError = useMemo(() => requestError ?? authError ?? null, [authError, requestError]);

  return (
    <AuthLayout
      title={t('auth.login.welcomeBack')}
      subtitle={t('auth.login.subtitle')}
      cardStyle={styles.card}
      cardBodyStyle={styles.formBody}
      topContent={
        <View style={styles.topContent}>
          <View style={[styles.logoWrap, { borderColor: theme.colors.border }]}> 
            <View style={[styles.logoInner, { backgroundColor: theme.colors.primaryMuted }]}> 
              <AppIcon name="shield-checkmark-outline" size="sm" tone="primary" />
            </View>
          </View>
          <Text style={[styles.brandTitle, { color: theme.colors.text }]}>{t('auth.brandTitle')}</Text>
          <AuthFooterLinks
            actionLabel={t('auth.links.joinNow')}
            onActionPress={() => navigation.navigate('Register')}
            prefix={t('auth.links.noAccount')}
          />
        </View>
      }
      footer={
        <View style={styles.footer}>
          <AuthFooterLinks
            actionLabel={t('auth.links.joinNow')}
            onActionPress={() => navigation.navigate('Register')}
            prefix={t('auth.links.noAccount')}
          />
          <View
            style={[
              styles.secureBadge,
              {
                backgroundColor: theme.mode === 'dark' ? 'rgba(255,255,255,0.04)' : theme.colors.surface,
                borderColor: theme.colors.border,
              },
            ]}
          >
            <AppIcon name="lock-closed-outline" size="xs" tone="income" />
            <Text style={[styles.secureBadgeText, { color: theme.colors.textMuted }]}>
              {t('auth.login.secureBadge')}
            </Text>
          </View>
        </View>
      }
    >
      <TextField
        autoCapitalize="none"
        autoComplete="email"
        blurOnSubmit={false}
        error={errors.email}
        keyboardType="email-address"
        label={t('auth.login.fields.emailLabel')}
        leftAdornment={<AppIcon name="mail-outline" size="sm" tone="muted" />}
        onChangeText={(value) => {
          setEmail(value);
          setErrors((prev) => ({ ...prev, email: undefined }));
          setRequestError(null);
          clearAuthError();
        }}
        onSubmitEditing={() => passwordRef.current?.focus()}
        placeholder={t('auth.login.fields.emailPlaceholder')}
        returnKeyType="next"
        textContentType="emailAddress"
        value={email}
      />

      <TextField
        ref={passwordRef}
        autoCapitalize="none"
        autoComplete="password"
        error={errors.password}
        label={t('auth.login.fields.passwordLabel')}
        labelRight={
          <Pressable onPress={() => navigation.navigate('ForgotPassword')}>
            <Text style={[styles.forgotLink, { color: theme.colors.primary }]}>{t('auth.login.forgot')}</Text>
          </Pressable>
        }
        leftAdornment={<AppIcon name="lock-closed-outline" size="sm" tone="muted" />}
        onChangeText={(value) => {
          setPassword(value);
          setErrors((prev) => ({ ...prev, password: undefined }));
          setRequestError(null);
          clearAuthError();
        }}
        onSubmitEditing={() => {
          void submit();
        }}
        placeholder={t('auth.login.fields.passwordPlaceholder')}
        rightAdornment={
          <Pressable
            accessibilityLabel={showPassword ? t('auth.login.hidePassword') : t('auth.login.showPassword')}
            onPress={() => setShowPassword((value) => !value)}
          >
            <AppIcon name={showPassword ? 'eye-off-outline' : 'eye-outline'} size="sm" tone="muted" />
          </Pressable>
        }
        returnKeyType="go"
        secureTextEntry={!showPassword}
        textContentType="password"
        value={password}
      />

      {globalError ? <Text style={[styles.errorText, { color: theme.colors.expense }]}>{globalError}</Text> : null}

      <Pressable
        accessibilityRole="button"
        disabled={isSubmitting}
        onPress={() => {
          void submit();
        }}
        style={({ pressed }) => [
          styles.submitButton,
          { backgroundColor: theme.colors.buttonPrimaryBackground },
          (pressed || isSubmitting) && styles.submitButtonPressed,
        ]}
      >
        {isSubmitting ? (
          <ActivityIndicator color={theme.colors.buttonPrimaryText} size="small" />
        ) : (
          <View style={styles.submitContent}>
            <Text style={[styles.submitLabel, { color: theme.colors.buttonPrimaryText }]}>{t('auth.login.submit')}</Text>
            <AppIcon name="arrow-forward" size="sm" tone="inverse" />
          </View>
        )}
      </Pressable>

      <View style={styles.divider}>
        <View style={[styles.dividerLine, { backgroundColor: theme.colors.border }]} />
        <Text style={[styles.dividerLabel, { color: theme.colors.textMuted }]}>{t('auth.common.orContinueWith')}</Text>
        <View style={[styles.dividerLine, { backgroundColor: theme.colors.border }]} />
      </View>

      <View style={styles.socialRow}>
        <Pressable
          accessibilityRole="button"
          onPress={() => undefined}
          style={({ pressed }) => [
            styles.socialButton,
            {
              backgroundColor: theme.mode === 'dark' ? 'rgba(255,255,255,0.04)' : theme.colors.surface,
              borderColor: theme.colors.border,
            },
            pressed && styles.socialButtonPressed,
          ]}
        >
          <Text style={[styles.socialLabel, { color: theme.colors.text }]}>{t('auth.common.google')}</Text>
        </Pressable>
        <Pressable
          accessibilityRole="button"
          onPress={() => undefined}
          style={({ pressed }) => [
            styles.socialButton,
            {
              backgroundColor: theme.mode === 'dark' ? 'rgba(255,255,255,0.04)' : theme.colors.surface,
              borderColor: theme.colors.border,
            },
            pressed && styles.socialButtonPressed,
          ]}
        >
          <Text style={[styles.socialLabel, { color: theme.colors.text }]}>{t('auth.common.apple')}</Text>
        </Pressable>
      </View>
    </AuthLayout>
  );
}

const styles = StyleSheet.create({
  topContent: {
    alignItems: 'center',
    gap: spacing.sm,
  },
  logoWrap: {
    borderRadius: radius.lg,
    borderWidth: 1,
    padding: spacing.xxs,
  },
  logoInner: {
    alignItems: 'center',
    borderRadius: radius.md,
    height: 50,
    justifyContent: 'center',
    width: 50,
  },
  brandTitle: {
    ...typography.title,
    fontSize: 50,
    fontWeight: '800',
    letterSpacing: -1,
    lineHeight: 56,
    textAlign: 'center',
  },
  card: {
    borderRadius: 30,
    paddingTop: spacing.xl,
  },
  formBody: {
    gap: spacing.md,
  },
  forgotLink: {
    ...typography.caption,
    fontWeight: '700',
  },
  errorText: {
    ...typography.caption,
  },
  submitButton: {
    alignItems: 'center',
    borderRadius: radius.md,
    height: 50,
    justifyContent: 'center',
    marginTop: spacing.xs,
  },
  submitContent: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    justifyContent: 'center',
  },
  submitButtonPressed: {
    opacity: 0.85,
  },
  submitLabel: {
    ...typography.subheading,
    fontWeight: '700',
  },
  divider: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.sm,
    marginTop: spacing.sm,
  },
  dividerLine: {
    flex: 1,
    height: 1,
  },
  dividerLabel: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 1,
  },
  socialRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  socialButton: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flex: 1,
    height: 50,
    justifyContent: 'center',
  },
  socialButtonPressed: {
    opacity: 0.82,
  },
  socialLabel: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '600',
  },
  footer: {
    alignItems: 'center',
    gap: spacing.md,
  },
  secureBadge: {
    alignItems: 'center',
    borderRadius: radius.full,
    borderWidth: 1,
    flexDirection: 'row',
    gap: spacing.xs,
    minHeight: 42,
    paddingHorizontal: spacing.md,
  },
  secureBadgeText: {
    ...typography.caption,
    fontSize: 10,
    fontWeight: '700',
    letterSpacing: 1,
  },
});

===== FILE: apps/mobile/src/features/auth/screens/RegisterScreen.tsx =====
import { useMemo, useRef, useState } from 'react';
import {
  ActivityIndicator,
  Pressable,
  StyleSheet,
  Text,
  TextInput,
  View,
} from 'react-native';

import type { NativeStackScreenProps } from '@react-navigation/native-stack';

import { AuthFooterLinks } from '@features/auth/components/AuthFooterLinks';
import { AuthLayout } from '@features/auth/components/AuthLayout';
import { TextField } from '@shared/ui';
import { useAuth } from '@app/providers/AuthProvider';
import { useI18n } from '@shared/i18n';
import type { AuthStackParamList } from '@core/navigation/types';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/kayit_ol_(dark_mode)_2/screen.png
// no touch/keyboard behavior changed by this PR.
type Props = NativeStackScreenProps<AuthStackParamList, 'Register'>;

interface RegisterErrors {
  name?: string;
  email?: string;
  password?: string;
}

const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

function validateRegister(
  name: string,
  email: string,
  password: string,
  t: (key: string) => string,
): RegisterErrors {
  const next: RegisterErrors = {};

  if (!name.trim()) {
    next.name = t('auth.validation.nameRequired');
  }

  if (!email.trim()) {
    next.email = t('auth.validation.emailRequired');
  } else if (!EMAIL_REGEX.test(email.trim())) {
    next.email = t('auth.validation.emailInvalid');
  }

  if (!password) {
    next.password = t('auth.validation.passwordRequired');
  } else if (password.length < 8) {
    next.password = t('auth.validation.passwordMin');
  }

  return next;
}

function IconText({
  color,
  size,
  symbol,
}: {
  color: string;
  size: number;
  symbol: string;
}) {
  return <Text style={[styles.iconText, { color, fontSize: size }]}>{symbol}</Text>;
}

export function RegisterScreen({ navigation }: Props) {
  const { theme } = useTheme();
  const { t } = useI18n();
  const { register, authError, clearAuthError } = useAuth();

  const emailRef = useRef<TextInput | null>(null);
  const passwordRef = useRef<TextInput | null>(null);

  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [errors, setErrors] = useState<RegisterErrors>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [requestError, setRequestError] = useState<string | null>(null);

  const submit = async () => {
    if (isSubmitting) {
      return;
    }

    clearAuthError();
    setRequestError(null);

    const nextErrors = validateRegister(name, email, password, t);
    setErrors(nextErrors);
    if (nextErrors.name || nextErrors.email || nextErrors.password) {
      return;
    }

    setIsSubmitting(true);
    try {
      const ok = await register({
        name: name.trim(),
        email: email.trim(),
        password,
      });

      if (!ok && !authError) {
        setRequestError(t('auth.register.fallbackError'));
      }
    } catch (error) {
      setRequestError(apiErrorText(error));
    } finally {
      setIsSubmitting(false);
    }
  };

  const globalError = useMemo(() => requestError ?? authError ?? null, [authError, requestError]);

  return (
    <AuthLayout
      contentStyle={styles.content}
      footer={
        <AuthFooterLinks
          actionLabel={t('auth.links.signIn')}
          onActionPress={() => navigation.navigate('Login')}
          prefix={t('auth.links.haveAccount')}
        />
      }
      topContent={
        <Pressable
          accessibilityRole="button"
          onPress={() => navigation.goBack()}
          style={styles.backButton}
        >
          <IconText color={theme.colors.text} size={18} symbol="<" />
        </Pressable>
      }
      useCard={false}
    >
        <View style={styles.headerBlock}>
        <View
          style={[
            styles.headerIconWrap,
            {
              backgroundColor: theme.mode === 'dark' ? 'rgba(255,255,255,0.05)' : theme.colors.surface,
              borderColor: theme.colors.border,
            },
          ]}
        >
          <IconText color={theme.colors.primary} size={18} symbol="◈" />
        </View>
        <Text style={[styles.title, { color: theme.colors.text }]}>{t('auth.register.title')}</Text>
        <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}>{t('auth.register.subtitle')}</Text>
      </View>

      <TextField
        autoCapitalize="words"
        autoComplete="name"
        blurOnSubmit={false}
        error={errors.name}
        label={t('auth.register.fields.nameLabel')}
        leftAdornment={<IconText color={theme.colors.inputIcon} size={15} symbol="◎" />}
        onChangeText={(value) => {
          setName(value);
          setErrors((prev) => ({ ...prev, name: undefined }));
          setRequestError(null);
          clearAuthError();
        }}
        onSubmitEditing={() => emailRef.current?.focus()}
        placeholder={t('auth.register.fields.namePlaceholder')}
        returnKeyType="next"
        textContentType="name"
        value={name}
      />

      <TextField
        ref={emailRef}
        autoCapitalize="none"
        autoComplete="email"
        blurOnSubmit={false}
        error={errors.email}
        keyboardType="email-address"
        label={t('auth.register.fields.emailLabel')}
        leftAdornment={<IconText color={theme.colors.inputIcon} size={15} symbol="@" />}
        onChangeText={(value) => {
          setEmail(value);
          setErrors((prev) => ({ ...prev, email: undefined }));
          setRequestError(null);
          clearAuthError();
        }}
        onSubmitEditing={() => passwordRef.current?.focus()}
        placeholder={t('auth.register.fields.emailPlaceholder')}
        returnKeyType="next"
        textContentType="emailAddress"
        value={email}
      />

      <TextField
        ref={passwordRef}
        autoCapitalize="none"
        autoComplete="password"
        error={errors.password}
        label={t('auth.register.fields.passwordLabel')}
        leftAdornment={<IconText color={theme.colors.inputIcon} size={16} symbol="#" />}
        onChangeText={(value) => {
          setPassword(value);
          setErrors((prev) => ({ ...prev, password: undefined }));
          setRequestError(null);
          clearAuthError();
        }}
        onSubmitEditing={() => {
          void submit();
        }}
        placeholder="••••••••"
        returnKeyType="go"
        rightAdornment={
          <Pressable
            accessibilityLabel={showPassword ? t('auth.login.hidePassword') : t('auth.login.showPassword')}
            onPress={() => setShowPassword((value) => !value)}
          >
            <IconText color={theme.colors.inputIcon} size={16} symbol={showPassword ? '○' : '◉'} />
          </Pressable>
        }
        secureTextEntry={!showPassword}
        textContentType="newPassword"
        value={password}
      />

      {globalError ? <Text style={[styles.errorText, { color: theme.colors.expense }]}>{globalError}</Text> : null}

      <Pressable
        accessibilityRole="button"
        disabled={isSubmitting}
        onPress={() => {
          void submit();
        }}
        style={({ pressed }) => [
          styles.submitButton,
          { backgroundColor: theme.colors.buttonPrimaryBackground },
          (pressed || isSubmitting) && styles.submitButtonPressed,
        ]}
      >
        {isSubmitting ? (
          <ActivityIndicator color={theme.colors.buttonPrimaryText} size="small" />
        ) : (
          <Text style={[styles.submitLabel, { color: theme.colors.buttonPrimaryText }]}>
            {t('auth.register.submit')}
          </Text>
        )}
      </Pressable>

      <View style={styles.divider}>
        <View style={[styles.dividerLine, { backgroundColor: theme.colors.border }]} />
        <Text style={[styles.dividerLabel, { color: theme.colors.textMuted }]}>{t('auth.common.or')}</Text>
        <View style={[styles.dividerLine, { backgroundColor: theme.colors.border }]} />
      </View>

      <View style={styles.socialRow}>
        <Pressable
          accessibilityRole="button"
          onPress={() => undefined}
          style={({ pressed }) => [
            styles.socialButton,
            {
              backgroundColor: theme.mode === 'dark' ? 'rgba(255,255,255,0.04)' : theme.colors.surface,
              borderColor: theme.colors.border,
            },
            pressed && styles.socialButtonPressed,
          ]}
        >
          <Text style={[styles.socialLabel, { color: theme.colors.text }]}>{t('auth.common.google')}</Text>
        </Pressable>
        <Pressable
          accessibilityRole="button"
          onPress={() => undefined}
          style={({ pressed }) => [
            styles.socialButton,
            {
              backgroundColor: theme.mode === 'dark' ? 'rgba(255,255,255,0.04)' : theme.colors.surface,
              borderColor: theme.colors.border,
            },
            pressed && styles.socialButtonPressed,
          ]}
        >
          <Text style={[styles.socialLabel, { color: theme.colors.text }]}>{t('auth.common.apple')}</Text>
        </Pressable>
      </View>
    </AuthLayout>
  );
}

const styles = StyleSheet.create({
  iconText: {
    fontWeight: '700',
    lineHeight: 18,
    textAlign: 'center',
  },
  content: {
    justifyContent: 'flex-start',
  },
  backButton: {
    alignItems: 'center',
    height: 36,
    justifyContent: 'center',
    width: 36,
  },
  headerBlock: {
    alignItems: 'center',
    gap: spacing.sm,
    marginBottom: spacing.md,
  },
  headerIconWrap: {
    alignItems: 'center',
    borderRadius: radius.lg,
    borderWidth: 1,
    height: 56,
    justifyContent: 'center',
    marginBottom: spacing.xs,
    width: 56,
  },
  title: {
    ...typography.title,
    fontSize: 46,
    fontWeight: '800',
    letterSpacing: -0.8,
    lineHeight: 52,
    textAlign: 'center',
  },
  subtitle: {
    ...typography.body,
    fontSize: 18,
    lineHeight: 25,
    maxWidth: 320,
    textAlign: 'center',
  },
  errorText: {
    ...typography.caption,
  },
  submitButton: {
    alignItems: 'center',
    borderRadius: radius.md,
    height: 52,
    justifyContent: 'center',
    marginTop: spacing.xs,
  },
  submitButtonPressed: {
    opacity: 0.85,
  },
  submitLabel: {
    ...typography.subheading,
    fontWeight: '700',
  },
  divider: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.sm,
    marginTop: spacing.sm,
  },
  dividerLine: {
    flex: 1,
    height: 1,
  },
  dividerLabel: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 1,
  },
  socialRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  socialButton: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flex: 1,
    height: 50,
    justifyContent: 'center',
  },
  socialButtonPressed: {
    opacity: 0.82,
  },
  socialLabel: {
    ...typography.subheading,
    fontWeight: '600',
  },
});

===== FILE: apps/mobile/src/features/debug/screens/DebugInputScreen.tsx =====
import { useEffect, useState } from 'react';
import {
  Keyboard,
  Pressable,
  StyleSheet,
  Text,
  TextInput,
  View,
} from 'react-native';

import type { NativeStackScreenProps } from '@react-navigation/native-stack';

import { ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { AuthStackParamList } from '@core/navigation/types';
import { radius, spacing, typography, useTheme } from '@shared/theme';

type Props = NativeStackScreenProps<AuthStackParamList, 'DebugInput'>;

export function DebugInputScreen({ navigation }: Props) {
  const { theme, mode } = useTheme();
  const { t } = useI18n();
  const [first, setFirst] = useState('');
  const [second, setSecond] = useState('');

  useEffect(() => {
    const subscriptions = [
      Keyboard.addListener('keyboardWillShow', () => console.log('[debug] keyboardWillShow')),
      Keyboard.addListener('keyboardDidShow', () => console.log('[debug] keyboardDidShow')),
      Keyboard.addListener('keyboardWillHide', () => console.log('[debug] keyboardWillHide')),
      Keyboard.addListener('keyboardDidHide', () => console.log('[debug] keyboardDidHide')),
    ];

    return () => {
      for (const subscription of subscriptions) {
        subscription.remove();
      }
    };
  }, []);

  const dark = mode === 'dark';

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.content}>
        <Text style={[styles.title, { color: theme.colors.text }]}>{t('debug.input.title')}</Text>
        <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}>{t('debug.input.subtitle')}</Text>

        <TextInput
          autoCapitalize="none"
          autoCorrect={false}
          onBlur={() => console.log('[debug] blur first')}
          onChangeText={setFirst}
          onFocus={() => console.log('[debug] focus first')}
          onTouchStart={() => console.log('[debug] touchstart first')}
          placeholder={t('debug.input.firstPlaceholder')}
          placeholderTextColor={theme.colors.textMuted}
          style={[
            styles.input,
            {
              backgroundColor: theme.colors.inputBackground,
              borderColor: theme.colors.inputBorder,
              color: theme.colors.inputText,
            },
          ]}
          value={first}
        />

        <TextInput
          autoCapitalize="none"
          autoCorrect={false}
          onBlur={() => console.log('[debug] blur second')}
          onChangeText={setSecond}
          onFocus={() => console.log('[debug] focus second')}
          onTouchStart={() => console.log('[debug] touchstart second')}
          placeholder={t('debug.input.secondPlaceholder')}
          placeholderTextColor={theme.colors.textMuted}
          style={[
            styles.input,
            {
              backgroundColor: theme.colors.inputBackground,
              borderColor: theme.colors.inputBorder,
              color: theme.colors.inputText,
            },
          ]}
          value={second}
        />

        <Pressable onPress={() => navigation.replace('Login')} style={[styles.button, { backgroundColor: theme.colors.primary }]}>
          <Text style={[styles.buttonText, { color: theme.colors.buttonPrimaryText }]}>{t('debug.input.goLogin')}</Text>
        </Pressable>

        <Pressable
          onPress={() => navigation.replace('Register')}
          style={[
            styles.button,
            {
              backgroundColor: dark ? theme.colors.surface : theme.colors.primaryMuted,
              borderColor: theme.colors.border,
            },
          ]}
        >
          <Text style={[styles.buttonText, { color: theme.colors.text }]}>{t('debug.input.goRegister')}</Text>
        </Pressable>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  content: {
    flex: 1,
    gap: spacing.sm,
    paddingTop: spacing.md,
  },
  title: {
    ...typography.heading,
  },
  subtitle: {
    ...typography.body,
  },
  input: {
    ...typography.body,
    borderRadius: radius.md,
    borderWidth: 1,
    height: 48,
    paddingHorizontal: spacing.sm,
  },
  button: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    height: 44,
    justifyContent: 'center',
    marginTop: spacing.xxs,
  },
  buttonText: {
    ...typography.subheading,
    fontSize: 15,
  },
});

===== FILE: apps/mobile/src/features/finance/index.ts =====
export { DashboardScreen } from './screens/DashboardScreen';
export { AccountsScreen } from './screens/AccountsScreen';
export { TransactionsScreen } from './screens/TransactionsScreen';
export { AddTransactionScreen } from './screens/AddTransactionScreen';
export { BudgetsScreen } from './screens/BudgetsScreen';
export { AnalyticsScreen } from './screens/AnalyticsScreen';
export { RecurringScreen } from './screens/RecurringScreen';
export { TransferScreen } from './screens/TransferScreen';
export { TransactionDetailScreen } from './screens/TransactionDetailScreen';

===== FILE: apps/mobile/src/features/finance/screens/AccountsScreen.tsx =====
import { useCallback, useEffect, useMemo, useState } from 'react';
import { ActivityIndicator, Alert, Pressable, StyleSheet, Text, TextInput, View } from 'react-native';

import { zodResolver } from '@hookform/resolvers/zod';
import {
  accountTypeSchema,
  accountCreateInputSchema,
  type AccountType,
  type AccountUpdateInput,
} from '@mintly/shared';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { Controller, useForm } from 'react-hook-form';
import { z } from 'zod';

import { useAuth } from '@app/providers/AuthProvider';
import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { Card, Chip, PrimaryButton, ScreenContainer, Section } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import { colors, radius, spacing, typography } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

const accountTypes: AccountType[] = ['cash', 'bank', 'credit'];

const createAccountFormSchema = z.object({
  name: accountCreateInputSchema.shape.name,
  type: accountCreateInputSchema.shape.type,
  currency: accountCreateInputSchema.shape.currency,
});

const editAccountFormSchema = z.object({
  name: z.string().trim().min(1, 'errors.validation.nameRequired').max(120),
  type: accountTypeSchema,
});

type CreateAccountFormValues = z.infer<typeof createAccountFormSchema>;
type EditAccountFormValues = z.infer<typeof editAccountFormSchema>;

export function AccountsScreen() {
  const { withAuth, user, refreshUser, logout } = useAuth();
  const { t } = useI18n();
  const queryClient = useQueryClient();
  const [editingAccountId, setEditingAccountId] = useState<string | null>(null);

  const baseCurrency = user?.baseCurrency ?? null;

  const accountsQuery = useQuery({
    queryKey: financeQueryKeys.accounts.list(),
    queryFn: () => withAuth((token) => apiClient.getAccounts(token)),
  });

  const createForm = useForm<CreateAccountFormValues>({
    resolver: zodResolver(createAccountFormSchema),
    defaultValues: {
      name: '',
      type: 'bank',
      currency: baseCurrency ?? 'USD',
    },
  });

  const editForm = useForm<EditAccountFormValues>({
    resolver: zodResolver(editAccountFormSchema),
    defaultValues: {
      name: '',
      type: 'bank',
    },
  });

  useEffect(() => {
    if (baseCurrency) {
      createForm.setValue('currency', baseCurrency, { shouldValidate: true });
    }
  }, [baseCurrency, createForm]);

  const createAccountMutation = useMutation({
    mutationFn: (values: CreateAccountFormValues) =>
      withAuth((token) =>
        apiClient.createAccount(
          {
            name: values.name.trim(),
            type: values.type,
            currency: (baseCurrency ?? values.currency).toUpperCase(),
          },
          token,
        ),
      ),
    onSuccess: async () => {
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.accounts.all() }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.dashboard.recent() }),
      ]);

      if (!baseCurrency) {
        await refreshUser();
      }

      createForm.reset({
        name: '',
        type: 'bank',
        currency: baseCurrency ?? createForm.getValues('currency'),
      });
    },
    onError: (error) => {
      Alert.alert(t('errors.account.createFailedTitle'), apiErrorText(error));
    },
  });

  const updateAccountMutation = useMutation({
    mutationFn: (params: { id: string; values: EditAccountFormValues }) =>
      withAuth((token) =>
        apiClient.updateAccount(
          params.id,
          {
            name: params.values.name.trim(),
            type: params.values.type,
          } satisfies AccountUpdateInput,
          token,
        ),
      ),
    onSuccess: async () => {
      setEditingAccountId(null);
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.accounts.all() }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.dashboard.recent() }),
      ]);
    },
    onError: (error) => {
      Alert.alert(t('errors.account.updateFailedTitle'), apiErrorText(error));
    },
  });

  const editingAccount = useMemo(
    () => accountsQuery.data?.accounts.find((account) => account.id === editingAccountId) ?? null,
    [accountsQuery.data?.accounts, editingAccountId],
  );

  const handleLogout = useCallback(async () => {
    try {
      await logout();
    } catch (error) {
      Alert.alert(t('errors.auth.logoutFailedTitle'), apiErrorText(error));
    }
  }, [logout, t]);

  if (accountsQuery.isLoading) {
    return (
      <ScreenContainer>
        <View style={styles.centerState}>
          <ActivityIndicator size="large" color={colors.primary} />
          <Text style={styles.stateText}>{t('accounts.state.loading')}</Text>
        </View>
      </ScreenContainer>
    );
  }

  if (accountsQuery.isError) {
    return (
      <ScreenContainer>
        <Card style={styles.errorCard}>
          <Text style={styles.errorTitle}>{t('accounts.state.loadErrorTitle')}</Text>
          <Text style={styles.errorText}>{apiErrorText(accountsQuery.error)}</Text>
          <PrimaryButton label={t('common.retry')} onPress={() => void accountsQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  const accounts = accountsQuery.data?.accounts ?? [];

  return (
    <ScreenContainer>
      <Section title={t('accounts.sections.baseCurrency.title')} subtitle={t('accounts.sections.baseCurrency.subtitle')}>
        <Card>
          <Text style={styles.baseCurrencyText}>
            {baseCurrency
              ? t('accounts.baseCurrency.value', { currency: baseCurrency })
              : t('accounts.baseCurrency.empty')}
          </Text>
        </Card>
      </Section>

      <Section title={t('accounts.sections.session.title')} subtitle={user?.email ?? t('accounts.session.signedIn')}>
        <Card style={styles.sessionCard}>
          <PrimaryButton
            label={t('profile.logOut')}
            onPress={() => {
              void handleLogout();
            }}
          />
          <Pressable
            style={styles.secondaryAction}
            onPress={() => {
              void handleLogout();
            }}
          >
            <Text style={styles.secondaryActionText}>{t('profile.useDifferentAccount')}</Text>
          </Pressable>
        </Card>
      </Section>

      <Section title={t('accounts.sections.create.title')}>
        <Card style={styles.formCard}>
          <Text style={styles.fieldLabel}>{t('accounts.form.nameLabel')}</Text>
          <Controller
            control={createForm.control}
            name="name"
            render={({ field: { onChange, onBlur, value } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                placeholder={t('accounts.form.namePlaceholder')}
                placeholderTextColor={colors.textMuted}
              />
            )}
          />
          {createForm.formState.errors.name ? (
            <Text style={styles.errorText}>{t(createForm.formState.errors.name.message ?? '')}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>{t('accounts.form.typeLabel')}</Text>
          <Controller
            control={createForm.control}
            name="type"
            render={({ field: { onChange, value } }) => (
              <TypePicker selected={value} onSelect={onChange} />
            )}
          />

          <Text style={styles.fieldLabel}>{t('accounts.form.currencyLabel')}</Text>
          {baseCurrency ? (
            <Chip label={baseCurrency} tone="primary" />
          ) : (
            <Controller
              control={createForm.control}
              name="currency"
              render={({ field: { onChange, onBlur, value } }) => (
                <TextInput
                  style={styles.input}
                  value={value}
                  onChangeText={(next) => onChange(next.toUpperCase())}
                  onBlur={onBlur}
                  placeholder={t('accounts.form.currencyPlaceholder')}
                  autoCapitalize="characters"
                  maxLength={3}
                  placeholderTextColor={colors.textMuted}
                />
              )}
            />
          )}
          {createForm.formState.errors.currency ? (
            <Text style={styles.errorText}>{t(createForm.formState.errors.currency.message ?? '')}</Text>
          ) : null}

          <PrimaryButton
            label={createAccountMutation.isPending ? t('accounts.form.creating') : t('accounts.form.create')}
            onPress={createForm.handleSubmit((values) => {
              createAccountMutation.mutate(values);
            })}
          />
        </Card>
      </Section>

      <Section title={t('accounts.sections.list.title')} subtitle={t('accounts.sections.list.total', { count: accounts.length })}>
        {accounts.length === 0 ? (
          <Card>
            <Text style={styles.emptyText}>{t('accounts.state.empty')}</Text>
          </Card>
        ) : null}

        {accounts.map((account) => (
          <Card key={account.id} style={styles.accountCard}>
            <View style={styles.accountHeader}>
              <View style={styles.accountMeta}>
                <Text style={styles.accountName}>{account.name}</Text>
                <Text style={styles.accountSub}>{`${account.type.toUpperCase()} · ${account.currency}`}</Text>
              </View>

              <Pressable
                onPress={() => {
                  setEditingAccountId(account.id);
                  editForm.reset({
                    name: account.name,
                    type: account.type,
                  });
                }}
              >
                <Text style={styles.linkText}>{t('common.edit')}</Text>
              </Pressable>
            </View>

            {editingAccountId === account.id && editingAccount ? (
              <View style={styles.inlineEditor}>
                <Text style={styles.fieldLabel}>{t('accounts.form.nameLabel')}</Text>
                <Controller
                  control={editForm.control}
                  name="name"
                  render={({ field: { onChange, onBlur, value } }) => (
                    <TextInput
                      style={styles.input}
                      value={value}
                      onChangeText={onChange}
                      onBlur={onBlur}
                      placeholder={t('accounts.form.namePlaceholder')}
                      placeholderTextColor={colors.textMuted}
                    />
                  )}
                />
                {editForm.formState.errors.name ? (
                  <Text style={styles.errorText}>{t(editForm.formState.errors.name.message ?? '')}</Text>
                ) : null}

                <Text style={styles.fieldLabel}>{t('accounts.form.typeLabel')}</Text>
                <Controller
                  control={editForm.control}
                  name="type"
                  render={({ field: { onChange, value } }) => (
                    <TypePicker selected={value} onSelect={onChange} />
                  )}
                />

                <View style={styles.editorActions}>
                  <PrimaryButton
                    label={updateAccountMutation.isPending ? t('common.saving') : t('common.save')}
                    onPress={editForm.handleSubmit((values) => {
                      updateAccountMutation.mutate({ id: editingAccount.id, values });
                    })}
                  />
                  <Pressable
                    style={styles.secondaryAction}
                    onPress={() => {
                      setEditingAccountId(null);
                    }}
                  >
                    <Text style={styles.secondaryActionText}>{t('common.cancel')}</Text>
                  </Pressable>
                </View>
              </View>
            ) : null}
          </Card>
        ))}
      </Section>
    </ScreenContainer>
  );
}

function TypePicker({
  selected,
  onSelect,
}: {
  selected: AccountType;
  onSelect: (value: AccountType) => void;
}) {
  const { t } = useI18n();

  return (
    <View style={styles.chipWrap}>
      {accountTypes.map((type) => (
        <Pressable key={type} onPress={() => onSelect(type)}>
          <Chip label={t(`accounts.accountType.${type}`)} tone={selected === type ? 'primary' : 'default'} />
        </Pressable>
      ))}
    </View>
  );
}

const styles = StyleSheet.create({
  centerState: {
    alignItems: 'center',
    justifyContent: 'center',
    gap: spacing.sm,
    paddingVertical: spacing.xxl,
  },
  stateText: {
    ...typography.body,
    color: colors.textMuted,
  },
  formCard: {
    gap: spacing.sm,
  },
  fieldLabel: {
    ...typography.caption,
    color: colors.textMuted,
  },
  input: {
    height: 46,
    borderRadius: radius.md,
    borderWidth: 1,
    borderColor: colors.border,
    backgroundColor: colors.surface,
    paddingHorizontal: spacing.sm,
    color: colors.text,
    ...typography.body,
  },
  chipWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  accountCard: {
    gap: spacing.sm,
  },
  accountHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    gap: spacing.md,
  },
  accountMeta: {
    flex: 1,
    gap: spacing.xxs,
  },
  accountName: {
    ...typography.subheading,
    color: colors.text,
  },
  accountSub: {
    ...typography.caption,
    color: colors.textMuted,
  },
  linkText: {
    ...typography.caption,
    color: colors.primary,
    fontWeight: '600',
  },
  inlineEditor: {
    gap: spacing.sm,
  },
  editorActions: {
    gap: spacing.xs,
  },
  secondaryAction: {
    height: 40,
    borderRadius: radius.md,
    borderWidth: 1,
    borderColor: colors.border,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: colors.surface,
  },
  secondaryActionText: {
    ...typography.caption,
    color: colors.textMuted,
    fontWeight: '600',
  },
  baseCurrencyText: {
    ...typography.body,
    color: colors.text,
  },
  sessionCard: {
    gap: spacing.xs,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
    color: colors.text,
  },
  errorText: {
    ...typography.caption,
    color: colors.expense,
  },
  emptyText: {
    ...typography.body,
    color: colors.textMuted,
  },
});

===== FILE: apps/mobile/src/features/finance/screens/AddTransactionScreen.tsx =====
import { useEffect, useMemo, useRef } from 'react';
import {
  ActivityIndicator,
  Alert,
  Pressable,
  StyleSheet,
  Text,
  View,
} from 'react-native';

import { zodResolver } from '@hookform/resolvers/zod';
import { transactionCreateInputSchema, type TransactionType } from '@mintly/shared';
import { useNavigation, useRoute } from '@react-navigation/native';
import type { RouteProp } from '@react-navigation/native';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { Controller, useForm } from 'react-hook-form';
import { z } from 'zod';

import { useAuth } from '@app/providers/AuthProvider';
import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { Card, PrimaryButton, ScreenContainer, TextField } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { RootTabParamList } from '@core/navigation/types';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';
import { monthFromIsoString } from '@shared/utils/month';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/grup_harcaması_ekle_(dark)/screen.png
// no touch/keyboard behavior changed by this PR.

const typeOptions: TransactionType[] = ['expense', 'income'];

const transactionFormSchema = z.object({
  type: z.enum(typeOptions),
  accountId: z.string().trim().min(1, 'errors.validation.selectAccount'),
  categoryId: z.string().trim().min(1, 'errors.validation.selectCategory'),
  amount: z
    .string()
    .trim()
    .min(1, 'errors.validation.amountRequired')
    .refine((value) => {
      const parsed = Number(value);
      return Number.isFinite(parsed) && parsed > 0;
    }, 'errors.validation.amountPositive'),
  description: z.string().trim().max(500).optional(),
  occurredAt: z
    .string()
    .trim()
    .min(1, 'errors.validation.dateTimeRequired')
    .refine((value) => !Number.isNaN(Date.parse(value)), 'errors.validation.invalidIsoDateTime'),
});

type TransactionFormValues = z.infer<typeof transactionFormSchema>;

export function AddTransactionScreen() {
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();
  const { t } = useI18n();
  const queryClient = useQueryClient();
  const route = useRoute<RouteProp<RootTabParamList, 'AddTab'>>();
  const navigation = useNavigation();
  const lastPrefillSignatureRef = useRef('');

  const accountsQuery = useQuery({
    queryKey: financeQueryKeys.accounts.list(),
    queryFn: () => withAuth((token) => apiClient.getAccounts(token)),
  });

  const categoriesQuery = useQuery({
    queryKey: financeQueryKeys.categories.list(),
    queryFn: () => withAuth((token) => apiClient.getCategories(token)),
  });

  const form = useForm<TransactionFormValues>({
    resolver: zodResolver(transactionFormSchema),
    defaultValues: {
      type: 'expense',
      accountId: '',
      categoryId: '',
      amount: '',
      description: '',
      occurredAt: new Date().toISOString(),
    },
  });

  const selectedType = form.watch('type');
  const selectedAccountId = form.watch('accountId');
  const selectedCategoryId = form.watch('categoryId');

  const selectedAccount = useMemo(
    () => accountsQuery.data?.accounts.find((account) => account.id === selectedAccountId) ?? null,
    [accountsQuery.data?.accounts, selectedAccountId],
  );

  const filteredCategories = useMemo(
    () => categoriesQuery.data?.categories.filter((category) => category.type === selectedType) ?? [],
    [categoriesQuery.data?.categories, selectedType],
  );

  useEffect(() => {
    if (!selectedCategoryId) {
      return;
    }

    const exists = filteredCategories.some((category) => category.id === selectedCategoryId);
    if (!exists) {
      form.setValue('categoryId', '');
    }
  }, [filteredCategories, form, selectedCategoryId]);

  useEffect(() => {
    const prefill = route.params?.prefill;
    if (!prefill) {
      return;
    }

    const signature = `${prefill.amount ?? ''}|${prefill.description ?? ''}|${prefill.occurredAt ?? ''}`;
    if (lastPrefillSignatureRef.current === signature) {
      return;
    }

    if (prefill.amount) {
      form.setValue('amount', prefill.amount, { shouldValidate: true });
    }
    if (prefill.description) {
      form.setValue('description', prefill.description);
    }
    if (prefill.occurredAt) {
      form.setValue('occurredAt', prefill.occurredAt, { shouldValidate: true });
    }

    lastPrefillSignatureRef.current = signature;
    (navigation as { setParams?: (params: RootTabParamList['AddTab']) => void }).setParams?.({
      prefill: undefined,
    });
  }, [form, navigation, route.params?.prefill]);

  const createTransactionMutation = useMutation({
    mutationFn: (values: TransactionFormValues) => {
      const amount = Number(values.amount);
      const occurredAt = new Date(values.occurredAt).toISOString();

      return withAuth((token) =>
        apiClient.createTransaction(
          transactionCreateInputSchema.parse({
            type: values.type,
            accountId: values.accountId,
            categoryId: values.categoryId,
            amount,
            currency: selectedAccount?.currency ?? 'TRY',
            description: values.description?.trim() || undefined,
            occurredAt,
          }),
          token,
        ),
      );
    },
    onSuccess: async (_, values) => {
      const transactionMonth = monthFromIsoString(values.occurredAt);

      await Promise.all([
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.transactions.all() }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.budgets.month(transactionMonth) }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.analytics.month(transactionMonth) }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.dashboard.recent() }),
      ]);

      form.reset({
        type: 'expense',
        accountId: '',
        categoryId: '',
        amount: '',
        description: '',
        occurredAt: new Date().toISOString(),
      });

      Alert.alert(t('transactions.create.successTitle'), t('transactions.create.successMessage'));
    },
    onError: (error) => {
      Alert.alert(t('errors.transaction.createFailedTitle'), apiErrorText(error));
    },
  });

  if (accountsQuery.isLoading || categoriesQuery.isLoading) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.stateCard}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={[styles.stateText, { color: theme.colors.textMuted }]}>
            {t('transactions.create.state.loading')}
          </Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (accountsQuery.isError || categoriesQuery.isError) {
    const error = accountsQuery.error ?? categoriesQuery.error;

    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.errorCard}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>
            {t('transactions.create.state.loadErrorTitle')}
          </Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(error)}</Text>
          <PrimaryButton
            label={t('common.retry')}
            onPress={() => {
              void accountsQuery.refetch();
              void categoriesQuery.refetch();
            }}
          />
        </Card>
      </ScreenContainer>
    );
  }

  const dark = mode === 'dark';
  const accounts = accountsQuery.data?.accounts ?? [];
  const panelBg = dark ? '#121826' : theme.colors.surface;
  const panelBorder = dark ? '#27344F' : theme.colors.border;

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.container}>
        <Card
          dark={dark}
          style={[
            styles.heroCard,
            {
              backgroundColor: panelBg,
              borderColor: panelBorder,
            },
          ]}
        >
          <Text style={[styles.heroTitle, { color: theme.colors.text }]}>{t('transactions.create.title')}</Text>
          <Text style={[styles.heroSubtitle, { color: theme.colors.textMuted }]}>
            {t('transactions.create.subtitle')}
          </Text>

          <View style={styles.segmentWrap}>
            <Controller
              control={form.control}
              name="type"
              render={({ field: { value, onChange } }) => (
                <View style={[styles.segment, { backgroundColor: dark ? '#0E1523' : '#EEF3FB' }]}>
                  {typeOptions.map((option) => {
                    const active = option === value;
                    const tone = option === 'income' ? '#17B26A' : '#F04438';

                    return (
                      <Pressable
                        key={option}
                        accessibilityRole="button"
                        onPress={() => onChange(option)}
                        style={[
                          styles.segmentButton,
                          active
                            ? {
                                backgroundColor: dark ? '#1A2336' : '#FFFFFF',
                                borderColor: tone,
                              }
                            : null,
                        ]}
                      >
                        <Text
                          style={[
                            styles.segmentButtonText,
                            { color: active ? tone : theme.colors.textMuted },
                          ]}
                        >
                          {option === 'income' ? t('analytics.income') : t('analytics.expense')}
                        </Text>
                      </Pressable>
                    );
                  })}
                </View>
              )}
            />
          </View>
        </Card>

        <Card
          dark={dark}
          style={[
            styles.formCard,
            {
              backgroundColor: panelBg,
              borderColor: panelBorder,
            },
          ]}
        >
          <View style={styles.sectionHead}>
            <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>
              {t('transactions.create.sections.details')}
            </Text>
            <Text style={[styles.sectionSubtitle, { color: theme.colors.textMuted }]}>
              {t('transactions.create.sections.step')}
            </Text>
          </View>

          <Text style={[styles.fieldLabel, { color: theme.colors.labelMuted }]}>
            {t('transactions.create.fields.account')}
          </Text>
          <Controller
            control={form.control}
            name="accountId"
            render={({ field: { value, onChange } }) => (
              <View style={styles.choiceWrap}>
                {accounts.map((account) => {
                  const selected = value === account.id;

                  return (
                    <Pressable
                      key={account.id}
                      accessibilityRole="button"
                      onPress={() => onChange(account.id)}
                      style={[
                        styles.choiceChip,
                        {
                          borderColor: selected ? theme.colors.primary : panelBorder,
                          backgroundColor: selected
                            ? dark
                              ? 'rgba(47, 107, 255, 0.20)'
                              : '#EAF0FF'
                            : dark
                              ? '#0E1523'
                              : '#F8FBFF',
                        },
                      ]}
                    >
                      <Text
                        style={[
                          styles.choiceChipLabel,
                          { color: selected ? theme.colors.primary : theme.colors.textMuted },
                        ]}
                      >
                        {account.name}
                      </Text>
                    </Pressable>
                  );
                })}
              </View>
            )}
          />
          {form.formState.errors.accountId ? (
            <Text style={[styles.inlineError, { color: theme.colors.expense }]}>
              {t(form.formState.errors.accountId.message ?? '')}
            </Text>
          ) : null}

          <Text style={[styles.fieldLabel, { color: theme.colors.labelMuted }]}>
            {t('transactions.create.fields.category')}
          </Text>
          <Controller
            control={form.control}
            name="categoryId"
            render={({ field: { value, onChange } }) => (
              <View style={styles.choiceWrap}>
                {filteredCategories.map((category) => {
                  const selected = value === category.id;

                  return (
                    <Pressable
                      key={category.id}
                      accessibilityRole="button"
                      onPress={() => onChange(category.id)}
                      style={[
                        styles.choiceChip,
                        {
                          borderColor: selected ? theme.colors.primary : panelBorder,
                          backgroundColor: selected
                            ? dark
                              ? 'rgba(47, 107, 255, 0.20)'
                              : '#EAF0FF'
                            : dark
                              ? '#0E1523'
                              : '#F8FBFF',
                        },
                      ]}
                    >
                      <Text
                        style={[
                          styles.choiceChipLabel,
                          { color: selected ? theme.colors.primary : theme.colors.textMuted },
                        ]}
                      >
                        {category.name}
                      </Text>
                    </Pressable>
                  );
                })}
              </View>
            )}
          />
          {form.formState.errors.categoryId ? (
            <Text style={[styles.inlineError, { color: theme.colors.expense }]}>
              {t(form.formState.errors.categoryId.message ?? '')}
            </Text>
          ) : null}

          <Controller
            control={form.control}
            name="amount"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextField
                autoCapitalize="none"
                error={form.formState.errors.amount?.message ? t(form.formState.errors.amount.message) : undefined}
                keyboardType="decimal-pad"
                label={t('transactions.create.fields.amount')}
                leftAdornment={
                  <Text style={[styles.adornmentText, { color: theme.colors.textMuted }]}>₺</Text>
                }
                onBlur={onBlur}
                onChangeText={onChange}
                placeholder={t('transactions.create.fields.amountPlaceholder')}
                value={value}
              />
            )}
          />

          <Controller
            control={form.control}
            name="description"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextField
                autoCapitalize="sentences"
                label={t('transactions.create.fields.description')}
                onBlur={onBlur}
                onChangeText={onChange}
                placeholder={t('transactions.create.fields.descriptionPlaceholder')}
                value={value ?? ''}
              />
            )}
          />

          <Controller
            control={form.control}
            name="occurredAt"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextField
                autoCapitalize="none"
                error={form.formState.errors.occurredAt?.message ? t(form.formState.errors.occurredAt.message) : undefined}
                label={t('transactions.create.fields.occurredAt')}
                labelRight={
                  <Pressable
                    accessibilityRole="button"
                    onPress={() => onChange(new Date().toISOString())}
                    style={styles.nowButton}
                  >
                    <Text style={[styles.nowButtonText, { color: theme.colors.primary }]}>
                      {t('common.now')}
                    </Text>
                  </Pressable>
                }
                onBlur={onBlur}
                onChangeText={onChange}
                placeholder={t('transactions.create.fields.occurredAtPlaceholder')}
                value={value}
              />
            )}
          />

          <View
            style={[
              styles.currencyRow,
              {
                borderColor: panelBorder,
                backgroundColor: dark ? '#0E1523' : '#F8FBFF',
              },
            ]}
          >
            <Text style={[styles.currencyLabel, { color: theme.colors.textMuted }]}>
              {t('transactions.create.fields.currency')}
            </Text>
            <Text style={[styles.currencyValue, { color: theme.colors.text }]}> 
              {selectedAccount?.currency ?? t('transactions.create.selectAccountFirst')}
            </Text>
          </View>

          <PrimaryButton
            disabled={createTransactionMutation.isPending}
            label={createTransactionMutation.isPending ? t('common.saving') : t('transactions.create.submit')}
            onPress={form.handleSubmit((values) => {
              createTransactionMutation.mutate(values);
            })}
          />
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  heroCard: {
    gap: spacing.sm,
  },
  heroTitle: {
    ...typography.heading,
    fontSize: 22,
    fontWeight: '700',
  },
  heroSubtitle: {
    ...typography.body,
    fontSize: 14,
  },
  segmentWrap: {
    marginTop: spacing.xxs,
  },
  segment: {
    borderRadius: radius.full,
    flexDirection: 'row',
    gap: spacing.xs,
    padding: spacing.xxs,
  },
  segmentButton: {
    alignItems: 'center',
    borderRadius: radius.full,
    borderWidth: 1,
    borderColor: 'transparent',
    flex: 1,
    minHeight: 38,
    justifyContent: 'center',
    paddingHorizontal: spacing.sm,
  },
  segmentButtonText: {
    ...typography.caption,
    fontWeight: '700',
  },
  formCard: {
    gap: spacing.sm,
  },
  sectionHead: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  sectionTitle: {
    ...typography.subheading,
    fontSize: 17,
    fontWeight: '700',
  },
  sectionSubtitle: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '600',
    letterSpacing: 0.3,
  },
  fieldLabel: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
  },
  choiceWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  choiceChip: {
    borderRadius: radius.full,
    borderWidth: 1,
    minHeight: 34,
    justifyContent: 'center',
    paddingHorizontal: spacing.sm,
  },
  choiceChipLabel: {
    ...typography.caption,
    fontWeight: '700',
  },
  inlineError: {
    ...typography.caption,
    fontSize: 12,
  },
  adornmentText: {
    ...typography.subheading,
    fontSize: 16,
    fontWeight: '700',
  },
  nowButton: {
    paddingHorizontal: spacing.xxs,
    paddingVertical: 2,
  },
  nowButtonText: {
    ...typography.caption,
    fontWeight: '700',
  },
  currencyRow: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
    minHeight: 44,
    paddingHorizontal: spacing.sm,
  },
  currencyLabel: {
    ...typography.caption,
    fontSize: 12,
  },
  currencyValue: {
    ...typography.caption,
    fontWeight: '700',
  },
  stateCard: {
    alignItems: 'center',
    gap: spacing.sm,
    justifyContent: 'center',
    minHeight: 160,
  },
  stateText: {
    ...typography.body,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
  },
  errorText: {
    ...typography.caption,
  },
});

===== FILE: apps/mobile/src/features/finance/screens/AnalyticsScreen.tsx =====
import { useMemo, useState } from 'react';
import {
  ActivityIndicator,
  Pressable,
  StyleSheet,
  Text,
  View,
} from 'react-native';

import type { CategoryType } from '@mintly/shared';
import { useNavigation } from '@react-navigation/native';
import { useQuery } from '@tanstack/react-query';

import { useAuth } from '@app/providers/AuthProvider';
import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { Card, ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';
import { formatMonthLabel, getCurrentMonthString, getTrendRange, shiftMonth } from '@shared/utils/month';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/harcama_analizi_(koyu_mod)_2/screen.png
// no touch/keyboard behavior changed by this PR.

type InsightRange = 'weekly' | 'monthly' | 'yearly';

const RANGE_TABS: Array<{ key: InsightRange; labelKey: string }> = [
  { key: 'weekly', labelKey: 'analytics.range.weekly' },
  { key: 'monthly', labelKey: 'analytics.range.monthly' },
  { key: 'yearly', labelKey: 'analytics.range.yearly' },
];

const CATEGORY_ICON_BACKGROUNDS = ['#2F6BFF', '#4C7CFF', '#3D5FE3', '#6B4EFF'];

function formatMoney(amount: number, currency: string, locale: string): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

function clampPercent(value: number): number {
  return Math.max(0, Math.min(100, value));
}

function buildDailyBars(values: number[]): number[] {
  const fallback = [62, 44, 66, 53, 74, 29, 47];
  if (!values.length) {
    return fallback;
  }

  const nonZero = values.filter((value) => value > 0);
  if (!nonZero.length) {
    return fallback;
  }

  const max = Math.max(...nonZero);
  return Array.from({ length: 7 }, (_, index) => {
    const source = nonZero[index % nonZero.length] ?? 0;
    return Math.max(18, Math.round((source / max) * 74));
  });
}

function LoadingSkeleton({ dark }: { dark: boolean }) {
  const block = dark ? '#171B2A' : '#E9EEF8';

  return (
    <View style={styles.skeletonWrap}>
      <View style={[styles.skeletonHeader, { backgroundColor: block }]} />
      <View style={[styles.skeletonTabs, { backgroundColor: block }]} />
      <View style={[styles.skeletonMainCard, { backgroundColor: block }]} />
      <View style={[styles.skeletonChartCard, { backgroundColor: block }]} />
      <View style={[styles.skeletonCategoryCard, { backgroundColor: block }]} />
      <View style={[styles.skeletonCategoryCard, { backgroundColor: block }]} />
    </View>
  );
}

export function AnalyticsScreen() {
  const navigation = useNavigation<any>();
  const { withAuth, user } = useAuth();
  const { theme, mode } = useTheme();
  const { locale, t } = useI18n();

  const [month, setMonth] = useState(getCurrentMonthString());
  const [range, setRange] = useState<InsightRange>('monthly');
  const [categoryType, setCategoryType] = useState<CategoryType>('expense');

  const trendSpan = range === 'yearly' ? 12 : range === 'monthly' ? 6 : 3;
  const trendRange = useMemo(() => getTrendRange(month, trendSpan), [month, trendSpan]);

  const summaryQuery = useQuery({
    queryKey: financeQueryKeys.analytics.summary(month),
    queryFn: () => withAuth((token) => apiClient.getAnalyticsSummary({ month }, token)),
  });

  const byCategoryQuery = useQuery({
    queryKey: financeQueryKeys.analytics.byCategory(month, categoryType),
    queryFn: () => withAuth((token) => apiClient.getAnalyticsByCategory({ month, type: categoryType }, token)),
  });

  const trendQuery = useQuery({
    queryKey: financeQueryKeys.analytics.trend(month, trendRange.from, trendRange.to),
    queryFn: () =>
      withAuth((token) =>
        apiClient.getAnalyticsTrend(
          {
            from: trendRange.from,
            to: trendRange.to,
          },
          token,
        ),
      ),
  });

  if (summaryQuery.isLoading && !summaryQuery.data) {
    return (
      <ScreenContainer scrollable={false} dark={mode === 'dark'} contentStyle={styles.containerContent}>
        <View style={styles.loadingStateWrap}>
          <LoadingSkeleton dark={mode === 'dark'} />
          <Text style={[styles.loadingStateText, { color: theme.colors.textMuted }]}>
            {t('common.loadingShort')}
          </Text>
        </View>
      </ScreenContainer>
    );
  }

  if (summaryQuery.isError && !summaryQuery.data) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>{t('analytics.state.errorTitle')}</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>
            {apiErrorText(summaryQuery.error)}
          </Text>
        </Card>
      </ScreenContainer>
    );
  }

  const summary = summaryQuery.data;
  if (!summary) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'}>
          <Text style={[styles.errorText, { color: theme.colors.textMuted }]}>{t('analytics.state.noData')}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  const currency = summary.currency ?? user?.baseCurrency ?? 'TRY';
  const topCategories = byCategoryQuery.data?.categories ?? [];
  const mainCategory = topCategories[0]?.name ?? t('analytics.noCategory');

  const expenseBars = trendQuery.data?.points.map((point) => point.expenseTotal) ?? [];
  const dailyBars = buildDailyBars(expenseBars);

  const expenseTrendPercent =
    summary.expenseTotal <= 0
      ? 0
      : clampPercent((summary.netTotal / summary.expenseTotal) * 100);

  const categoryTotal = Math.max(
    1,
    topCategories.reduce((accumulator, item) => accumulator + item.total, 0),
  );

  const dark = mode === 'dark';
  const panelBg = dark ? '#0F1425' : '#FFFFFF';
  const panelBorder = dark ? '#232843' : '#E3E9F5';
  const sectionBg = dark ? '#10172A' : '#F7FAFF';

  return (
    <ScreenContainer scrollable={false} dark={dark} contentStyle={styles.containerContent}>
      <View style={styles.contentWrap}>
        <View style={styles.topBar}>
          <Text style={[styles.topIcon, { color: theme.colors.text }]}>{'‹'}</Text>
          <Text adjustsFontSizeToFit numberOfLines={1} style={[styles.screenTitle, { color: theme.colors.text }]}>
            {t('analytics.title')}
          </Text>
          <Text style={[styles.topIcon, { color: theme.colors.primary }]}>↥</Text>
        </View>

        <View
          style={[
            styles.tabsWrap,
            {
              backgroundColor: dark ? '#101629' : '#EEF3FC',
              borderColor: dark ? '#212A45' : '#DDE6F5',
            },
          ]}
        >
          {RANGE_TABS.map((tab) => {
            const active = tab.key === range;
            return (
              <Pressable
                key={tab.key}
                accessibilityRole="button"
                onPress={() => setRange(tab.key)}
                style={styles.tabButton}
              >
                <Text
                  adjustsFontSizeToFit
                  numberOfLines={1}
                  style={[
                    styles.tabLabel,
                    {
                      color: active ? theme.colors.primary : theme.colors.textMuted,
                      fontWeight: active ? '700' : '600',
                    },
                  ]}
                >
                  {t(tab.labelKey)}
                </Text>
                {active ? (
                  <View style={[styles.tabUnderline, { backgroundColor: theme.colors.primary }]} />
                ) : null}
              </Pressable>
            );
          })}
        </View>

        <View style={styles.monthRow}>
          <Pressable
            accessibilityRole="button"
            onPress={() => setMonth(shiftMonth(month, -1))}
            style={styles.monthArrow}
          >
            <Text style={[styles.monthArrowText, { color: theme.colors.text }]}>{'<'}</Text>
          </Pressable>

          <Text
            adjustsFontSizeToFit
            numberOfLines={1}
            style={[styles.monthLabel, { color: theme.colors.textMuted }]}
          >
            {formatMonthLabel(month)}
          </Text>

          <Pressable
            accessibilityRole="button"
            onPress={() => setMonth(shiftMonth(month, 1))}
            style={styles.monthArrow}
          >
            <Text style={[styles.monthArrowText, { color: theme.colors.text }]}>{'>'}</Text>
          </Pressable>
        </View>

        <Card
          dark={dark}
          style={[
            styles.totalCard,
            {
              backgroundColor: panelBg,
              borderColor: panelBorder,
            },
          ]}
        >
          <Text numberOfLines={1} style={[styles.totalLabel, { color: theme.colors.textMuted }]}>
            {t('analytics.totalSpending')}
          </Text>
          <Text adjustsFontSizeToFit numberOfLines={1} style={[styles.totalValue, { color: theme.colors.text }]}>
            {formatMoney(summary.expenseTotal, currency, locale)}
          </Text>

          <View style={[styles.percentPill, { backgroundColor: dark ? '#0D3A31' : '#DCFCEB' }]}>
            <Text style={styles.percentPillText}>
              {t('analytics.fromLastMonth', { percent: expenseTrendPercent.toFixed(0) })}
            </Text>
          </View>

          <View style={styles.donutWrap}>
            <View style={[styles.donutRingBase, { borderColor: dark ? '#2B5BD8' : '#4F7DFF' }]} />
            <View style={[styles.donutRingArc, { borderTopColor: '#76B4FF', borderRightColor: '#76B4FF' }]} />
            <View style={[styles.donutRingArc, { borderTopColor: '#2F6BFF', borderRightColor: '#2F6BFF', transform: [{ rotate: '135deg' }] }]} />

            <View
              style={[
                styles.donutInner,
                {
                  backgroundColor: dark ? '#0C1221' : '#F7FAFF',
                  borderColor: dark ? '#1E2842' : '#E5ECF8',
                },
              ]}
            >
              <Text style={[styles.donutLabel, { color: theme.colors.textMuted }]}>{t('analytics.mainCategory')}</Text>
              <Text numberOfLines={2} style={[styles.donutValue, { color: theme.colors.text }]}>
                {mainCategory}
              </Text>
            </View>
          </View>
        </Card>

        <Card
          dark={dark}
          style={[
            styles.trendCard,
            {
              backgroundColor: panelBg,
              borderColor: panelBorder,
            },
          ]}
        >
          <View style={styles.sectionHeader}>
            <Text numberOfLines={1} style={[styles.sectionTitle, { color: theme.colors.text }]}>
              {t('analytics.dailyTrends')}
            </Text>
            <Text numberOfLines={1} style={[styles.sectionMeta, { color: theme.colors.textMuted }]}>
              {t('analytics.last7Days')}
            </Text>
          </View>

          <View style={[styles.barBoard, { backgroundColor: sectionBg, borderColor: panelBorder }]}> 
            {dailyBars.map((height, index) => (
              <View key={DAY_LABELS[index]} style={styles.barItem}>
                <View
                  style={[
                    styles.bar,
                    {
                      height,
                      backgroundColor: index % 2 === 0 ? '#5B2BFF' : '#3A5BFF',
                    },
                  ]}
                />
                <Text style={[styles.barLabel, { color: theme.colors.textMuted }]}>{t(DAY_LABELS[index])}</Text>
              </View>
            ))}
          </View>

          {trendQuery.isLoading ? (
            <View style={styles.inlineLoadingWrap}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text style={[styles.inlineLoadingText, { color: theme.colors.textMuted }]}>{t('analytics.refreshingTrend')}</Text>
            </View>
          ) : null}
        </Card>

        <Card
          dark={dark}
          style={[
            styles.categoriesCard,
            {
              backgroundColor: panelBg,
              borderColor: panelBorder,
            },
          ]}
        >
          <View style={styles.sectionHeader}>
            <Text numberOfLines={1} style={[styles.sectionTitle, { color: theme.colors.text }]}>
              {t('analytics.topCategories')}
            </Text>
            <View style={styles.typeToggleWrap}>
              {(['expense', 'income'] as const).map((type) => {
                const active = categoryType === type;
                return (
                  <Pressable
                    key={type}
                    accessibilityRole="button"
                    onPress={() => setCategoryType(type)}
                    style={[
                      styles.typeChip,
                      {
                        backgroundColor: active
                          ? theme.colors.primary
                          : dark
                            ? 'rgba(255,255,255,0.06)'
                            : '#EEF2FA',
                      },
                    ]}
                  >
                    <Text
                      numberOfLines={1}
                      style={[
                        styles.typeChipText,
                        { color: active ? '#FFFFFF' : theme.colors.textMuted },
                      ]}
                    >
                      {type === 'expense' ? t('analytics.expense') : t('analytics.income')}
                    </Text>
                  </Pressable>
                );
              })}
            </View>
          </View>

          {byCategoryQuery.isLoading && !byCategoryQuery.data ? (
            <View style={styles.inlineLoadingWrap}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text style={[styles.inlineLoadingText, { color: theme.colors.textMuted }]}>{t('analytics.loadingCategories')}</Text>
            </View>
          ) : null}

          {byCategoryQuery.isError && !byCategoryQuery.data ? (
            <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(byCategoryQuery.error)}</Text>
          ) : null}

          {byCategoryQuery.data && topCategories.length === 0 ? (
            <Text style={[styles.emptyText, { color: theme.colors.textMuted }]}>{t('analytics.noCategories')}</Text>
          ) : null}

          {topCategories.slice(0, 4).map((item, index) => {
            const percent = clampPercent((item.total / categoryTotal) * 100);

            return (
              <View
                key={item.categoryId}
                style={[
                  styles.categoryRow,
                  {
                    backgroundColor: sectionBg,
                    borderColor: panelBorder,
                  },
                ]}
              >
                <View style={styles.categoryLeft}>
                  <View
                    style={[
                      styles.categoryIcon,
                      { backgroundColor: CATEGORY_ICON_BACKGROUNDS[index % CATEGORY_ICON_BACKGROUNDS.length] },
                    ]}
                  >
                    <Text style={styles.categoryIconText}>{item.name.charAt(0).toUpperCase()}</Text>
                  </View>

                  <View style={styles.categoryTextWrap}>
                    <Text numberOfLines={1} style={[styles.categoryName, { color: theme.colors.text }]}>
                      {item.name}
                    </Text>
                    <Text numberOfLines={1} style={[styles.categoryMeta, { color: theme.colors.textMuted }]}>
                      {t('analytics.transactionsCount', { count: item.count })}
                    </Text>
                  </View>
                </View>

                <View style={styles.categoryRight}>
                  <Text
                    adjustsFontSizeToFit
                    numberOfLines={1}
                    style={[
                      styles.categoryAmount,
                      { color: categoryType === 'expense' ? theme.colors.expense : theme.colors.income },
                    ]}
                  >
                    {formatMoney(item.total, currency, locale)}
                  </Text>
                  <Text numberOfLines={1} style={[styles.categoryMeta, { color: theme.colors.textMuted }]}>
                    {t('analytics.percentOfTotal', { percent: percent.toFixed(0) })}
                  </Text>
                </View>
              </View>
            );
          })}
        </Card>

        <Card
          dark={dark}
          style={[
            styles.entryCard,
            {
              backgroundColor: panelBg,
              borderColor: panelBorder,
            },
          ]}
        >
          <Text numberOfLines={1} style={[styles.sectionTitle, { color: theme.colors.text }]}>
            {t('analytics.premiumInsights')}
          </Text>
          <Pressable
            accessibilityRole="button"
            onPress={() => navigation.navigate('AiAdvisor')}
            style={({ pressed }) => [styles.insightsCta, pressed && styles.entryPressed]}
          >
            <Text style={[styles.insightsCtaText, { color: theme.colors.primary }]}>
              {t('analytics.aiAdvisorCta')}
            </Text>
          </Pressable>
          <View style={styles.entryRow}>
            <Pressable
              accessibilityRole="button"
              onPress={() => navigation.navigate('AiAdvisor')}
              style={({ pressed }) => [
                styles.entryButton,
                {
                  backgroundColor: dark ? 'rgba(47,107,255,0.16)' : '#ECF2FF',
                  borderColor: dark ? 'rgba(47,107,255,0.45)' : '#D4E1FF',
                },
                pressed && styles.entryPressed,
              ]}
            >
              <Text numberOfLines={1} style={[styles.entryTitle, { color: theme.colors.text }]}>
                {t('analytics.aiAdvisor')}
              </Text>
              <Text numberOfLines={2} style={[styles.entrySubtitle, { color: theme.colors.textMuted }]}>
                {t('analytics.aiAdvisorSubtitle')}
              </Text>
            </Pressable>

            <Pressable
              accessibilityRole="button"
              onPress={() => navigation.navigate('WeeklyReport')}
              style={({ pressed }) => [
                styles.entryButton,
                {
                  backgroundColor: dark ? 'rgba(23,178,106,0.14)' : '#EAF9F0',
                  borderColor: dark ? 'rgba(23,178,106,0.4)' : '#CBEFD9',
                },
                pressed && styles.entryPressed,
              ]}
            >
              <Text numberOfLines={1} style={[styles.entryTitle, { color: theme.colors.text }]}>
                {t('analytics.weeklyReport')}
              </Text>
              <Text numberOfLines={2} style={[styles.entrySubtitle, { color: theme.colors.textMuted }]}>
                {t('analytics.weeklyReportSubtitle')}
              </Text>
            </Pressable>
          </View>
        </Card>
      </View>
    </ScreenContainer>
  );
}

const DAY_LABELS = [
  'analytics.days.mon',
  'analytics.days.tue',
  'analytics.days.wed',
  'analytics.days.thu',
  'analytics.days.fri',
  'analytics.days.sat',
  'analytics.days.sun',
];

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    gap: 0,
    paddingBottom: 0,
    paddingHorizontal: 0,
    paddingTop: 0,
  },
  contentWrap: {
    gap: spacing.sm,
    paddingBottom: spacing.xl,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
  },
  loadingStateWrap: {
    gap: spacing.sm,
  },
  loadingStateText: {
    ...typography.body,
    textAlign: 'center',
  },
  topBar: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    justifyContent: 'space-between',
    minHeight: 38,
  },
  topIcon: {
    ...typography.subheading,
    fontSize: 22,
    width: 32,
  },
  screenTitle: {
    ...typography.heading,
    fontSize: 24,
    flex: 1,
    textAlign: 'center',
  },
  tabsWrap: {
    borderRadius: radius.lg,
    borderWidth: 1,
    flexDirection: 'row',
    overflow: 'hidden',
  },
  tabButton: {
    alignItems: 'center',
    flex: 1,
    gap: spacing.xxs,
    minHeight: 42,
    justifyContent: 'center',
    paddingHorizontal: spacing.xs,
    paddingTop: spacing.xs,
  },
  tabLabel: {
    ...typography.caption,
    fontSize: 13,
    textAlign: 'center',
  },
  tabUnderline: {
    borderRadius: radius.full,
    height: 2,
    width: '55%',
  },
  monthRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'center',
  },
  monthArrow: {
    alignItems: 'center',
    height: 30,
    justifyContent: 'center',
    width: 30,
  },
  monthArrowText: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  monthLabel: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '600',
    letterSpacing: 0.25,
    flexShrink: 1,
    maxWidth: 220,
    minWidth: 140,
    textAlign: 'center',
    textTransform: 'uppercase',
  },
  totalCard: {
    gap: spacing.xs,
    paddingBottom: spacing.md,
    paddingTop: spacing.md,
  },
  totalLabel: {
    ...typography.caption,
    alignSelf: 'center',
    fontSize: 14,
    letterSpacing: 0.5,
  },
  totalValue: {
    ...typography.amount,
    alignSelf: 'center',
    fontSize: 48,
    fontWeight: '800',
    lineHeight: 54,
  },
  percentPill: {
    alignSelf: 'center',
    borderRadius: radius.full,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xxs,
  },
  percentPillText: {
    ...typography.caption,
    color: '#16B364',
    fontWeight: '700',
  },
  donutWrap: {
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: spacing.xs,
    minHeight: 176,
  },
  donutRingBase: {
    borderRadius: radius.full,
    borderWidth: 16,
    height: 176,
    width: 176,
  },
  donutRingArc: {
    borderColor: 'transparent',
    borderRadius: radius.full,
    borderWidth: 16,
    height: 176,
    position: 'absolute',
    transform: [{ rotate: '35deg' }],
    width: 176,
  },
  donutInner: {
    alignItems: 'center',
    borderRadius: radius.full,
    borderWidth: 1,
    gap: 2,
    height: 122,
    justifyContent: 'center',
    position: 'absolute',
    width: 122,
  },
  donutLabel: {
    ...typography.caption,
    fontSize: 11,
  },
  donutValue: {
    ...typography.subheading,
    fontSize: 28,
    fontWeight: '700',
    textAlign: 'center',
  },
  trendCard: {
    gap: spacing.sm,
  },
  sectionHeader: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    justifyContent: 'space-between',
  },
  sectionTitle: {
    ...typography.heading,
    flex: 1,
    fontSize: 21,
  },
  sectionMeta: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '600',
  },
  barBoard: {
    borderRadius: radius.md,
    borderWidth: 1,
    flexDirection: 'row',
    gap: spacing.xs,
    justifyContent: 'space-between',
    minHeight: 136,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  barItem: {
    alignItems: 'center',
    flex: 1,
    justifyContent: 'flex-end',
  },
  bar: {
    borderRadius: radius.sm,
    minHeight: 12,
    width: '85%',
  },
  barLabel: {
    ...typography.caption,
    fontSize: 10,
    marginTop: spacing.xs,
  },
  inlineLoadingWrap: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  inlineLoadingText: {
    ...typography.caption,
  },
  categoriesCard: {
    gap: spacing.sm,
  },
  entryCard: {
    gap: spacing.sm,
  },
  insightsCta: {
    alignSelf: 'flex-start',
    borderRadius: radius.full,
    paddingVertical: spacing.xxs,
  },
  insightsCtaText: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
    letterSpacing: 0.2,
  },
  entryRow: {
    gap: spacing.sm,
  },
  entryButton: {
    borderRadius: radius.md,
    borderWidth: 1,
    gap: spacing.xxs,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  entryTitle: {
    ...typography.subheading,
    fontSize: 15,
    fontWeight: '700',
  },
  entrySubtitle: {
    ...typography.caption,
    fontSize: 12,
    lineHeight: 16,
  },
  entryPressed: {
    opacity: 0.84,
  },
  typeToggleWrap: {
    flexDirection: 'row',
    gap: spacing.xs,
  },
  typeChip: {
    borderRadius: radius.full,
    minHeight: 28,
    paddingHorizontal: spacing.sm,
    justifyContent: 'center',
  },
  typeChipText: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
  },
  categoryRow: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  categoryLeft: {
    alignItems: 'center',
    flexDirection: 'row',
    flex: 1,
    gap: spacing.sm,
    minWidth: 0,
  },
  categoryTextWrap: {
    flex: 1,
    minWidth: 0,
  },
  categoryIcon: {
    alignItems: 'center',
    borderRadius: radius.sm,
    height: 34,
    justifyContent: 'center',
    width: 34,
  },
  categoryIconText: {
    ...typography.caption,
    color: '#FFFFFF',
    fontWeight: '800',
  },
  categoryName: {
    ...typography.subheading,
    fontWeight: '700',
  },
  categoryMeta: {
    ...typography.caption,
    fontSize: 11,
  },
  categoryRight: {
    alignItems: 'flex-end',
    gap: 2,
  },
  categoryAmount: {
    ...typography.subheading,
    fontSize: 20,
    fontWeight: '700',
  },
  skeletonWrap: {
    gap: spacing.sm,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
  },
  skeletonHeader: {
    borderRadius: radius.md,
    height: 42,
    width: '65%',
  },
  skeletonTabs: {
    borderRadius: radius.md,
    height: 44,
    width: '100%',
  },
  skeletonMainCard: {
    borderRadius: radius.lg,
    height: 320,
    width: '100%',
  },
  skeletonChartCard: {
    borderRadius: radius.lg,
    height: 200,
    width: '100%',
  },
  skeletonCategoryCard: {
    borderRadius: radius.md,
    height: 72,
    width: '100%',
  },
  errorTitle: {
    ...typography.subheading,
  },
  errorText: {
    ...typography.body,
  },
  emptyText: {
    ...typography.body,
  },
});

===== FILE: apps/mobile/src/features/finance/screens/BudgetsScreen.tsx =====
import { useEffect, useMemo, useState } from 'react';
import {
  ActivityIndicator,
  Alert,
  Pressable,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  View,
} from 'react-native';

import { zodResolver } from '@hookform/resolvers/zod';
import { budgetCreateInputSchema } from '@mintly/shared';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { Controller, useForm } from 'react-hook-form';
import { z } from 'zod';

import { useAuth } from '@app/providers/AuthProvider';
import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { Card, PrimaryButton, ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';
import { formatMonthLabel, getCurrentMonthString, shiftMonth } from '@shared/utils/month';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/bütçe_planlama/screen.png
// no touch/keyboard behavior changed by this PR.

const budgetFormSchema = z.object({
  categoryId: budgetCreateInputSchema.shape.categoryId,
  limitAmount: z
    .string()
    .trim()
    .min(1, 'errors.validation.limitAmountRequired')
    .refine((value) => {
      const parsed = Number(value);
      return Number.isFinite(parsed) && parsed > 0;
    }, 'errors.validation.limitAmountPositive'),
});

const editBudgetFormSchema = z.object({
  limitAmount: z
    .string()
    .trim()
    .min(1, 'errors.validation.limitAmountRequired')
    .refine((value) => {
      const parsed = Number(value);
      return Number.isFinite(parsed) && parsed > 0;
    }, 'errors.validation.limitAmountPositive'),
});

type BudgetFormValues = z.infer<typeof budgetFormSchema>;
type EditBudgetFormValues = z.infer<typeof editBudgetFormSchema>;

function formatMoney(amount: number, currency: string, locale: string): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

function getProgressTone(percentUsed: number): {
  color: string;
  chipBackground: string;
  chipText: string;
} {
  if (percentUsed >= 100) {
    return {
      color: '#FF4D57',
      chipBackground: '#4D1F2A',
      chipText: '#FF7680',
    };
  }

  if (percentUsed >= 85) {
    return {
      color: '#F59E0B',
      chipBackground: '#4A3310',
      chipText: '#FFBF4D',
    };
  }

  return {
    color: '#22D3A6',
    chipBackground: '#113A33',
    chipText: '#52F3C1',
  };
}

function categoryGlyph(name: string): string {
  const lower = name.toLowerCase();
  if (lower.includes('food') || lower.includes('gida') || lower.includes('market')) {
    return '🍴';
  }

  if (lower.includes('transport') || lower.includes('ulaşım') || lower.includes('ulasim')) {
    return '🚗';
  }

  if (lower.includes('shopping') || lower.includes('alış') || lower.includes('alis')) {
    return '🛍';
  }

  if (lower.includes('rent') || lower.includes('kira') || lower.includes('bill') || lower.includes('fatura')) {
    return '🏠';
  }

  return '◉';
}

function LoadingSkeleton({ dark }: { dark: boolean }) {
  const block = dark ? '#181C2E' : '#E8EDF7';

  return (
    <View style={styles.skeletonWrap}>
      <View style={[styles.skeletonHeader, { backgroundColor: block }]} />
      <View style={[styles.skeletonOverview, { backgroundColor: block }]} />
      <View style={[styles.skeletonRow, { backgroundColor: block }]} />
      <View style={[styles.skeletonRow, { backgroundColor: block }]} />
      <View style={[styles.skeletonRow, { backgroundColor: block }]} />
    </View>
  );
}

export function BudgetsScreen() {
  const { withAuth, user } = useAuth();
  const { theme, mode } = useTheme();
  const { t, locale } = useI18n();
  const queryClient = useQueryClient();

  const [month, setMonth] = useState(getCurrentMonthString());
  const [composerOpen, setComposerOpen] = useState(false);
  const [editingBudgetId, setEditingBudgetId] = useState<string | null>(null);

  const currency = user?.baseCurrency ?? 'TRY';

  const budgetsQuery = useQuery({
    queryKey: financeQueryKeys.budgets.list(month),
    queryFn: () => withAuth((token) => apiClient.listBudgets({ month }, token)),
  });

  const categoriesQuery = useQuery({
    queryKey: financeQueryKeys.categories.list(),
    queryFn: () => withAuth((token) => apiClient.getCategories(token)),
  });

  const addForm = useForm<BudgetFormValues>({
    resolver: zodResolver(budgetFormSchema),
    defaultValues: {
      categoryId: '',
      limitAmount: '',
    },
  });

  const editForm = useForm<EditBudgetFormValues>({
    resolver: zodResolver(editBudgetFormSchema),
    defaultValues: {
      limitAmount: '',
    },
  });

  const expenseCategories = useMemo(
    () => categoriesQuery.data?.categories.filter((category) => category.type === 'expense') ?? [],
    [categoriesQuery.data?.categories],
  );

  const budgetedCategoryIds = useMemo(
    () => new Set((budgetsQuery.data?.budgets ?? []).map((budget) => budget.categoryId)),
    [budgetsQuery.data?.budgets],
  );

  const selectedCategoryId = addForm.watch('categoryId');

  const availableCategories = useMemo(
    () =>
      expenseCategories.filter(
        (category) => !budgetedCategoryIds.has(category.id) || category.id === selectedCategoryId,
      ),
    [budgetedCategoryIds, expenseCategories, selectedCategoryId],
  );

  useEffect(() => {
    if (!composerOpen || selectedCategoryId || availableCategories.length === 0) {
      return;
    }

    addForm.setValue('categoryId', availableCategories[0].id, { shouldValidate: true });
  }, [addForm, availableCategories, composerOpen, selectedCategoryId]);

  async function invalidateMonthScopedData(targetMonth: string): Promise<void> {
    await Promise.all([
      queryClient.invalidateQueries({ queryKey: financeQueryKeys.budgets.month(targetMonth) }),
      queryClient.invalidateQueries({ queryKey: financeQueryKeys.analytics.month(targetMonth) }),
      queryClient.invalidateQueries({ queryKey: financeQueryKeys.dashboard.recent() }),
    ]);
  }

  const createBudgetMutation = useMutation({
    mutationFn: (values: BudgetFormValues) =>
      withAuth((token) =>
        apiClient.createBudget(
          {
            categoryId: values.categoryId,
            month,
            limitAmount: Number(values.limitAmount),
          },
          token,
        ),
      ),
    onSuccess: async () => {
      setComposerOpen(false);
      addForm.reset({ categoryId: '', limitAmount: '' });
      await invalidateMonthScopedData(month);
    },
    onError: (error) => {
      Alert.alert(t('errors.budget.createFailedTitle'), apiErrorText(error));
    },
  });

  const updateBudgetMutation = useMutation({
    mutationFn: (params: { id: string; values: EditBudgetFormValues }) =>
      withAuth((token) =>
        apiClient.updateBudget(
          params.id,
          {
            limitAmount: Number(params.values.limitAmount),
          },
          token,
        ),
      ),
    onSuccess: async () => {
      setEditingBudgetId(null);
      editForm.reset({ limitAmount: '' });
      await invalidateMonthScopedData(month);
    },
    onError: (error) => {
      Alert.alert(t('errors.budget.updateFailedTitle'), apiErrorText(error));
    },
  });

  const deleteBudgetMutation = useMutation({
    mutationFn: (budgetId: string) => withAuth((token) => apiClient.deleteBudget(budgetId, token)),
    onSuccess: async () => {
      await invalidateMonthScopedData(month);
    },
    onError: (error) => {
      Alert.alert(t('errors.budget.deleteFailedTitle'), apiErrorText(error));
    },
  });

  if (budgetsQuery.isLoading && !budgetsQuery.data) {
    return (
      <ScreenContainer scrollable={false} dark={mode === 'dark'} contentStyle={styles.containerContent}>
        <LoadingSkeleton dark={mode === 'dark'} />
      </ScreenContainer>
    );
  }

  if (budgetsQuery.isError && !budgetsQuery.data) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>{t('budgets.state.unavailableTitle')}</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(budgetsQuery.error)}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  const budgets = budgetsQuery.data?.budgets ?? [];
  const overview = budgets.reduce(
    (accumulator, budget) => {
      accumulator.limit += budget.limitAmount;
      accumulator.spent += budget.spentAmount;
      return accumulator;
    },
    { limit: 0, spent: 0 },
  );

  const remaining = overview.limit - overview.spent;
  const usedPercent = overview.limit > 0 ? (overview.spent / overview.limit) * 100 : 0;
  const normalizedUsedPercent = Math.max(0, Math.min(100, usedPercent));

  const dark = mode === 'dark';
  const panelBg = dark ? '#14122A' : '#FFFFFF';
  const panelBorder = dark ? '#2C2753' : '#E3E9F5';
  const sectionBg = dark ? '#101229' : '#F8FAFF';
  const inputBg = dark ? '#111427' : '#FFFFFF';

  return (
    <ScreenContainer scrollable={false} dark={dark} contentStyle={styles.containerContent}>
      <View style={styles.rootWrap}>
        <ScrollView
          contentContainerStyle={styles.scrollContent}
          keyboardDismissMode="on-drag"
          keyboardShouldPersistTaps="always"
        >
          <View style={styles.topBar}>
            <Text style={[styles.topIcon, { color: theme.colors.text }]}>{'‹'}</Text>
            <Text style={[styles.screenTitle, { color: theme.colors.text }]}>{t('budgets.title')}</Text>
            <Text style={[styles.topIcon, { color: theme.colors.text }]}>⋮</Text>
          </View>

          <View style={styles.monthRow}>
            <Pressable
              accessibilityRole="button"
              onPress={() => setMonth(shiftMonth(month, -1))}
              style={styles.monthArrow}
            >
              <Text style={[styles.monthArrowText, { color: theme.colors.text }]}>{'<'}</Text>
            </Pressable>

            <Text style={[styles.monthLabel, { color: theme.colors.textMuted }]}>{formatMonthLabel(month)}</Text>

            <Pressable
              accessibilityRole="button"
              onPress={() => setMonth(shiftMonth(month, 1))}
              style={styles.monthArrow}
            >
              <Text style={[styles.monthArrowText, { color: theme.colors.text }]}>{'>'}</Text>
            </Pressable>
          </View>

          <Card
            dark={dark}
            style={[
              styles.overviewCard,
              {
                backgroundColor: panelBg,
                borderColor: panelBorder,
              },
            ]}
          >
            <View style={styles.overviewHeader}>
              <Text style={[styles.overviewLabel, { color: theme.colors.textMuted }]}>{t('budgets.overview.totalMonthlyBudget')}</Text>
              <View style={[styles.overviewBadge, { backgroundColor: dark ? '#2F1CCF' : '#EEF0FF' }]}>
                <Text style={[styles.overviewBadgeText, { color: dark ? '#7F85FF' : '#4F46E5' }]}>{t('common.appInitials')}</Text>
              </View>
            </View>

            <Text style={[styles.overviewTotal, { color: theme.colors.text }]}>{formatMoney(overview.limit, currency, locale)}</Text>

            <View style={styles.overviewMetaRow}>
              <Text style={[styles.overviewMetaText, { color: theme.colors.textMuted }]}> 
                {t('budgets.overview.spentLabel', {
                  spent: formatMoney(overview.spent, currency, locale),
                  percent: usedPercent.toFixed(0),
                })}
              </Text>
              <Text style={[styles.overviewRemaining, { color: theme.colors.text }]}> 
                {t('budgets.overview.leftLabel', { remaining: formatMoney(Math.max(0, remaining), currency, locale) })}
              </Text>
            </View>

            <View style={[styles.overviewTrack, { backgroundColor: dark ? '#3B2F74' : '#DEE7FF' }]}> 
              <View
                style={[
                  styles.overviewFill,
                  {
                    width: `${normalizedUsedPercent}%`,
                    backgroundColor: usedPercent >= 100 ? '#FF4D57' : '#5B2BFF',
                  },
                ]}
              />
            </View>

            <View style={[styles.aiHint, { backgroundColor: dark ? '#1B1640' : '#EFF1FF' }]}> 
              <Text style={[styles.aiHintIcon, { color: theme.colors.primary }]}>✦</Text>
              <Text style={[styles.aiHintText, { color: theme.colors.textMuted }]}> 
                {t('budgets.overview.aiHintPrefix')}
                <Text style={[styles.aiHintStrong, { color: theme.colors.text }]}> {formatMoney(Math.max(0, remaining), currency, locale)}</Text>
                {' '}
                {t('budgets.overview.aiHintSuffix')}
              </Text>
            </View>
          </Card>

          {composerOpen ? (
            <Card
              dark={dark}
              style={[
                styles.composerCard,
                {
                  backgroundColor: panelBg,
                  borderColor: panelBorder,
                },
              ]}
            >
              <View style={styles.composerHeader}>
                <Text style={[styles.composerTitle, { color: theme.colors.text }]}>{t('budgets.composer.title')}</Text>
                <Pressable
                  accessibilityRole="button"
                  onPress={() => {
                    setComposerOpen(false);
                    addForm.reset({ categoryId: '', limitAmount: '' });
                  }}
                >
                  <Text style={[styles.composerClose, { color: theme.colors.textMuted }]}>{t('common.close')}</Text>
                </Pressable>
              </View>

              {availableCategories.length === 0 ? (
                <Text style={[styles.emptyText, { color: theme.colors.textMuted }]}>
                  {t('budgets.composer.noCategories')}
                </Text>
              ) : (
                <>
                  <Text style={[styles.fieldLabel, { color: theme.colors.textMuted }]}>{t('budgets.composer.category')}</Text>
                  <Controller
                    control={addForm.control}
                    name="categoryId"
                    render={({ field: { value, onChange } }) => (
                      <View style={styles.categoryChipWrap}>
                        {availableCategories.map((category) => {
                          const active = value === category.id;

                          return (
                            <Pressable
                              key={category.id}
                              accessibilityRole="button"
                              onPress={() => onChange(category.id)}
                              style={[
                                styles.categoryChip,
                                {
                                  backgroundColor: active
                                    ? '#5B2BFF'
                                    : dark
                                      ? 'rgba(255,255,255,0.06)'
                                      : '#EEF2FA',
                                },
                              ]}
                            >
                              <Text
                                style={[
                                  styles.categoryChipText,
                                  { color: active ? '#FFFFFF' : theme.colors.textMuted },
                                ]}
                              >
                                {category.name}
                              </Text>
                            </Pressable>
                          );
                        })}
                      </View>
                    )}
                  />

                  {addForm.formState.errors.categoryId ? (
                    <Text style={[styles.errorText, { color: theme.colors.expense }]}>
                      {t(addForm.formState.errors.categoryId.message ?? '')}
                    </Text>
                  ) : null}

                  <Text style={[styles.fieldLabel, { color: theme.colors.textMuted }]}>{t('budgets.composer.limitAmount')}</Text>
                  <Controller
                    control={addForm.control}
                    name="limitAmount"
                    render={({ field: { value, onChange, onBlur } }) => (
                      <TextInput
                        autoCapitalize="none"
                        keyboardType="decimal-pad"
                        onBlur={onBlur}
                        onChangeText={onChange}
                        placeholder={t('budgets.composer.amountPlaceholder')}
                        placeholderTextColor={theme.colors.textMuted}
                        style={[
                          styles.amountInput,
                          {
                            backgroundColor: inputBg,
                            borderColor: panelBorder,
                            color: theme.colors.text,
                          },
                        ]}
                        value={value}
                      />
                    )}
                  />

                  {addForm.formState.errors.limitAmount ? (
                    <Text style={[styles.errorText, { color: theme.colors.expense }]}>
                      {t(addForm.formState.errors.limitAmount.message ?? '')}
                    </Text>
                  ) : null}

                  <PrimaryButton
                    label={createBudgetMutation.isPending ? t('budgets.composer.creating') : t('budgets.composer.create')}
                    onPress={addForm.handleSubmit((values) => {
                      createBudgetMutation.mutate(values);
                    })}
                    disabled={createBudgetMutation.isPending}
                  />
                </>
              )}
            </Card>
          ) : null}

          <View style={styles.sectionHeadRow}>
            <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>{t('budgets.sections.spendingCategories')}</Text>
            <Text style={[styles.sectionLink, { color: '#5B2BFF' }]}>{t('budgets.sections.viewHistory')}</Text>
          </View>

          {budgets.length === 0 ? (
            <Card
              dark={dark}
              style={[
                styles.emptyCard,
                {
                  backgroundColor: panelBg,
                  borderColor: panelBorder,
                },
              ]}
            >
              <Text style={[styles.emptyText, { color: theme.colors.textMuted }]}>{t('budgets.state.empty')}</Text>
            </Card>
          ) : null}

          {budgets.map((budget, index) => {
            const percentUsed = budget.percentUsed;
            const normalizedPercent = Math.max(0, Math.min(100, percentUsed));
            const progress = getProgressTone(percentUsed);
            const iconBg = CATEGORY_ICON_BACKGROUNDS[index % CATEGORY_ICON_BACKGROUNDS.length];
            const overLimit = percentUsed >= 100;

            return (
              <Card
                key={budget.id}
                dark={dark}
                style={[
                  styles.budgetCard,
                  {
                    backgroundColor: panelBg,
                    borderColor: panelBorder,
                  },
                ]}
              >
                <View style={styles.budgetTopRow}>
                  <View style={styles.budgetMetaLeft}>
                    <View style={[styles.categoryIconWrap, { backgroundColor: iconBg }]}>
                      <Text style={styles.categoryIconEmoji}>{categoryGlyph(budget.categoryName)}</Text>
                    </View>

                    <View>
                      <Text style={[styles.budgetName, { color: theme.colors.text }]}>{budget.categoryName}</Text>
                      <Text style={[styles.budgetMetaText, { color: theme.colors.textMuted }]}> 
                        {t('budgets.row.spentOf', {
                          spent: formatMoney(budget.spentAmount, currency, locale),
                          limit: formatMoney(budget.limitAmount, currency, locale),
                        })}
                      </Text>
                    </View>
                  </View>

                  <Pressable
                    accessibilityRole="button"
                    onPress={() => {
                      setEditingBudgetId((current) => {
                        if (current === budget.id) {
                          editForm.reset({ limitAmount: '' });
                          return null;
                        }

                        editForm.reset({ limitAmount: budget.limitAmount.toString() });
                        return budget.id;
                      });
                    }}
                    style={styles.editButton}
                  >
                    <Text style={[styles.editButtonText, { color: theme.colors.textMuted }]}>✎</Text>
                  </Pressable>
                </View>

                <View style={[styles.progressTrack, { backgroundColor: dark ? '#40346A' : '#E3EAFC' }]}>
                  <View
                    style={[
                      styles.progressFill,
                      {
                        width: `${normalizedPercent}%`,
                        backgroundColor: progress.color,
                      },
                    ]}
                  />
                </View>

                <View style={styles.metaFooter}>
                  <View style={[styles.percentChip, { backgroundColor: progress.chipBackground }]}> 
                    <Text style={[styles.percentChipText, { color: progress.chipText }]}>{percentUsed.toFixed(0)}%</Text>
                  </View>
                  {overLimit ? (
                    <Text style={[styles.overTag, { color: '#FF7680' }]}>{t('budgets.row.over')}</Text>
                  ) : (
                    <Text style={[styles.remainingText, { color: theme.colors.textMuted }]}>
                      {t('budgets.row.left', { remaining: formatMoney(Math.max(0, budget.remainingAmount), currency, locale) })}
                    </Text>
                  )}
                </View>

                {editingBudgetId === budget.id ? (
                  <View style={styles.inlineEditorWrap}>
                    <Text style={[styles.fieldLabel, { color: theme.colors.textMuted }]}>{t('budgets.inline.updateLimit')}</Text>
                    <Controller
                      control={editForm.control}
                      name="limitAmount"
                      render={({ field: { value, onChange, onBlur } }) => (
                        <TextInput
                          autoCapitalize="none"
                          keyboardType="decimal-pad"
                          onBlur={onBlur}
                          onChangeText={onChange}
                          placeholder={t('budgets.composer.amountPlaceholder')}
                          placeholderTextColor={theme.colors.textMuted}
                          style={[
                            styles.amountInput,
                            {
                              backgroundColor: inputBg,
                              borderColor: panelBorder,
                              color: theme.colors.text,
                            },
                          ]}
                          value={value}
                        />
                      )}
                    />

                    {editForm.formState.errors.limitAmount ? (
                      <Text style={[styles.errorText, { color: theme.colors.expense }]}>
                        {t(editForm.formState.errors.limitAmount.message ?? '')}
                      </Text>
                    ) : null}

                    <PrimaryButton
                      label={updateBudgetMutation.isPending ? t('common.saving') : t('budgets.inline.saveLimit')}
                      onPress={editForm.handleSubmit((values) => {
                        updateBudgetMutation.mutate({ id: budget.id, values });
                      })}
                      disabled={updateBudgetMutation.isPending}
                    />

                    <View style={styles.inlineActions}>
                      <Pressable
                        accessibilityRole="button"
                        onPress={() => {
                          setEditingBudgetId(null);
                          editForm.reset({ limitAmount: '' });
                        }}
                      >
                        <Text style={[styles.inlineActionText, { color: theme.colors.textMuted }]}>{t('common.cancel')}</Text>
                      </Pressable>

                      <Pressable
                        accessibilityRole="button"
                        onPress={() => {
                          Alert.alert(
                            t('budgets.delete.title'),
                            t('budgets.delete.message', { category: budget.categoryName, month }),
                            [
                              { text: t('common.cancel'), style: 'cancel' },
                              {
                                text: t('common.delete'),
                                style: 'destructive',
                                onPress: () => {
                                  deleteBudgetMutation.mutate(budget.id);
                                },
                              },
                            ],
                          );
                        }}
                      >
                        <Text style={styles.deleteText}>{t('common.delete')}</Text>
                      </Pressable>
                    </View>
                  </View>
                ) : null}
              </Card>
            );
          })}

          {deleteBudgetMutation.isPending ? (
            <View style={styles.inlineLoadingRow}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text style={[styles.inlineLoadingText, { color: theme.colors.textMuted }]}>
                {t('budgets.state.updating')}
              </Text>
            </View>
          ) : null}
        </ScrollView>

        <Pressable
          accessibilityRole="button"
          onPress={() => setComposerOpen((current) => !current)}
          style={[
            styles.fab,
            {
              backgroundColor: '#5B2BFF',
              shadowColor: dark ? '#000000' : '#4F46E5',
            },
          ]}
        >
          <Text style={styles.fabLabel}>{composerOpen ? '−' : '+'}</Text>
        </Pressable>
      </View>
    </ScreenContainer>
  );
}

const CATEGORY_ICON_BACKGROUNDS = ['#523626', '#213B61', '#5A2A58', '#2D2D74', '#274B35'];

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    gap: 0,
    paddingBottom: 0,
    paddingHorizontal: 0,
    paddingTop: 0,
  },
  rootWrap: {
    flex: 1,
  },
  scrollContent: {
    gap: spacing.sm,
    paddingBottom: 110,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
  },
  topBar: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  topIcon: {
    ...typography.subheading,
    fontSize: 22,
    width: 32,
  },
  screenTitle: {
    ...typography.heading,
    fontSize: 24,
    textAlign: 'center',
  },
  monthRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'center',
  },
  monthArrow: {
    alignItems: 'center',
    height: 32,
    justifyContent: 'center',
    width: 32,
  },
  monthArrowText: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  monthLabel: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
    letterSpacing: 0.5,
    minWidth: 168,
    textAlign: 'center',
    textTransform: 'uppercase',
  },
  overviewCard: {
    gap: spacing.sm,
  },
  overviewHeader: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  overviewLabel: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
    letterSpacing: 1,
  },
  overviewBadge: {
    alignItems: 'center',
    borderRadius: radius.md,
    height: 34,
    justifyContent: 'center',
    width: 34,
  },
  overviewBadgeText: {
    ...typography.subheading,
    fontWeight: '800',
  },
  overviewTotal: {
    ...typography.amount,
    fontSize: 52,
    fontWeight: '800',
    lineHeight: 58,
  },
  overviewMetaRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  overviewMetaText: {
    ...typography.body,
    fontSize: 15,
  },
  overviewRemaining: {
    ...typography.subheading,
    fontSize: 32,
    fontWeight: '700',
  },
  overviewTrack: {
    borderRadius: radius.full,
    height: 10,
    overflow: 'hidden',
  },
  overviewFill: {
    borderRadius: radius.full,
    height: '100%',
  },
  aiHint: {
    alignItems: 'center',
    borderRadius: radius.md,
    flexDirection: 'row',
    gap: spacing.xs,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xs,
  },
  aiHintIcon: {
    ...typography.subheading,
    fontSize: 15,
  },
  aiHintText: {
    ...typography.caption,
    flex: 1,
    fontSize: 12,
    lineHeight: 18,
  },
  aiHintStrong: {
    fontWeight: '800',
  },
  composerCard: {
    gap: spacing.sm,
  },
  composerHeader: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  composerTitle: {
    ...typography.subheading,
    fontSize: 19,
    fontWeight: '700',
  },
  composerClose: {
    ...typography.caption,
    fontWeight: '700',
  },
  fieldLabel: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
  },
  categoryChipWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  categoryChip: {
    borderRadius: radius.full,
    minHeight: 30,
    justifyContent: 'center',
    paddingHorizontal: spacing.sm,
  },
  categoryChipText: {
    ...typography.caption,
    fontWeight: '700',
  },
  amountInput: {
    ...typography.body,
    borderRadius: radius.md,
    borderWidth: 1,
    height: 44,
    paddingHorizontal: spacing.sm,
  },
  sectionHeadRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: spacing.xs,
  },
  sectionTitle: {
    ...typography.heading,
    fontSize: 20,
  },
  sectionLink: {
    ...typography.subheading,
    fontWeight: '700',
  },
  emptyCard: {
    minHeight: 88,
    justifyContent: 'center',
  },
  emptyText: {
    ...typography.body,
  },
  budgetCard: {
    gap: spacing.sm,
  },
  budgetTopRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  budgetMetaLeft: {
    alignItems: 'center',
    flexDirection: 'row',
    flex: 1,
    gap: spacing.sm,
  },
  categoryIconWrap: {
    alignItems: 'center',
    borderRadius: radius.sm,
    height: 34,
    justifyContent: 'center',
    width: 34,
  },
  categoryIconEmoji: {
    fontSize: 16,
  },
  budgetName: {
    ...typography.subheading,
    fontSize: 16,
    fontWeight: '700',
  },
  budgetMetaText: {
    ...typography.body,
    fontSize: 14,
  },
  editButton: {
    alignItems: 'center',
    height: 28,
    justifyContent: 'center',
    width: 28,
  },
  editButtonText: {
    ...typography.subheading,
    fontSize: 16,
  },
  progressTrack: {
    borderRadius: radius.full,
    height: 6,
    overflow: 'hidden',
  },
  progressFill: {
    borderRadius: radius.full,
    height: '100%',
  },
  metaFooter: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  percentChip: {
    borderRadius: radius.full,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xxs,
  },
  percentChipText: {
    ...typography.caption,
    fontWeight: '700',
  },
  overTag: {
    ...typography.caption,
    fontWeight: '700',
    letterSpacing: 0.6,
  },
  remainingText: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '600',
  },
  inlineEditorWrap: {
    gap: spacing.sm,
  },
  inlineActions: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  inlineActionText: {
    ...typography.caption,
    fontWeight: '700',
  },
  deleteText: {
    ...typography.caption,
    color: '#FF4D57',
    fontWeight: '700',
  },
  inlineLoadingRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    marginTop: spacing.xs,
  },
  inlineLoadingText: {
    ...typography.caption,
  },
  fab: {
    alignItems: 'center',
    borderRadius: radius.full,
    bottom: 32,
    elevation: 9,
    height: 56,
    justifyContent: 'center',
    position: 'absolute',
    right: spacing.lg,
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.35,
    shadowRadius: 14,
    width: 56,
  },
  fabLabel: {
    ...typography.amount,
    color: '#FFFFFF',
    fontSize: 28,
    fontWeight: '600',
    lineHeight: 30,
  },
  errorTitle: {
    ...typography.subheading,
  },
  errorText: {
    ...typography.body,
  },
  skeletonWrap: {
    gap: spacing.sm,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
  },
  skeletonHeader: {
    borderRadius: radius.md,
    height: 42,
    width: '58%',
  },
  skeletonOverview: {
    borderRadius: radius.lg,
    height: 190,
    width: '100%',
  },
  skeletonRow: {
    borderRadius: radius.md,
    height: 86,
    width: '100%',
  },
});

===== FILE: apps/mobile/src/features/finance/screens/DashboardScreen.tsx =====
import { memo, useCallback, useMemo } from 'react';
import {
  FlatList,
  Pressable,
  RefreshControl,
  StyleSheet,
  Text,
  View,
} from 'react-native';

import type { DashboardRecentResponse } from '@mintly/shared';
import { useNavigation } from '@react-navigation/native';
import { useQuery } from '@tanstack/react-query';

import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { useAuth } from '@app/providers/AuthProvider';
import { useI18n } from '@shared/i18n';
import { Card, PrimaryButton, ScreenContainer } from '@shared/ui';
import type { AnalyticsStackParamList } from '@core/navigation/stacks/AnalyticsStack';
import type { RootTabParamList } from '@core/navigation/types';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import type { ThemeMode } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/ana_ekran_(dashboard)_1/screen.png
// no touch/keyboard behavior changed by this PR.

type DashboardTransaction = DashboardRecentResponse['recentTransactions'][number];

type TabTarget = 'AddTab' | 'TransactionsTab';

interface RecentTransactionRowProps {
  amount: string;
  mode: ThemeMode;
  subtitle: string;
  title: string;
  type: 'income' | 'expense';
  kind: 'normal' | 'transfer';
}

function formatCurrency(amount: number, currency: string, locale: string): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

function formatSignedAmount(
  amount: number,
  currency: string,
  type: 'income' | 'expense',
  locale: string,
): string {
  const value = formatCurrency(amount, currency, locale);
  return `${type === 'income' ? '+' : '-'}${value}`;
}

function formatOccurredAt(
  value: string,
  locale: string,
  t: (key: string, params?: Record<string, string | number>) => string,
): string {
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return value;
  }

  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const target = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  const diffDays = Math.round((today.getTime() - target.getTime()) / (1000 * 60 * 60 * 24));
  const time = date.toLocaleTimeString(locale, {
    hour: '2-digit',
    minute: '2-digit',
  });

  if (diffDays === 0) {
    return t('dashboard.time.today', { time });
  }

  if (diffDays === 1) {
    return t('dashboard.time.yesterday', { time });
  }

  const dayMonth = date.toLocaleDateString(locale, {
    day: 'numeric',
    month: 'short',
  });

  return t('dashboard.time.dayWithTime', { day: dayMonth, time });
}

function toInitials(value: string | null | undefined, fallback: string): string {
  if (!value) {
    return fallback;
  }

  const words = value
    .trim()
    .split(/\s+/)
    .filter(Boolean);

  if (words.length === 0) {
    return fallback;
  }

  if (words.length === 1) {
    return words[0].slice(0, 2).toUpperCase();
  }

  return `${words[0][0] ?? ''}${words[1][0] ?? ''}`.toUpperCase();
}

function deriveTrendText(
  incomeTotal: number,
  expenseTotal: number,
  t: (key: string, params?: Record<string, string | number>) => string,
): string {
  if (incomeTotal <= 0) {
    return t('dashboard.trend.stable');
  }

  const ratio = ((incomeTotal - expenseTotal) / incomeTotal) * 100;
  const absolute = Math.abs(ratio).toFixed(1);
  return ratio >= 0
    ? t('dashboard.trend.increase', { percent: absolute })
    : t('dashboard.trend.decrease', { percent: absolute });
}

function deriveInsight(incomeTotal: number, expenseTotal: number): {
  highlight: string;
  message: string;
  noHighlightText?: string;
} {
  if (incomeTotal <= 0) {
    return {
      highlight: '%0',
      message: 'dashboard.insight.noSavingsMessage',
      noHighlightText: 'dashboard.insight.noSavingsHighlight',
    };
  }

  const savingsPercent = Math.max(0, Math.round(((incomeTotal - expenseTotal) / incomeTotal) * 100));
  return {
    highlight: `%${savingsPercent}`,
    message: 'dashboard.insight.savingsMessage',
  };
}

function formatAccountType(
  accountType: string,
  t: (key: string, params?: Record<string, string | number>) => string,
): string {
  const key = `dashboard.accountTypes.${accountType.toLowerCase()}`;
  const translated = t(key);
  return translated === key ? accountType : translated;
}

const INCOME_BARS = [0.38, 0.58, 0.36, 0.88];
const EXPENSE_BARS = [0.7, 0.45, 0.8, 0.32];

function MiniStatCard({
  label,
  value,
  tone,
  mode,
}: {
  label: string;
  value: string;
  tone: 'income' | 'expense';
  mode: ThemeMode;
}) {
  const bars = tone === 'income' ? INCOME_BARS : EXPENSE_BARS;
  const valueColor = tone === 'income' ? '#16A965' : '#EA3F63';
  const mutedBarColor = tone === 'income' ? '#CDEFE0' : '#F9D9DE';
  const activeBarColor = tone === 'income' ? '#19B16E' : '#EF3F64';

  return (
    <View
      style={[
        styles.statCard,
        {
          backgroundColor: mode === 'dark' ? '#171A22' : '#FFFFFF',
          borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#EEF2F8',
        },
      ]}
    >
      <Text style={[styles.statLabel, { color: mode === 'dark' ? '#96A2B7' : '#6B7280' }]}>{label}</Text>
      <Text style={[styles.statValue, { color: valueColor }]}>{value}</Text>

      <View style={styles.statBars}>
        {bars.map((bar, index) => (
          <View
            key={`${tone}-bar-${index}`}
            style={[
              styles.statBar,
              {
                backgroundColor: index === bars.length - 1 ? activeBarColor : mutedBarColor,
                height: 42 * bar,
              },
            ]}
          />
        ))}
      </View>
    </View>
  );
}

function AccountCard({
  name,
  accountType,
  amount,
  mode,
}: {
  name: string;
  accountType: string;
  amount: string;
  mode: ThemeMode;
}) {
  return (
    <View
      style={[
        styles.accountCard,
        {
          backgroundColor: mode === 'dark' ? '#171A22' : '#FFFFFF',
          borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#EAF0FA',
        },
      ]}
    >
      <Text numberOfLines={1} style={[styles.accountName, { color: mode === 'dark' ? '#F3F7FF' : '#1D2433' }]}>
        {name}
      </Text>
      <Text style={[styles.accountMeta, { color: mode === 'dark' ? '#98A5BA' : '#74839C' }]}>{accountType}</Text>
      <Text numberOfLines={1} style={[styles.accountAmount, { color: mode === 'dark' ? '#AFC6FF' : '#2F6BFF' }]}>
        {amount}
      </Text>
    </View>
  );
}

const RecentTransactionRow = memo(function RecentTransactionRow({
  amount,
  mode,
  subtitle,
  title,
  type,
  kind,
}: RecentTransactionRowProps) {
  const palette = getTransactionPalette(type, kind, mode);

  return (
    <View
      style={[
        styles.transactionCard,
        {
          backgroundColor: mode === 'dark' ? '#161A22' : '#FFFFFF',
          borderColor: mode === 'dark' ? 'rgba(255,255,255,0.08)' : '#EDF2FA',
        },
      ]}
    >
      <View style={[styles.transactionIconWrap, { backgroundColor: palette.iconBg }]}> 
        <Text style={[styles.transactionIcon, { color: palette.iconText }]}>{palette.icon}</Text>
      </View>

      <View style={styles.transactionMeta}>
        <Text numberOfLines={1} style={[styles.transactionTitle, { color: mode === 'dark' ? '#F3F7FF' : '#1F293B' }]}>
          {title}
        </Text>
        <Text numberOfLines={1} style={[styles.transactionSubtitle, { color: mode === 'dark' ? '#90A0B7' : '#8A97AD' }]}>
          {subtitle}
        </Text>
      </View>

      <Text style={[styles.transactionAmount, { color: palette.amount }]}>{amount}</Text>
    </View>
  );
});

function getTransactionPalette(
  type: 'income' | 'expense',
  kind: 'normal' | 'transfer',
  mode: ThemeMode,
): {
  amount: string;
  icon: string;
  iconBg: string;
  iconText: string;
} {
  if (kind === 'transfer') {
    return {
      amount: type === 'income' ? '#16A965' : '#EA3F63',
      icon: '↔',
      iconBg: mode === 'dark' ? 'rgba(95,134,255,0.20)' : '#EAF0FF',
      iconText: '#2F6BFF',
    };
  }

  if (type === 'income') {
    return {
      amount: '#16A965',
      icon: '+',
      iconBg: mode === 'dark' ? 'rgba(22,169,101,0.22)' : '#E8F9F0',
      iconText: '#16A965',
    };
  }

  return {
    amount: '#EA3F63',
    icon: '-',
    iconBg: mode === 'dark' ? 'rgba(234,63,99,0.20)' : '#FEECEF',
    iconText: '#EA3F63',
  };
}

function DashboardSkeleton({ mode }: { mode: ThemeMode }) {
  const block = mode === 'dark' ? '#1A202A' : '#E6EDF8';

  return (
    <View style={styles.skeletonWrap}>
      <View style={[styles.skeletonHeader, { backgroundColor: block }]} />
      <View style={[styles.skeletonHero, { backgroundColor: block }]} />
      <View style={styles.skeletonRow}>
        <View style={[styles.skeletonStat, { backgroundColor: block }]} />
        <View style={[styles.skeletonStat, { backgroundColor: block }]} />
      </View>
      <View style={[styles.skeletonInsight, { backgroundColor: block }]} />
      <View style={styles.skeletonRow}>
        <View style={[styles.skeletonQuick, { backgroundColor: block }]} />
        <View style={[styles.skeletonQuick, { backgroundColor: block }]} />
        <View style={[styles.skeletonQuick, { backgroundColor: block }]} />
      </View>
      <View style={[styles.skeletonTx, { backgroundColor: block }]} />
      <View style={[styles.skeletonTx, { backgroundColor: block }]} />
      <View style={[styles.skeletonTx, { backgroundColor: block }]} />
    </View>
  );
}

export function DashboardScreen() {
  const navigation = useNavigation<any>();
  const { withAuth, user } = useAuth();
  const { theme, mode } = useTheme();
  const { locale, t } = useI18n();

  const dashboardQuery = useQuery({
    queryKey: financeQueryKeys.dashboard.recent(),
    queryFn: () => withAuth((token) => apiClient.getDashboardRecent(token)),
  });

  const currency = useMemo(() => {
    if (dashboardQuery.data?.balances[0]?.currency) {
      return dashboardQuery.data.balances[0].currency;
    }

    return user?.baseCurrency ?? 'TRY';
  }, [dashboardQuery.data?.balances, user?.baseCurrency]);

  const accountNameById = useMemo(() => {
    const map: Record<string, string> = {};
    for (const balance of dashboardQuery.data?.balances ?? []) {
      map[balance.accountId] = balance.name;
    }
    return map;
  }, [dashboardQuery.data?.balances]);

  const profileName = useMemo(() => {
    if (user?.name?.trim()) {
      return user.name.trim();
    }

    if (user?.email) {
      return user.email.split('@')[0];
    }

    return t('common.appName');
  }, [t, user?.email, user?.name]);

  const recentTotals = useMemo(() => {
    let incomeTotal = 0;
    let expenseTotal = 0;

    for (const transaction of dashboardQuery.data?.recentTransactions ?? []) {
      if (transaction.kind === 'transfer') {
        continue;
      }

      if (transaction.type === 'income') {
        incomeTotal += transaction.amount;
      } else {
        expenseTotal += transaction.amount;
      }
    }

    return { expenseTotal, incomeTotal };
  }, [dashboardQuery.data?.recentTransactions]);

  const trendLabel = useMemo(
    () => deriveTrendText(recentTotals.incomeTotal, recentTotals.expenseTotal, t),
    [recentTotals.expenseTotal, recentTotals.incomeTotal, t],
  );

  const insight = useMemo(
    () => deriveInsight(recentTotals.incomeTotal, recentTotals.expenseTotal),
    [recentTotals.expenseTotal, recentTotals.incomeTotal],
  );

  const goToAnalyticsScreen = useCallback(
    (screen: keyof AnalyticsStackParamList) => {
      const parent = navigation.getParent?.();
      const root = parent?.getParent?.();
      const target = (root ?? parent ?? navigation) as {
        navigate: (
          routeName: keyof RootTabParamList,
          params?: RootTabParamList['AnalyticsTab'],
        ) => void;
      };

      target.navigate('AnalyticsTab', { screen });
    },
    [navigation],
  );

  const goToTab = useCallback(
    (tabName: TabTarget) => {
      const parent = navigation.getParent?.();
      const root = parent?.getParent?.();
      const target = root ?? parent ?? navigation;
      target.navigate(tabName);
    },
    [navigation],
  );

  const renderTransaction = useCallback(
    ({ item }: { item: DashboardTransaction }) => {
      const accountName = accountNameById[item.accountId] ?? t('dashboard.accountFallback');
      const relatedName = item.relatedAccountId ? accountNameById[item.relatedAccountId] : null;

      let context = accountName;
      if (item.kind === 'transfer') {
        if (item.transferDirection === 'out' && relatedName) {
          context = `${accountName} -> ${relatedName}`;
        } else if (item.transferDirection === 'in' && relatedName) {
          context = `${relatedName} -> ${accountName}`;
        } else {
          context = t('dashboard.transaction.transferContext');
        }
      }

      const title =
        item.description?.trim() ||
        (item.kind === 'transfer'
          ? t('dashboard.transaction.transferTitle')
          : item.type === 'income'
            ? t('dashboard.transaction.incomeTitle')
            : t('dashboard.transaction.expenseTitle'));

      const subtitle = `${formatOccurredAt(item.occurredAt, locale, t)} • ${context}`;

      return (
        <RecentTransactionRow
          amount={formatSignedAmount(item.amount, item.currency, item.type, locale)}
          kind={item.kind}
          mode={mode}
          subtitle={subtitle}
          title={title}
          type={item.type}
        />
      );
    },
    [accountNameById, locale, mode, t],
  );

  if (dashboardQuery.isLoading) {
    return (
      <ScreenContainer scrollable={false} contentStyle={styles.containerContent}>
        <View style={styles.loadingStateWrap}>
          <DashboardSkeleton mode={mode} />
          <Text style={[styles.loadingStateText, { color: theme.colors.textMuted }]}>
            {t('dashboard.state.loading')}
          </Text>
        </View>
      </ScreenContainer>
    );
  }

  if (dashboardQuery.isError) {
    return (
      <ScreenContainer>
        <Card style={styles.errorCard}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>{t('dashboard.state.errorTitle')}</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(dashboardQuery.error)}</Text>
          <PrimaryButton label={t('common.retry')} onPress={() => void dashboardQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  const data = dashboardQuery.data;

  if (!data) {
    return (
      <ScreenContainer>
        <Card>
          <Text style={[styles.emptyText, { color: theme.colors.textMuted }]}>{t('dashboard.state.noData')}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  return (
    <ScreenContainer scrollable={false} contentStyle={styles.containerContent}>
      <FlatList
        contentContainerStyle={styles.listContent}
        data={data.recentTransactions}
        ItemSeparatorComponent={() => <View style={styles.transactionSeparator} />}
        keyExtractor={(item) => item.id}
        ListEmptyComponent={
          <Card>
            <Text style={[styles.emptyText, { color: theme.colors.textMuted }]}>{t('dashboard.state.noTransactions')}</Text>
          </Card>
        }
        ListHeaderComponent={
          <View style={styles.headerWrap}>
            <View style={styles.topRow}>
              <View style={styles.profileRow}>
                <View
                  style={[
                    styles.avatar,
                    {
                      backgroundColor: mode === 'dark' ? '#25363A' : '#DFECDD',
                      borderColor: mode === 'dark' ? '#36585C' : '#D2E2CF',
                    },
                  ]}
                >
                  <Text style={[styles.avatarText, { color: mode === 'dark' ? '#C3EFE2' : '#5A6A58' }]}>
                    {toInitials(profileName, t('common.appInitials'))}
                  </Text>
                </View>

                <View>
                  <Text style={[styles.greetingText, { color: theme.colors.textMuted }]}>{t('dashboard.greeting')}</Text>
                  <Text numberOfLines={1} style={[styles.profileName, { color: theme.colors.primary }]}>
                    {profileName}
                  </Text>
                </View>
              </View>

              <View
                style={[
                  styles.statusPill,
                  {
                    backgroundColor: mode === 'dark' ? 'rgba(47,107,255,0.20)' : '#F1F5FF',
                    borderColor: mode === 'dark' ? 'rgba(47,107,255,0.34)' : '#D8E4FF',
                  },
                ]}
              >
                <View style={styles.statusDot} />
                <Text numberOfLines={1} style={[styles.statusLabel, { color: theme.colors.primary }]}>
                  {t('dashboard.aiActive')}
                </Text>
              </View>
            </View>

            <View style={styles.balanceCard}>
              <Text style={styles.balanceLabel}>{t('dashboard.currentBalance')}</Text>
              <Text adjustsFontSizeToFit minimumFontScale={0.72} numberOfLines={1} style={styles.balanceAmount}>
                {formatCurrency(data.totalBalance, currency, locale)}
              </Text>

              <View style={styles.balanceTrendPill}>
                <Text style={styles.balanceTrendArrow}>↗</Text>
                <Text numberOfLines={2} style={styles.balanceTrendText}>
                  {trendLabel}
                </Text>
              </View>
            </View>

            <View style={styles.statRow}>
              <MiniStatCard
                label={t('dashboard.income')}
                mode={mode}
                tone="income"
                value={formatCurrency(recentTotals.incomeTotal, currency, locale)}
              />
              <MiniStatCard
                label={t('dashboard.expense')}
                mode={mode}
                tone="expense"
                value={formatCurrency(recentTotals.expenseTotal, currency, locale)}
              />
            </View>

            {data.balances.length > 0 ? (
              <View style={styles.sectionWrap}>
              <View style={styles.sectionHeaderRow}>
                  <Text
                    numberOfLines={2}
                    style={[styles.sectionTitle, { color: mode === 'dark' ? '#F3F7FF' : '#1B2437' }]}
                  >
                    {t('dashboard.accounts')}
                  </Text>
                </View>
                <View style={styles.accountsGrid}>
                  {data.balances.map((balance) => (
                    <AccountCard
                      key={balance.accountId}
                      accountType={formatAccountType(balance.type, t)}
                      amount={formatCurrency(balance.balance, balance.currency, locale)}
                      mode={mode}
                      name={balance.name}
                    />
                  ))}
                </View>
              </View>
            ) : (
              <Card>
                <Text style={[styles.emptyText, { color: theme.colors.textMuted }]}>{t('dashboard.state.noAccounts')}</Text>
              </Card>
            )}

            <View
              style={[
                styles.insightCard,
                {
                  backgroundColor: mode === 'dark' ? '#171A22' : '#F4F6FD',
                  borderColor: mode === 'dark' ? 'rgba(47,107,255,0.28)' : '#CDD9F2',
                },
              ]}
            >
              <View style={styles.insightIconBox}>
                <Text style={styles.insightIcon}>✦</Text>
              </View>

              <View style={styles.insightContent}>
                <Text style={[styles.insightTitle, { color: theme.colors.primary }]}>{t('dashboard.aiAnalysisTitle')}</Text>
                <Text style={[styles.insightText, { color: mode === 'dark' ? '#A8B3C7' : '#52607A' }]}>
                  {insight.noHighlightText ? (
                    <>
                      {t(insight.noHighlightText)} <Text style={styles.insightHighlight}>{insight.highlight}</Text> {t(insight.message)}
                    </>
                  ) : (
                    <>
                      {t('dashboard.insight.thisMonth')} <Text style={styles.insightHighlight}>{insight.highlight}</Text> {t(insight.message)}
                    </>
                  )}
                </Text>
                <Pressable
                  accessibilityRole="button"
                  onPress={() => goToAnalyticsScreen('AiAdvisor')}
                  style={({ pressed }) => [styles.insightAction, pressed && styles.insightActionPressed]}
                >
                  <Text style={styles.insightActionText}>{t('dashboard.aiAction')}</Text>
                </Pressable>
              </View>
            </View>

            <View style={styles.sectionWrap}>
              <Text style={[styles.sectionTitle, { color: mode === 'dark' ? '#F3F7FF' : '#1B2437' }]}>
                {t('dashboard.premiumSection')}
              </Text>
              <View style={styles.quickActionsRow}>
                <Pressable
                  accessibilityRole="button"
                  onPress={() => goToAnalyticsScreen('AiAdvisor')}
                  style={({ pressed }) => [
                    styles.quickTile,
                    {
                      backgroundColor: mode === 'dark' ? '#171A22' : '#FFFFFF',
                      borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#EEF2F8',
                    },
                    pressed && styles.quickTilePressed,
                  ]}
                >
                  <View style={[styles.quickIconWrap, { backgroundColor: mode === 'dark' ? '#293065' : '#EEF1FF' }]}>
                    <Text style={[styles.quickIcon, { color: '#5961E9' }]}>✦</Text>
                  </View>
                  <Text style={[styles.quickLabel, { color: mode === 'dark' ? '#C0CCDF' : '#4A556D' }]}>
                    {t('dashboard.aiAdvisor')}
                  </Text>
                </Pressable>

                <Pressable
                  accessibilityRole="button"
                  onPress={() => goToAnalyticsScreen('WeeklyReport')}
                  style={({ pressed }) => [
                    styles.quickTile,
                    {
                      backgroundColor: mode === 'dark' ? '#171A22' : '#FFFFFF',
                      borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#EEF2F8',
                    },
                    pressed && styles.quickTilePressed,
                  ]}
                >
                  <View style={[styles.quickIconWrap, { backgroundColor: mode === 'dark' ? '#1C4A36' : '#EAF9F0' }]}>
                    <Text style={[styles.quickIcon, { color: '#17B26A' }]}>◔</Text>
                  </View>
                  <Text numberOfLines={2} style={[styles.quickLabel, { color: mode === 'dark' ? '#C0CCDF' : '#4A556D' }]}>
                    {t('dashboard.weeklyReport')}
                  </Text>
                </Pressable>
              </View>
            </View>

            <View style={styles.sectionWrap}>
              <Text style={[styles.sectionTitle, { color: mode === 'dark' ? '#F3F7FF' : '#1B2437' }]}>{t('dashboard.quickActions')}</Text>
              <View style={styles.quickActionsRow}>
                <Pressable
                  accessibilityRole="button"
                  onPress={() => goToTab('TransactionsTab')}
                  style={({ pressed }) => [
                    styles.quickTile,
                    {
                      backgroundColor: mode === 'dark' ? '#171A22' : '#FFFFFF',
                      borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#EEF2F8',
                    },
                    pressed && styles.quickTilePressed,
                  ]}
                >
                  <View style={[styles.quickIconWrap, { backgroundColor: mode === 'dark' ? '#293065' : '#EEF1FF' }]}>
                    <Text style={[styles.quickIcon, { color: '#5961E9' }]}>▦</Text>
                  </View>
                  <Text numberOfLines={2} style={[styles.quickLabel, { color: mode === 'dark' ? '#C0CCDF' : '#4A556D' }]}>
                    {t('dashboard.scanReceipt')}
                  </Text>
                </Pressable>

                <Pressable
                  accessibilityRole="button"
                  onPress={() => goToTab('AddTab')}
                  style={({ pressed }) => [
                    styles.quickTile,
                    {
                      backgroundColor: mode === 'dark' ? '#171A22' : '#FFFFFF',
                      borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#EEF2F8',
                    },
                    pressed && styles.quickTilePressed,
                  ]}
                >
                  <View style={[styles.quickIconWrap, { backgroundColor: mode === 'dark' ? '#1C4A36' : '#EAF9F0' }]}>
                    <Text style={[styles.quickIcon, { color: '#17B26A' }]}>+</Text>
                  </View>
                  <Text numberOfLines={2} style={[styles.quickLabel, { color: mode === 'dark' ? '#C0CCDF' : '#4A556D' }]}>
                    {t('dashboard.addIncome')}
                  </Text>
                </Pressable>

                <Pressable
                  accessibilityRole="button"
                  onPress={() => goToTab('AddTab')}
                  style={({ pressed }) => [
                    styles.quickTile,
                    {
                      backgroundColor: mode === 'dark' ? '#171A22' : '#FFFFFF',
                      borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#EEF2F8',
                    },
                    pressed && styles.quickTilePressed,
                  ]}
                >
                  <View style={[styles.quickIconWrap, { backgroundColor: mode === 'dark' ? '#522635' : '#FEECEF' }]}>
                    <Text style={[styles.quickIcon, { color: '#F04438' }]}>-</Text>
                  </View>
                  <Text numberOfLines={2} style={[styles.quickLabel, { color: mode === 'dark' ? '#C0CCDF' : '#4A556D' }]}>
                    {t('dashboard.addExpense')}
                  </Text>
                </Pressable>
              </View>
            </View>

            <View style={styles.transactionsHeader}>
              <Text style={[styles.sectionTitle, { color: mode === 'dark' ? '#F3F7FF' : '#1B2437' }]}>{t('dashboard.recentTransactions')}</Text>
              <Pressable onPress={() => goToTab('TransactionsTab')}>
                <Text style={[styles.actionText, { color: theme.colors.primary }]}>{t('dashboard.viewAll')}</Text>
              </Pressable>
            </View>
          </View>
        }
        refreshControl={
          <RefreshControl
            onRefresh={() => {
              void dashboardQuery.refetch();
            }}
            refreshing={dashboardQuery.isRefetching}
            tintColor={theme.colors.primary}
          />
        }
        renderItem={renderTransaction}
        showsVerticalScrollIndicator={false}
      />
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    gap: 0,
    paddingBottom: 0,
    paddingHorizontal: 0,
    paddingTop: 0,
  },
  loadingStateWrap: {
    gap: spacing.sm,
  },
  loadingStateText: {
    ...typography.body,
    textAlign: 'center',
  },
  listContent: {
    paddingBottom: spacing.xl,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
  },
  headerWrap: {
    gap: spacing.md,
    marginBottom: spacing.sm,
  },
  topRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.sm,
    justifyContent: 'space-between',
  },
  profileRow: {
    alignItems: 'center',
    flex: 1,
    flexDirection: 'row',
    gap: spacing.xs,
    minWidth: 0,
  },
  avatar: {
    alignItems: 'center',
    borderRadius: radius.full,
    borderWidth: 1,
    height: 34,
    justifyContent: 'center',
    width: 34,
  },
  avatarText: {
    ...typography.caption,
    fontWeight: '700',
  },
  greetingText: {
    ...typography.caption,
    fontSize: 11,
  },
  profileName: {
    ...typography.subheading,
    fontSize: 17,
    lineHeight: 22,
    maxWidth: 180,
  },
  statusPill: {
    alignItems: 'center',
    alignSelf: 'flex-start',
    borderRadius: radius.full,
    borderWidth: 1,
    flexDirection: 'row',
    gap: spacing.xxs,
    paddingHorizontal: spacing.sm,
    paddingVertical: 6,
    maxWidth: 120,
  },
  statusDot: {
    backgroundColor: '#22C55E',
    borderRadius: radius.full,
    height: 7,
    width: 7,
  },
  statusLabel: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 0.3,
  },
  balanceCard: {
    backgroundColor: '#2F6BFF',
    borderRadius: radius.lg,
    minHeight: 124,
    overflow: 'hidden',
    paddingHorizontal: spacing.md,
    paddingVertical: spacing.md,
  },
  balanceLabel: {
    ...typography.body,
    color: '#DCE6FF',
    fontSize: 14,
    fontWeight: '500',
  },
  balanceAmount: {
    ...typography.amount,
    color: '#FFFFFF',
    fontSize: 43,
    fontWeight: '800',
    lineHeight: 52,
    marginTop: 2,
  },
  balanceTrendPill: {
    alignItems: 'center',
    alignSelf: 'flex-start',
    backgroundColor: 'rgba(255,255,255,0.14)',
    borderRadius: radius.sm,
    flexDirection: 'row',
    gap: spacing.xxs,
    marginTop: spacing.xs,
    maxWidth: '100%',
    paddingHorizontal: spacing.xs,
    paddingVertical: 5,
  },
  balanceTrendArrow: {
    ...typography.caption,
    color: '#E7EEFF',
    fontSize: 10,
    fontWeight: '700',
  },
  balanceTrendText: {
    ...typography.caption,
    color: '#E7EEFF',
    fontSize: 11,
    flexShrink: 1,
  },
  statRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  statCard: {
    borderRadius: radius.md,
    borderWidth: 1,
    flex: 1,
    minWidth: 130,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  statLabel: {
    ...typography.caption,
    fontSize: 12,
  },
  statValue: {
    ...typography.subheading,
    fontSize: 33,
    lineHeight: 38,
    marginTop: 2,
  },
  statBars: {
    alignItems: 'flex-end',
    flexDirection: 'row',
    gap: spacing.xxs,
    height: 44,
    marginTop: spacing.sm,
    paddingHorizontal: 2,
  },
  statBar: {
    borderRadius: radius.sm,
    flex: 1,
    minWidth: 12,
  },
  sectionWrap: {
    gap: spacing.sm,
  },
  sectionHeaderRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  sectionTitle: {
    ...typography.subheading,
    fontSize: 20,
    fontWeight: '700',
    flexShrink: 1,
  },
  accountsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.sm,
  },
  accountCard: {
    borderRadius: radius.md,
    borderWidth: 1,
    minWidth: 132,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
    width: '48%',
  },
  accountName: {
    ...typography.body,
    fontSize: 14,
    fontWeight: '700',
  },
  accountMeta: {
    ...typography.caption,
    fontSize: 11,
    marginTop: 2,
    textTransform: 'uppercase',
  },
  accountAmount: {
    ...typography.subheading,
    fontSize: 16,
    marginTop: spacing.xs,
  },
  insightCard: {
    borderRadius: radius.md,
    borderWidth: 1,
    flexDirection: 'row',
    gap: spacing.sm,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  insightIconBox: {
    alignItems: 'center',
    backgroundColor: '#2F6BFF',
    borderRadius: radius.sm,
    height: 42,
    justifyContent: 'center',
    width: 42,
  },
  insightIcon: {
    ...typography.subheading,
    color: '#FFFFFF',
    fontSize: 18,
  },
  insightContent: {
    flex: 1,
    gap: spacing.xxs,
  },
  insightTitle: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  insightText: {
    ...typography.body,
    fontSize: 16,
    lineHeight: 24,
  },
  insightHighlight: {
    color: '#18B86A',
    fontWeight: '700',
  },
  insightAction: {
    alignSelf: 'flex-start',
    backgroundColor: '#2F6BFF',
    borderRadius: radius.sm,
    marginTop: spacing.sm,
    minHeight: 36,
    justifyContent: 'center',
    paddingHorizontal: spacing.md,
  },
  insightActionPressed: {
    opacity: 0.86,
  },
  insightActionText: {
    ...typography.caption,
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: '700',
  },
  quickActionsRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  quickTile: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flex: 1,
    gap: spacing.xs,
    minHeight: 86,
    paddingHorizontal: spacing.xs,
    paddingVertical: spacing.sm,
  },
  quickTilePressed: {
    opacity: 0.86,
  },
  quickIconWrap: {
    alignItems: 'center',
    borderRadius: radius.full,
    height: 26,
    justifyContent: 'center',
    width: 26,
  },
  quickIcon: {
    ...typography.caption,
    fontSize: 14,
    fontWeight: '700',
  },
  quickLabel: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 0.15,
    textAlign: 'center',
  },
  transactionsHeader: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  actionText: {
    ...typography.caption,
    fontWeight: '700',
  },
  transactionSeparator: {
    height: spacing.sm,
  },
  transactionCard: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flexDirection: 'row',
    gap: spacing.sm,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  transactionIconWrap: {
    alignItems: 'center',
    borderRadius: radius.sm,
    height: 34,
    justifyContent: 'center',
    width: 34,
  },
  transactionIcon: {
    ...typography.caption,
    fontWeight: '800',
  },
  transactionMeta: {
    flex: 1,
    gap: 2,
  },
  transactionTitle: {
    ...typography.subheading,
    fontSize: 17,
    fontWeight: '700',
  },
  transactionSubtitle: {
    ...typography.caption,
    fontSize: 11,
  },
  transactionAmount: {
    ...typography.subheading,
    fontSize: 24,
    fontWeight: '700',
  },
  skeletonWrap: {
    gap: spacing.sm,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
  },
  skeletonHeader: {
    borderRadius: radius.md,
    height: 36,
    width: '70%',
  },
  skeletonHero: {
    borderRadius: radius.lg,
    height: 140,
    width: '100%',
  },
  skeletonRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  skeletonStat: {
    borderRadius: radius.md,
    flex: 1,
    height: 120,
  },
  skeletonInsight: {
    borderRadius: radius.md,
    height: 120,
    width: '100%',
  },
  skeletonQuick: {
    borderRadius: radius.md,
    flex: 1,
    height: 82,
  },
  skeletonTx: {
    borderRadius: radius.md,
    height: 72,
    width: '100%',
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
  },
  errorText: {
    ...typography.body,
  },
  emptyText: {
    ...typography.body,
    textAlign: 'center',
  },
});

===== FILE: apps/mobile/src/features/finance/screens/RecurringScreen.tsx =====
import { useMemo } from 'react';
import { Alert, Pressable, StyleSheet, Text, TextInput, View } from 'react-native';

import { zodResolver } from '@hookform/resolvers/zod';
import {
  recurringCreateInputSchema,
  type RecurringRule,
} from '@mintly/shared';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { Controller, useForm } from 'react-hook-form';
import { z } from 'zod';

import { useAuth } from '@app/providers/AuthProvider';
import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { Card, Chip, PrimaryButton, ScreenContainer, Section } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import { colors, radius, spacing, typography } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

const recurringFormSchema = z
  .object({
    kind: z.enum(['normal', 'transfer']),
    type: z.enum(['expense', 'income']),
    accountId: z.string().trim().optional(),
    categoryId: z.string().trim().optional(),
    fromAccountId: z.string().trim().optional(),
    toAccountId: z.string().trim().optional(),
    amount: z
      .string()
      .trim()
      .min(1, 'errors.validation.amountRequired')
      .refine((value) => {
        const parsed = Number(value);
        return Number.isFinite(parsed) && parsed > 0;
      }, 'errors.validation.amountPositive'),
    cadence: z.enum(['weekly', 'monthly']),
    dayOfWeek: z.string().trim().optional(),
    dayOfMonth: z.string().trim().optional(),
    startAt: z
      .string()
      .trim()
      .min(1, 'errors.validation.startDateTimeRequired')
      .refine((value) => !Number.isNaN(Date.parse(value)), 'errors.validation.invalidIsoDateTime'),
    description: z.string().trim().max(500).optional(),
  })
  .superRefine((value, ctx) => {
    if (value.kind === 'normal') {
      if (!value.accountId) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['accountId'],
          message: 'errors.validation.selectAccount',
        });
      }
      if (!value.categoryId) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['categoryId'],
          message: 'errors.validation.selectCategory',
        });
      }
    } else {
      if (!value.fromAccountId) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['fromAccountId'],
          message: 'errors.validation.selectSourceAccount',
        });
      }
      if (!value.toAccountId) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['toAccountId'],
          message: 'errors.validation.selectDestinationAccount',
        });
      }
      if (value.fromAccountId && value.toAccountId && value.fromAccountId === value.toAccountId) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['toAccountId'],
          message: 'errors.validation.sourceDestinationDifferent',
        });
      }
    }

    if (value.cadence === 'weekly') {
      const parsed = Number(value.dayOfWeek);
      if (!Number.isInteger(parsed) || parsed < 0 || parsed > 6) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['dayOfWeek'],
          message: 'errors.validation.dayOfWeekRange',
        });
      }
    }

    if (value.cadence === 'monthly') {
      const parsed = Number(value.dayOfMonth);
      if (!Number.isInteger(parsed) || parsed < 1 || parsed > 28) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['dayOfMonth'],
          message: 'errors.validation.dayOfMonthRange',
        });
      }
    }
  });

type RecurringFormValues = z.infer<typeof recurringFormSchema>;

function formatDateTime(value: string): string {
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return value;
  }

  return date.toLocaleString();
}

export function RecurringScreen() {
  const { withAuth } = useAuth();
  const { t } = useI18n();
  const queryClient = useQueryClient();

  const recurringQuery = useQuery({
    queryKey: financeQueryKeys.recurring.list({}),
    queryFn: () => withAuth((token) => apiClient.listRecurring({}, token)),
  });

  const accountsQuery = useQuery({
    queryKey: financeQueryKeys.accounts.list(),
    queryFn: () => withAuth((token) => apiClient.getAccounts(token)),
  });

  const categoriesQuery = useQuery({
    queryKey: financeQueryKeys.categories.list(),
    queryFn: () => withAuth((token) => apiClient.getCategories(token)),
  });

  const form = useForm<RecurringFormValues>({
    resolver: zodResolver(recurringFormSchema),
    defaultValues: {
      kind: 'normal',
      type: 'expense',
      accountId: '',
      categoryId: '',
      fromAccountId: '',
      toAccountId: '',
      amount: '',
      cadence: 'monthly',
      dayOfWeek: '1',
      dayOfMonth: '1',
      startAt: new Date().toISOString(),
      description: '',
    },
  });

  const kind = form.watch('kind');
  const type = form.watch('type');
  const cadence = form.watch('cadence');

  const categories = useMemo(
    () => categoriesQuery.data?.categories.filter((item) => item.type === type) ?? [],
    [categoriesQuery.data?.categories, type],
  );

  const accounts = accountsQuery.data?.accounts ?? [];

  const accountNameById = useMemo(
    () => new Map(accounts.map((account) => [account.id, account.name])),
    [accounts],
  );
  const categoryNameById = useMemo(
    () =>
      new Map((categoriesQuery.data?.categories ?? []).map((category) => [category.id, category.name])),
    [categoriesQuery.data?.categories],
  );

  async function refreshRecurringList(): Promise<void> {
    await queryClient.invalidateQueries({ queryKey: financeQueryKeys.recurring.all() });
  }

  const createRecurringMutation = useMutation({
    mutationFn: (values: RecurringFormValues) =>
      withAuth((token) => {
        const amount = Number(values.amount);
        const basePayload = {
          kind: values.kind,
          amount,
          description: values.description?.trim() || undefined,
          cadence: values.cadence,
          startAt: new Date(values.startAt).toISOString(),
          ...(values.cadence === 'weekly'
            ? { dayOfWeek: Number(values.dayOfWeek) }
            : { dayOfMonth: Number(values.dayOfMonth) }),
        } as const;

        if (values.kind === 'normal') {
          return apiClient.createRecurring(
            recurringCreateInputSchema.parse({
              ...basePayload,
              kind: 'normal',
              accountId: values.accountId ?? '',
              categoryId: values.categoryId ?? '',
              type: values.type,
            }),
            token,
          );
        }

        return apiClient.createRecurring(
          recurringCreateInputSchema.parse({
            ...basePayload,
            kind: 'transfer',
            fromAccountId: values.fromAccountId ?? '',
            toAccountId: values.toAccountId ?? '',
          }),
          token,
        );
      }),
    onSuccess: async () => {
      await refreshRecurringList();
      form.reset({
        kind: 'normal',
        type: 'expense',
        accountId: '',
        categoryId: '',
        fromAccountId: '',
        toAccountId: '',
        amount: '',
        cadence: 'monthly',
        dayOfWeek: '1',
        dayOfMonth: '1',
        startAt: new Date().toISOString(),
        description: '',
      });
      Alert.alert(t('recurring.successTitle'), t('recurring.successMessage'));
    },
    onError: (error) => {
      Alert.alert(t('errors.recurring.createFailedTitle'), apiErrorText(error));
    },
  });

  const togglePausedMutation = useMutation({
    mutationFn: (rule: RecurringRule) =>
      withAuth((token) =>
        apiClient.updateRecurring(
          rule.id,
          {
            isPaused: !rule.isPaused,
          },
          token,
        ),
      ),
    onSuccess: refreshRecurringList,
    onError: (error) => {
      Alert.alert(t('errors.recurring.updateFailedTitle'), apiErrorText(error));
    },
  });

  const deleteMutation = useMutation({
    mutationFn: (ruleId: string) => withAuth((token) => apiClient.deleteRecurring(ruleId, token)),
    onSuccess: refreshRecurringList,
    onError: (error) => {
      Alert.alert(t('errors.recurring.deleteFailedTitle'), apiErrorText(error));
    },
  });

  if (recurringQuery.isLoading || accountsQuery.isLoading || categoriesQuery.isLoading) {
    return (
      <ScreenContainer>
        <Card>
          <Text style={styles.helperText}>{t('recurring.state.loading')}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (recurringQuery.isError || accountsQuery.isError || categoriesQuery.isError) {
    const error = recurringQuery.error ?? accountsQuery.error ?? categoriesQuery.error;
    return (
      <ScreenContainer>
        <Card style={styles.errorCard}>
          <Text style={styles.errorText}>{apiErrorText(error)}</Text>
          <PrimaryButton
            label={t('common.retry')}
            onPress={() => {
              void recurringQuery.refetch();
              void accountsQuery.refetch();
              void categoriesQuery.refetch();
            }}
          />
        </Card>
      </ScreenContainer>
    );
  }

  const rules = recurringQuery.data?.rules ?? [];

  return (
    <ScreenContainer>
      <Section title={t('recurring.title')} subtitle={t('recurring.subtitle')}>
        <Card style={styles.formCard}>
          <Text style={styles.fieldLabel}>{t('recurring.fields.kind')}</Text>
          <Controller
            control={form.control}
            name="kind"
            render={({ field: { value, onChange } }) => (
              <View style={styles.chipWrap}>
                <Pressable onPress={() => onChange('normal')}>
                  <Chip label={t('recurring.kind.normal')} tone={value === 'normal' ? 'primary' : 'default'} />
                </Pressable>
                <Pressable onPress={() => onChange('transfer')}>
                  <Chip label={t('recurring.kind.transfer')} tone={value === 'transfer' ? 'primary' : 'default'} />
                </Pressable>
              </View>
            )}
          />

          {kind === 'normal' ? (
            <>
              <Text style={styles.fieldLabel}>{t('recurring.fields.type')}</Text>
              <Controller
                control={form.control}
                name="type"
                render={({ field: { value, onChange } }) => (
                  <View style={styles.chipWrap}>
                    <Pressable onPress={() => onChange('expense')}>
                      <Chip label={t('analytics.expense')} tone={value === 'expense' ? 'expense' : 'default'} />
                    </Pressable>
                    <Pressable onPress={() => onChange('income')}>
                      <Chip label={t('analytics.income')} tone={value === 'income' ? 'income' : 'default'} />
                    </Pressable>
                  </View>
                )}
              />

              <Text style={styles.fieldLabel}>{t('recurring.fields.account')}</Text>
              <Controller
                control={form.control}
                name="accountId"
                render={({ field: { value, onChange } }) => (
                  <View style={styles.chipWrap}>
                    {accounts.map((account) => (
                      <Pressable key={account.id} onPress={() => onChange(account.id)}>
                        <Chip label={account.name} tone={value === account.id ? 'primary' : 'default'} />
                      </Pressable>
                    ))}
                  </View>
                )}
              />
              {form.formState.errors.accountId ? (
                <Text style={styles.errorText}>{t(form.formState.errors.accountId.message ?? '')}</Text>
              ) : null}

              <Text style={styles.fieldLabel}>{t('recurring.fields.categoryWithType', { type: t(`recurring.type.${type}`) })}</Text>
              <Controller
                control={form.control}
                name="categoryId"
                render={({ field: { value, onChange } }) => (
                  <View style={styles.chipWrap}>
                    {categories.map((category) => (
                      <Pressable key={category.id} onPress={() => onChange(category.id)}>
                        <Chip
                          label={category.name}
                          tone={value === category.id ? 'primary' : 'default'}
                        />
                      </Pressable>
                    ))}
                  </View>
                )}
              />
              {form.formState.errors.categoryId ? (
                <Text style={styles.errorText}>{t(form.formState.errors.categoryId.message ?? '')}</Text>
              ) : null}
            </>
          ) : (
            <>
              <Text style={styles.fieldLabel}>{t('recurring.fields.fromAccount')}</Text>
              <Controller
                control={form.control}
                name="fromAccountId"
                render={({ field: { value, onChange } }) => (
                  <View style={styles.chipWrap}>
                    {accounts.map((account) => (
                      <Pressable key={`from-${account.id}`} onPress={() => onChange(account.id)}>
                        <Chip
                          label={account.name}
                          tone={value === account.id ? 'expense' : 'default'}
                        />
                      </Pressable>
                    ))}
                  </View>
                )}
              />
              {form.formState.errors.fromAccountId ? (
                <Text style={styles.errorText}>{t(form.formState.errors.fromAccountId.message ?? '')}</Text>
              ) : null}

              <Text style={styles.fieldLabel}>{t('recurring.fields.toAccount')}</Text>
              <Controller
                control={form.control}
                name="toAccountId"
                render={({ field: { value, onChange } }) => (
                  <View style={styles.chipWrap}>
                    {accounts.map((account) => (
                      <Pressable key={`to-${account.id}`} onPress={() => onChange(account.id)}>
                        <Chip
                          label={account.name}
                          tone={value === account.id ? 'income' : 'default'}
                        />
                      </Pressable>
                    ))}
                  </View>
                )}
              />
              {form.formState.errors.toAccountId ? (
                <Text style={styles.errorText}>{t(form.formState.errors.toAccountId.message ?? '')}</Text>
              ) : null}
            </>
          )}

          <Text style={styles.fieldLabel}>{t('recurring.fields.amount')}</Text>
          <Controller
            control={form.control}
            name="amount"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                keyboardType="decimal-pad"
                placeholder={t('recurring.fields.amountPlaceholder')}
                placeholderTextColor={colors.textMuted}
              />
            )}
          />
          {form.formState.errors.amount ? (
            <Text style={styles.errorText}>{t(form.formState.errors.amount.message ?? '')}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>{t('recurring.fields.cadence')}</Text>
          <Controller
            control={form.control}
            name="cadence"
            render={({ field: { value, onChange } }) => (
              <View style={styles.chipWrap}>
                <Pressable onPress={() => onChange('weekly')}>
                  <Chip label={t('recurring.cadence.weekly')} tone={value === 'weekly' ? 'primary' : 'default'} />
                </Pressable>
                <Pressable onPress={() => onChange('monthly')}>
                  <Chip label={t('recurring.cadence.monthly')} tone={value === 'monthly' ? 'primary' : 'default'} />
                </Pressable>
              </View>
            )}
          />

          {cadence === 'weekly' ? (
            <>
              <Text style={styles.fieldLabel}>{t('recurring.fields.dayOfWeek')}</Text>
              <Controller
                control={form.control}
                name="dayOfWeek"
                render={({ field: { value, onChange, onBlur } }) => (
                  <TextInput
                    style={styles.input}
                    value={value}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    keyboardType="number-pad"
                    placeholder={t('recurring.fields.dayPlaceholder')}
                    placeholderTextColor={colors.textMuted}
                  />
                )}
              />
              {form.formState.errors.dayOfWeek ? (
                <Text style={styles.errorText}>{t(form.formState.errors.dayOfWeek.message ?? '')}</Text>
              ) : null}
            </>
          ) : (
            <>
              <Text style={styles.fieldLabel}>{t('recurring.fields.dayOfMonth')}</Text>
              <Controller
                control={form.control}
                name="dayOfMonth"
                render={({ field: { value, onChange, onBlur } }) => (
                  <TextInput
                    style={styles.input}
                    value={value}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    keyboardType="number-pad"
                    placeholder={t('recurring.fields.dayPlaceholder')}
                    placeholderTextColor={colors.textMuted}
                  />
                )}
              />
              {form.formState.errors.dayOfMonth ? (
                <Text style={styles.errorText}>{t(form.formState.errors.dayOfMonth.message ?? '')}</Text>
              ) : null}
            </>
          )}

          <Text style={styles.fieldLabel}>{t('recurring.fields.startAt')}</Text>
          <Controller
            control={form.control}
            name="startAt"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                autoCapitalize="none"
                placeholder={t('recurring.fields.startAtPlaceholder')}
                placeholderTextColor={colors.textMuted}
              />
            )}
          />
          {form.formState.errors.startAt ? (
            <Text style={styles.errorText}>{t(form.formState.errors.startAt.message ?? '')}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>{t('recurring.fields.description')}</Text>
          <Controller
            control={form.control}
            name="description"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                placeholder={t('recurring.fields.descriptionPlaceholder')}
                placeholderTextColor={colors.textMuted}
              />
            )}
          />

          <PrimaryButton
            label={createRecurringMutation.isPending ? t('common.saving') : t('recurring.actions.create')}
            onPress={form.handleSubmit((values) => {
              createRecurringMutation.mutate(values);
            })}
          />
        </Card>
      </Section>

      <Section title={t('recurring.sections.existing')} subtitle={t('recurring.sections.totalRules', { count: rules.length })}>
        {rules.length === 0 ? (
          <Card>
            <Text style={styles.helperText}>{t('recurring.state.empty')}</Text>
          </Card>
        ) : null}

        {rules.map((rule) => (
          <Card key={rule.id} style={styles.ruleCard}>
            <View style={styles.ruleHeader}>
              <Text style={styles.ruleTitle}>
                {rule.kind === 'transfer' ? t('recurring.rule.transfer') : t('recurring.rule.normal')}
              </Text>
              <Chip
                label={rule.isPaused ? t('recurring.status.paused') : t('recurring.status.active')}
                tone={rule.isPaused ? 'default' : 'primary'}
              />
            </View>

            <Text style={styles.ruleText}>{t('recurring.rule.amount', { amount: String(rule.amount) })}</Text>
            <Text style={styles.ruleText}>{t('recurring.rule.cadence', { cadence: t(`recurring.cadence.${rule.cadence}`) })}</Text>
            <Text style={styles.ruleText}>{t('recurring.rule.nextRun', { date: formatDateTime(rule.nextRunAt) })}</Text>
            {rule.kind === 'normal' ? (
              <>
                <Text style={styles.ruleText}>{t('recurring.rule.type', { type: rule.type ? t(`recurring.type.${rule.type}`) : t('common.notAvailable') })}</Text>
                <Text style={styles.ruleText}>
                  {t('recurring.rule.account', {
                    account: rule.accountId ? accountNameById.get(rule.accountId) ?? rule.accountId : t('common.notAvailable'),
                  })}
                </Text>
                <Text style={styles.ruleText}>
                  {t('recurring.rule.category', {
                    category: rule.categoryId ? categoryNameById.get(rule.categoryId) ?? rule.categoryId : t('common.notAvailable'),
                  })}
                </Text>
              </>
            ) : (
              <>
                <Text style={styles.ruleText}>
                  {t('recurring.rule.from', {
                    account: rule.fromAccountId
                      ? accountNameById.get(rule.fromAccountId) ?? rule.fromAccountId
                      : t('common.notAvailable'),
                  })}
                </Text>
                <Text style={styles.ruleText}>
                  {t('recurring.rule.to', {
                    account: rule.toAccountId ? accountNameById.get(rule.toAccountId) ?? rule.toAccountId : t('common.notAvailable'),
                  })}
                </Text>
              </>
            )}

            {rule.description ? <Text style={styles.ruleText}>{t('recurring.rule.note', { note: rule.description })}</Text> : null}

            <View style={styles.actionRow}>
              <Pressable
                onPress={() => {
                  togglePausedMutation.mutate(rule);
                }}
              >
                <Text style={styles.linkText}>{rule.isPaused ? t('common.resume') : t('common.pause')}</Text>
              </Pressable>
              <Pressable
                onPress={() => {
                  Alert.alert(t('recurring.delete.title'), t('recurring.delete.message'), [
                    { text: t('common.cancel'), style: 'cancel' },
                    {
                      text: t('common.delete'),
                      style: 'destructive',
                      onPress: () => {
                        deleteMutation.mutate(rule.id);
                      },
                    },
                  ]);
                }}
              >
                <Text style={styles.deleteText}>{t('common.delete')}</Text>
              </Pressable>
            </View>
          </Card>
        ))}
      </Section>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  formCard: {
    gap: spacing.sm,
  },
  fieldLabel: {
    ...typography.caption,
    color: colors.textMuted,
  },
  chipWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  input: {
    height: 44,
    borderWidth: 1,
    borderColor: colors.border,
    borderRadius: radius.md,
    backgroundColor: colors.surface,
    paddingHorizontal: spacing.sm,
    color: colors.text,
    ...typography.body,
  },
  helperText: {
    ...typography.body,
    color: colors.textMuted,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorText: {
    ...typography.caption,
    color: colors.expense,
  },
  ruleCard: {
    gap: spacing.xs,
  },
  ruleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    gap: spacing.sm,
  },
  ruleTitle: {
    ...typography.subheading,
    color: colors.text,
  },
  ruleText: {
    ...typography.caption,
    color: colors.textMuted,
  },
  actionRow: {
    marginTop: spacing.xs,
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  linkText: {
    ...typography.caption,
    color: colors.primary,
    fontWeight: '600',
  },
  deleteText: {
    ...typography.caption,
    color: colors.expense,
    fontWeight: '600',
  },
});

===== FILE: apps/mobile/src/features/finance/screens/TransactionDetailScreen.tsx =====
import { useMemo } from 'react';
import {
  ActivityIndicator,
  Pressable,
  ScrollView,
  StyleSheet,
  Text,
  View,
} from 'react-native';

import { useQuery } from '@tanstack/react-query';
import type { NativeStackScreenProps } from '@react-navigation/native-stack';

import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { useAuth } from '@app/providers/AuthProvider';
import { Card, ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/i̇şlem_detayı_1/screen.png
// no touch/keyboard behavior changed by this PR.

type TransactionsStackParamList = {
  TransactionDetail: { transactionId: string };
};

type Props = NativeStackScreenProps<TransactionsStackParamList, 'TransactionDetail'>;

function formatCurrency(amount: number, currency: string, locale: string): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

function formatDateTime(value: string, locale: string): string {
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return value;
  }

  return date.toLocaleDateString(locale, {
    day: 'numeric',
    month: 'long',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
  });
}

export function TransactionDetailScreen({ navigation, route }: Props) {
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();
  const { t, locale } = useI18n();
  const { transactionId } = route.params;

  const transactionQuery = useQuery({
    queryKey: ['transactions', 'detail', transactionId],
    queryFn: () => withAuth((token) => apiClient.getTransaction(transactionId, token)),
  });

  const accountsQuery = useQuery({
    queryKey: financeQueryKeys.accounts.list(),
    queryFn: () => withAuth((token) => apiClient.getAccounts(token)),
  });

  const categoriesQuery = useQuery({
    queryKey: financeQueryKeys.categories.list(),
    queryFn: () => withAuth((token) => apiClient.getCategories(token)),
  });

  const accountNameById = useMemo(() => {
    const map: Record<string, string> = {};
    for (const account of accountsQuery.data?.accounts ?? []) {
      map[account.id] = account.name;
    }
    return map;
  }, [accountsQuery.data?.accounts]);

  const categoryById = useMemo(() => {
    const map: Record<string, { name: string; type: string }> = {};
    for (const category of categoriesQuery.data?.categories ?? []) {
      map[category.id] = {
        name: category.name,
        type: category.type,
      };
    }
    return map;
  }, [categoriesQuery.data?.categories]);

  if (transactionQuery.isLoading) {
    return (
      <ScreenContainer dark={mode === 'dark'} scrollable={false} contentStyle={styles.containerContent}>
        <View style={styles.centerState}>
          <ActivityIndicator color={theme.colors.primary} size="large" />
          <Text style={[styles.stateText, { color: theme.colors.textMuted }]}>
            {t('transactionDetail.state.loading')}
          </Text>
        </View>
      </ScreenContainer>
    );
  }

  if (transactionQuery.isError || !transactionQuery.data) {
    return (
      <ScreenContainer dark={mode === 'dark'} scrollable={false} contentStyle={styles.containerContent}>
        <View style={styles.centerState}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>
            {t('transactionDetail.state.loadErrorTitle')}
          </Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(transactionQuery.error)}</Text>
          <Pressable
            onPress={() => navigation.goBack()}
            style={[styles.backAction, { backgroundColor: theme.colors.buttonPrimaryBackground }]}
          >
            <Text style={[styles.backActionLabel, { color: theme.colors.buttonPrimaryText }]}>
              {t('common.goBack')}
            </Text>
          </Pressable>
        </View>
      </ScreenContainer>
    );
  }

  const transaction = transactionQuery.data;
  const amountText = `${transaction.type === 'income' ? '+' : '-'}${formatCurrency(transaction.amount, transaction.currency, locale)}`;
  const title =
    transaction.description?.trim() ||
    (transaction.type === 'income' ? t('transactions.row.incomeTitle') : t('transactions.row.expenseTitle'));
  const category = transaction.categoryId ? categoryById[transaction.categoryId] : undefined;
  const accountName = accountNameById[transaction.accountId] ?? t('transactions.accountFallback');

  return (
    <ScreenContainer dark={mode === 'dark'} scrollable={false} contentStyle={styles.containerContent}>
      <View style={styles.safe}>
        <View style={[styles.header, { borderBottomColor: theme.colors.border }]}>
          <Pressable onPress={() => navigation.goBack()} style={styles.headerIconButton}>
            <Text style={[styles.headerIcon, { color: theme.colors.text }]}>{'<'}</Text>
          </Pressable>

          <Text style={[styles.headerTitle, { color: theme.colors.text }]}>{t('transactionDetail.title')}</Text>

          <Pressable onPress={() => undefined} style={styles.headerEditButton}>
            <Text style={[styles.headerEditText, { color: theme.colors.primary }]}>{t('common.edit')}</Text>
          </Pressable>
        </View>

        <ScrollView contentContainerStyle={styles.scrollContent} showsVerticalScrollIndicator={false}>
          <View style={styles.heroWrap}>
            <Text style={[styles.heroAmount, { color: transaction.type === 'income' ? theme.colors.income : theme.colors.expense }]}>
              {amountText}
            </Text>
            <Text style={[styles.heroTitle, { color: theme.colors.text }]}>{title}</Text>

            <View
              style={[
                styles.statusPill,
                {
                  backgroundColor: mode === 'dark' ? 'rgba(23,178,106,0.18)' : theme.colors.primaryMuted,
                },
              ]}
            >
              <View style={[styles.statusDot, { backgroundColor: theme.colors.income }]} />
              <Text style={[styles.statusLabel, { color: theme.colors.income }]}>
                {t('transactionDetail.status.completed')}
              </Text>
            </View>
          </View>

          <Card dark={mode === 'dark'} style={styles.metaCard}>
            <View style={styles.metaRow}>
              <View style={styles.metaLabelWrap}>
                <View style={[styles.metaIconBox, { backgroundColor: theme.colors.primaryMuted }]}>
                  <Text style={[styles.metaIcon, { color: theme.colors.primary }]}>▣</Text>
                </View>
                <Text style={[styles.metaLabel, { color: theme.colors.textMuted }]}>
                  {t('transactionDetail.fields.dateTime')}
                </Text>
              </View>
              <Text style={[styles.metaValue, { color: theme.colors.text }]}>
                {formatDateTime(transaction.occurredAt, locale)}
              </Text>
            </View>

            <View style={styles.metaRow}>
              <View style={styles.metaLabelWrap}>
                <View style={[styles.metaIconBox, { backgroundColor: theme.colors.primaryMuted }]}>
                  <Text style={[styles.metaIcon, { color: theme.colors.primary }]}>◉</Text>
                </View>
                <Text style={[styles.metaLabel, { color: theme.colors.textMuted }]}>
                  {t('transactionDetail.fields.category')}
                </Text>
              </View>
              <Text style={[styles.metaValue, { color: theme.colors.text }]}>
                {category?.name ?? t('transactionDetail.fields.noCategory')}
              </Text>
            </View>

            <View style={styles.metaRow}>
              <View style={styles.metaLabelWrap}>
                <View style={[styles.metaIconBox, { backgroundColor: theme.colors.primaryMuted }]}>
                  <Text style={[styles.metaIcon, { color: theme.colors.primary }]}>⌁</Text>
                </View>
                <Text style={[styles.metaLabel, { color: theme.colors.textMuted }]}>
                  {t('transactionDetail.fields.account')}
                </Text>
              </View>
              <Text style={[styles.metaValue, { color: theme.colors.text }]}>{accountName}</Text>
            </View>
          </Card>

          <Card dark={mode === 'dark'} style={styles.locationCard}>
            <View style={styles.locationHeader}>
              <View>
                <Text style={[styles.locationTitle, { color: theme.colors.text }]}>{accountName}</Text>
                <Text style={[styles.locationSubtitle, { color: theme.colors.textMuted }]}>
                  {t('transactionDetail.location.placeholder')}
                </Text>
              </View>
              <Text style={[styles.locationArrow, { color: theme.colors.textMuted }]}>{'>'}</Text>
            </View>

            <View
              style={[
                styles.mapPlaceholder,
                {
                  backgroundColor: mode === 'dark' ? theme.colors.surface : theme.colors.primaryMuted,
                },
              ]}
            >
              <View style={[styles.mapPin, { borderBottomColor: theme.colors.primary }]} />
            </View>
          </Card>

          <Card dark={mode === 'dark'} style={styles.notesCard}>
            <Text style={[styles.sectionLabel, { color: theme.colors.textMuted }]}>
              {t('transactionDetail.notes.title')}
            </Text>
            <Text style={[styles.notesText, { color: theme.colors.text }]}>
              "
              {transaction.description?.trim() || t('transactionDetail.notes.empty')}
              "
            </Text>
          </Card>

          <Card dark={mode === 'dark'} style={styles.receiptCard}>
            <View style={styles.receiptHeader}>
              <Text style={[styles.sectionLabel, { color: theme.colors.textMuted }]}>
                {t('transactionDetail.receipt.title')}
              </Text>
              <Pressable onPress={() => undefined}>
                <Text style={[styles.receiptAction, { color: theme.colors.primary }]}>{t('common.view')}</Text>
              </Pressable>
            </View>

            <View
              style={[
                styles.receiptPlaceholder,
                {
                  backgroundColor: mode === 'dark' ? theme.colors.surface : theme.colors.primaryMuted,
                  borderColor: theme.colors.border,
                },
              ]}
            >
              <View style={[styles.receiptPaper, { backgroundColor: theme.colors.surface }]}>
                <View style={[styles.receiptLine, { backgroundColor: theme.colors.border }]} />
                <View style={[styles.receiptLine, { backgroundColor: theme.colors.border }]} />
                <View style={[styles.receiptLine, { backgroundColor: theme.colors.border }]} />
                <View style={[styles.receiptLineShort, { backgroundColor: theme.colors.border }]} />
              </View>
            </View>
          </Card>
        </ScrollView>

        <View
          style={[
            styles.bottomActions,
            {
              backgroundColor: mode === 'dark' ? 'rgba(6,7,11,0.97)' : 'rgba(243,246,252,0.97)',
              borderTopColor: theme.colors.border,
            },
          ]}
        >
          <View style={styles.bottomButtonsRow}>
            <Pressable
              onPress={() => undefined}
              style={[
                styles.secondaryBottomButton,
                {
                  backgroundColor: theme.colors.surface,
                  borderColor: theme.colors.border,
                },
              ]}
            >
              <Text style={[styles.secondaryBottomLabel, { color: theme.colors.text }]}>
                {t('transactionDetail.actions.splitExpense')}
              </Text>
            </Pressable>

            <Pressable
              onPress={() => undefined}
              style={[styles.primaryBottomButton, { backgroundColor: theme.colors.primary }]}
            >
              <Text style={[styles.primaryBottomLabel, { color: theme.colors.buttonPrimaryText }]}>
                {t('transactionDetail.actions.downloadReceipt')}
              </Text>
            </Pressable>
          </View>

          <Pressable onPress={() => undefined} style={styles.deleteAction}>
            <Text style={[styles.deleteActionLabel, { color: theme.colors.expense }]}>
              {t('transactionDetail.actions.delete')}
            </Text>
          </Pressable>
        </View>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    gap: 0,
    paddingBottom: 0,
    paddingHorizontal: 0,
    paddingTop: 0,
  },
  safe: {
    flex: 1,
  },
  header: {
    alignItems: 'center',
    borderBottomWidth: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: spacing.md,
    paddingVertical: spacing.sm,
  },
  headerIconButton: {
    alignItems: 'center',
    height: 36,
    justifyContent: 'center',
    width: 36,
  },
  headerIcon: {
    ...typography.subheading,
    fontSize: 20,
    fontWeight: '700',
  },
  headerTitle: {
    ...typography.subheading,
    fontSize: 20,
    fontWeight: '700',
  },
  headerEditButton: {
    alignItems: 'center',
    borderRadius: radius.sm,
    justifyContent: 'center',
    minWidth: 58,
    paddingVertical: spacing.xxs,
  },
  headerEditText: {
    ...typography.caption,
    fontWeight: '700',
  },
  scrollContent: {
    gap: spacing.sm,
    paddingBottom: 170,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.md,
  },
  heroWrap: {
    alignItems: 'center',
    gap: spacing.xs,
    paddingVertical: spacing.md,
  },
  heroAmount: {
    ...typography.amount,
    fontSize: 54,
    fontWeight: '800',
    lineHeight: 60,
  },
  heroTitle: {
    ...typography.heading,
    fontSize: 31,
    lineHeight: 37,
  },
  statusPill: {
    alignItems: 'center',
    borderRadius: radius.full,
    flexDirection: 'row',
    gap: spacing.xxs,
    paddingHorizontal: spacing.sm,
    paddingVertical: 4,
  },
  statusDot: {
    borderRadius: radius.full,
    height: 6,
    width: 6,
  },
  statusLabel: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
  },
  metaCard: {
    gap: spacing.sm,
  },
  metaRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  metaLabelWrap: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  metaIconBox: {
    alignItems: 'center',
    borderRadius: radius.sm,
    height: 32,
    justifyContent: 'center',
    width: 32,
  },
  metaIcon: {
    ...typography.caption,
    fontWeight: '700',
    fontSize: 12,
  },
  metaLabel: {
    ...typography.caption,
    fontSize: 13,
    fontWeight: '600',
  },
  metaValue: {
    ...typography.body,
    fontWeight: '600',
  },
  locationCard: {
    overflow: 'hidden',
    padding: 0,
  },
  locationHeader: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  locationTitle: {
    ...typography.body,
    fontWeight: '700',
  },
  locationSubtitle: {
    ...typography.caption,
    fontSize: 11,
  },
  locationArrow: {
    ...typography.subheading,
    fontSize: 18,
  },
  mapPlaceholder: {
    height: 126,
    overflow: 'hidden',
    width: '100%',
  },
  mapPin: {
    alignSelf: 'center',
    borderBottomWidth: 18,
    borderLeftColor: 'transparent',
    borderLeftWidth: 11,
    borderRightColor: 'transparent',
    borderRightWidth: 11,
    borderTopWidth: 0,
    marginTop: 10,
    width: 0,
  },
  notesCard: {
    gap: spacing.xs,
  },
  sectionLabel: {
    ...typography.caption,
    fontSize: 13,
    fontWeight: '700',
  },
  notesText: {
    ...typography.body,
    fontStyle: 'italic',
    lineHeight: 21,
  },
  receiptCard: {
    gap: spacing.sm,
  },
  receiptHeader: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  receiptAction: {
    ...typography.caption,
    fontWeight: '700',
  },
  receiptPlaceholder: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderStyle: 'dashed',
    borderWidth: 1,
    height: 240,
    justifyContent: 'center',
    overflow: 'hidden',
    width: '100%',
  },
  receiptPaper: {
    borderRadius: radius.sm,
    elevation: 4,
    gap: spacing.xs,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
    shadowColor: 'rgba(0,0,0,0.35)',
    shadowOpacity: 0.15,
    shadowOffset: { width: 0, height: 4 },
    shadowRadius: 8,
    width: 110,
  },
  receiptLine: {
    borderRadius: radius.sm,
    height: 4,
    width: '100%',
  },
  receiptLineShort: {
    borderRadius: radius.sm,
    height: 4,
    width: '60%',
  },
  bottomActions: {
    borderTopWidth: 1,
    bottom: 0,
    left: 0,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
    position: 'absolute',
    right: 0,
  },
  bottomButtonsRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  secondaryBottomButton: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flex: 1,
    justifyContent: 'center',
    minHeight: 46,
    paddingHorizontal: spacing.sm,
  },
  secondaryBottomLabel: {
    ...typography.caption,
    fontSize: 13,
    fontWeight: '700',
  },
  primaryBottomButton: {
    alignItems: 'center',
    borderRadius: radius.md,
    flex: 1,
    justifyContent: 'center',
    minHeight: 46,
    paddingHorizontal: spacing.sm,
  },
  primaryBottomLabel: {
    ...typography.caption,
    fontSize: 13,
    fontWeight: '700',
  },
  deleteAction: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: spacing.sm,
  },
  deleteActionLabel: {
    ...typography.caption,
    fontSize: 13,
    fontWeight: '700',
  },
  centerState: {
    alignItems: 'center',
    flex: 1,
    gap: spacing.sm,
    justifyContent: 'center',
    paddingHorizontal: spacing.lg,
  },
  stateText: {
    ...typography.body,
  },
  errorTitle: {
    ...typography.subheading,
    textAlign: 'center',
  },
  errorText: {
    ...typography.body,
    textAlign: 'center',
  },
  backAction: {
    alignItems: 'center',
    borderRadius: radius.md,
    justifyContent: 'center',
    minHeight: 44,
    minWidth: 120,
    paddingHorizontal: spacing.md,
  },
  backActionLabel: {
    ...typography.subheading,
    fontWeight: '700',
  },
});

===== FILE: apps/mobile/src/features/finance/screens/TransactionsScreen.tsx =====
import { useCallback, useMemo, useState } from 'react';
import {
  ActivityIndicator,
  FlatList,
  Pressable,
  RefreshControl,
  StyleSheet,
  Text,
  TextInput,
  View,
} from 'react-native';

import type { Transaction } from '@mintly/shared';
import { useInfiniteQuery } from '@tanstack/react-query';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useNavigation } from '@react-navigation/native';

import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { useAuth } from '@app/providers/AuthProvider';
import { Card, PrimaryButton, ScreenContainer, TransactionRow } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { TransactionsStackParamList } from '@core/navigation/stacks/TransactionsStack';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/güncel_i̇şlem_geçmişi_(borç_kapama_dahil)/screen.png
// no touch/keyboard behavior changed by this PR.

type TypeFilter = 'all' | 'income' | 'expense';

type ListItem =
  | { id: string; kind: 'header'; title: string }
  | { id: string; kind: 'transaction'; transaction: Transaction };

function formatCurrency(amount: number, currency: string, locale: string): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

function formatSignedAmount(
  amount: number,
  currency: string,
  type: 'income' | 'expense',
  locale: string,
): string {
  const value = formatCurrency(amount, currency, locale);
  return `${type === 'income' ? '+' : '-'}${value}`;
}

function formatTime(dateIso: string, locale: string): string {
  const date = new Date(dateIso);
  if (Number.isNaN(date.getTime())) {
    return '--:--';
  }

  return date.toLocaleTimeString(locale, {
    hour: '2-digit',
    minute: '2-digit',
  });
}

function getDayKey(dateIso: string): string {
  const date = new Date(dateIso);
  if (Number.isNaN(date.getTime())) {
    return 'unknown';
  }

  const year = date.getFullYear();
  const month = `${date.getMonth() + 1}`.padStart(2, '0');
  const day = `${date.getDate()}`.padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function getDayLabel(dayKey: string, t: (key: string) => string, locale: string): string {
  if (dayKey === 'unknown') {
    return t('transactions.group.other');
  }

  const [year, month, day] = dayKey.split('-').map(Number);
  const target = new Date(year, (month ?? 1) - 1, day ?? 1);
  if (Number.isNaN(target.getTime())) {
    return t('transactions.group.other');
  }

  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const diffDays = Math.round((today.getTime() - target.getTime()) / (1000 * 60 * 60 * 24));

  if (diffDays === 0) {
    return t('transactions.group.today');
  }

  if (diffDays === 1) {
    return t('transactions.group.yesterday');
  }

  return target
    .toLocaleDateString(locale, {
      day: 'numeric',
      month: 'long',
    })
    .toLocaleUpperCase(locale);
}

function buildListItems(transactions: Transaction[], t: (key: string) => string, locale: string): ListItem[] {
  const groups = new Map<string, Transaction[]>();

  for (const transaction of transactions) {
    const dayKey = getDayKey(transaction.occurredAt);
    const existing = groups.get(dayKey) ?? [];
    existing.push(transaction);
    groups.set(dayKey, existing);
  }

  const sortedDayKeys = [...groups.keys()].sort((a, b) => {
    if (a === 'unknown') {
      return 1;
    }
    if (b === 'unknown') {
      return -1;
    }
    return a < b ? 1 : -1;
  });

  const items: ListItem[] = [];

  for (const dayKey of sortedDayKeys) {
    items.push({
      id: `header-${dayKey}`,
      kind: 'header',
      title: getDayLabel(dayKey, t, locale),
    });

    const groupTransactions = groups.get(dayKey) ?? [];
    for (const transaction of groupTransactions) {
      items.push({
        id: `tx-${transaction.id}`,
        kind: 'transaction',
        transaction,
      });
    }
  }

  return items;
}

function getTransactionTitle(transaction: Transaction, t: (key: string) => string): string {
  if (transaction.description?.trim()) {
    return transaction.description.trim();
  }

  if (transaction.kind === 'transfer') {
    return t('transactions.row.transferTitle');
  }

  return transaction.type === 'income' ? t('transactions.row.incomeTitle') : t('transactions.row.expenseTitle');
}

function getCategoryHint(
  transaction: Transaction,
  t: (key: string, params?: Record<string, string | number>) => string,
  locale: string,
): string {
  if (transaction.kind === 'transfer') {
    return t('transactions.row.transferHint', { time: formatTime(transaction.occurredAt, locale) });
  }

  return t('transactions.row.typeHint', {
    type: transaction.type === 'income' ? t('analytics.income') : t('analytics.expense'),
    time: formatTime(transaction.occurredAt, locale),
  });
}

function getCategoryIcon(transaction: Transaction, t: (key: string) => string): string {
  const title = getTransactionTitle(transaction, t);
  const firstLetter = title.charAt(0).toUpperCase();

  if (!firstLetter) {
    return transaction.type === 'income' ? '+' : '-';
  }

  if (transaction.kind === 'transfer') {
    return '↔';
  }

  return firstLetter;
}

function LoadingSkeleton() {
  return (
    <View style={styles.skeletonWrap}>
      <View style={styles.skeletonHeader} />
      <View style={styles.skeletonSearch} />
      <View style={styles.skeletonChips}>
        <View style={styles.skeletonChip} />
        <View style={styles.skeletonChip} />
        <View style={styles.skeletonChip} />
      </View>
      <View style={styles.skeletonSummaryRow}>
        <View style={styles.skeletonSummary} />
        <View style={styles.skeletonSummary} />
      </View>
      <View style={styles.skeletonItem} />
      <View style={styles.skeletonItem} />
      <View style={styles.skeletonItem} />
    </View>
  );
}

export function TransactionsScreen() {
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();
  const { t, locale } = useI18n();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();

  const [draftSearch, setDraftSearch] = useState('');
  const [activeSearch, setActiveSearch] = useState('');
  const [typeFilter, setTypeFilter] = useState<TypeFilter>('all');

  const queryFilters = useMemo(
    () => ({
      search: activeSearch.trim() || undefined,
      type: typeFilter === 'all' ? undefined : typeFilter,
    }),
    [activeSearch, typeFilter],
  );

  const transactionsQuery = useInfiniteQuery({
    queryKey: financeQueryKeys.transactions.list(queryFilters),
    initialPageParam: 1,
    queryFn: ({ pageParam }) =>
      withAuth((token) =>
        apiClient.listTransactions(
          {
            ...queryFilters,
            page: pageParam,
            limit: 20,
          },
          token,
        ),
      ),
    getNextPageParam: (lastPage) => {
      if (lastPage.pagination.page >= lastPage.pagination.totalPages) {
        return undefined;
      }

      return lastPage.pagination.page + 1;
    },
  });

  const transactions = useMemo(
    () => transactionsQuery.data?.pages.flatMap((page) => page.transactions) ?? [],
    [transactionsQuery.data?.pages],
  );

  const totals = useMemo(() => {
    let income = 0;
    let expense = 0;

    for (const transaction of transactions) {
      if (transaction.kind === 'transfer') {
        continue;
      }

      if (transaction.type === 'income') {
        income += transaction.amount;
      } else {
        expense += transaction.amount;
      }
    }

    return {
      income,
      expense,
    };
  }, [transactions]);

  const listItems = useMemo(() => buildListItems(transactions, t, locale), [locale, t, transactions]);

  const renderListItem = useCallback(
    ({ item }: { item: ListItem }) => {
      if (item.kind === 'header') {
        return <Text style={[styles.groupHeader, { color: theme.colors.textMuted }]}>{item.title}</Text>;
      }

      const transaction = item.transaction;
      return (
        <TransactionRow
          amount={formatSignedAmount(transaction.amount, transaction.currency, transaction.type, locale)}
          categoryIcon={getCategoryIcon(transaction, t)}
          date={getCategoryHint(transaction, t, locale)}
          dark={mode === 'dark'}
          kind={transaction.kind}
          onPress={() => navigation.navigate('TransactionDetail', { transactionId: transaction.id })}
          title={getTransactionTitle(transaction, t)}
          type={transaction.type}
        />
      );
    },
    [locale, mode, navigation, t, theme.colors.textMuted],
  );

  if (transactionsQuery.isLoading) {
    return (
      <ScreenContainer scrollable={false} contentStyle={styles.containerContent}>
        <View style={styles.loadingStateWrap}>
          <LoadingSkeleton />
          <Text style={[styles.loadingStateText, { color: theme.colors.textMuted }]}>
            {t('common.loadingShort')}
          </Text>
        </View>
      </ScreenContainer>
    );
  }

  if (transactionsQuery.isError) {
    return (
      <ScreenContainer>
        <Card style={styles.errorCard}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>{t('transactions.state.loadErrorTitle')}</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(transactionsQuery.error)}</Text>
          <PrimaryButton label={t('common.retry')} onPress={() => void transactionsQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  return (
    <ScreenContainer scrollable={false} contentStyle={styles.containerContent}>
      <FlatList
        contentContainerStyle={styles.listContent}
        data={listItems}
        ItemSeparatorComponent={() => <View style={styles.itemSeparator} />}
        keyExtractor={(item) => item.id}
        ListEmptyComponent={
          <Card>
            <Text style={[styles.emptyText, { color: theme.colors.textMuted }]}>
              {t('transactions.state.empty')}
            </Text>
          </Card>
        }
        ListFooterComponent={
          transactionsQuery.hasNextPage ? (
            <View style={styles.footerLoaderWrap}>
              {transactionsQuery.isFetchingNextPage ? (
                <>
                  <ActivityIndicator color={theme.colors.primary} size="small" />
                  <Text style={[styles.footerLoaderText, { color: theme.colors.textMuted }]}>
                    {t('transactions.state.loadingMore')}
                  </Text>
                </>
              ) : (
                <PrimaryButton
                  label={t('transactions.actions.loadMore')}
                  onPress={() => {
                    void transactionsQuery.fetchNextPage();
                  }}
                />
              )}
            </View>
          ) : (
            <View style={styles.footerSpacer} />
          )
        }
        ListHeaderComponent={
          <View style={styles.headerWrap}>
            <View style={styles.topBar}>
              <Pressable
                accessibilityRole="button"
                onPress={() => {
                  if (navigation.canGoBack()) {
                    navigation.goBack();
                  }
                }}
                style={styles.iconButton}
              >
                <Text style={[styles.iconButtonText, { color: theme.colors.text }]}>{'<'}</Text>
              </Pressable>

              <Text
                adjustsFontSizeToFit
                numberOfLines={1}
                style={[styles.screenTitle, { color: theme.colors.text }]}
              >
                {t('transactions.title')}
              </Text>

              <Pressable accessibilityRole="button" onPress={() => undefined} style={styles.iconButton}>
                <Text style={[styles.iconButtonText, { color: theme.colors.text }]}>⋮</Text>
              </Pressable>
            </View>

            <View
              style={[
                styles.searchWrap,
                {
                  backgroundColor: mode === 'dark' ? '#111A2E' : '#EEF2FA',
                },
              ]}
            >
              <Text style={[styles.searchIcon, { color: mode === 'dark' ? '#5C79C8' : '#6A84CB' }]}>⌕</Text>
              <TextInput
                autoCapitalize="none"
                onChangeText={setDraftSearch}
                onSubmitEditing={() => setActiveSearch(draftSearch)}
                placeholder={t('transactions.searchPlaceholder')}
                placeholderTextColor={theme.colors.textMuted}
                returnKeyType="search"
                style={[styles.searchInput, { color: theme.colors.text }]}
                value={draftSearch}
              />
            </View>

            <View style={styles.filterChipRow}>
              {(['all', 'income', 'expense'] as const).map((filter) => {
                const isActive = typeFilter === filter;
                const label =
                  filter === 'all' ? t('transactions.filters.all') : filter === 'income' ? t('analytics.income') : t('analytics.expense');

                return (
                  <Pressable
                    key={filter}
                    accessibilityRole="button"
                    onPress={() => setTypeFilter(filter)}
                    style={[
                      styles.filterChip,
                      {
                        backgroundColor: isActive
                          ? theme.colors.primary
                          : mode === 'dark'
                            ? 'rgba(47,107,255,0.20)'
                            : '#EAF0FF',
                      },
                    ]}
                  >
                    <Text
                      numberOfLines={1}
                      style={[
                        styles.filterChipText,
                        {
                          color: isActive
                            ? '#FFFFFF'
                            : theme.colors.primary,
                        },
                      ]}
                    >
                      {label}
                    </Text>
                  </Pressable>
                );
              })}

              <Pressable
                accessibilityRole="button"
                onPress={() => setActiveSearch(draftSearch)}
                style={[
                  styles.filterApplyButton,
                  {
                    borderColor: mode === 'dark' ? 'rgba(255,255,255,0.12)' : '#D8E0EE',
                    backgroundColor: mode === 'dark' ? '#151D2E' : '#FFFFFF',
                  },
                ]}
              >
                <Text numberOfLines={1} style={[styles.filterApplyText, { color: theme.colors.textMuted }]}>
                  {t('transactions.actions.search')}
                </Text>
              </Pressable>
            </View>

            <View style={styles.summaryRow}>
              <View
                style={[
                  styles.summaryCard,
                  {
                    backgroundColor: mode === 'dark' ? '#171F33' : '#FFFFFF',
                    borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#EAF0FA',
                  },
                ]}
              >
                <Text numberOfLines={1} style={[styles.summaryLabel, { color: theme.colors.textMuted }]}>
                  {t('transactions.summary.totalIncome')}
                </Text>
                <Text adjustsFontSizeToFit numberOfLines={1} style={styles.summaryIncome}>
                  {formatCurrency(totals.income, transactions[0]?.currency ?? 'TRY', locale)}
                </Text>
              </View>

              <View
                style={[
                  styles.summaryCard,
                  {
                    backgroundColor: mode === 'dark' ? '#171F33' : '#FFFFFF',
                    borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#EAF0FA',
                  },
                ]}
              >
                <Text numberOfLines={1} style={[styles.summaryLabel, { color: theme.colors.textMuted }]}>
                  {t('transactions.summary.totalExpense')}
                </Text>
                <Text adjustsFontSizeToFit numberOfLines={1} style={styles.summaryExpense}>
                  {formatCurrency(totals.expense, transactions[0]?.currency ?? 'TRY', locale)}
                </Text>
              </View>
            </View>

            <View style={styles.quickActionsRow}>
              <Pressable
                accessibilityRole="button"
                onPress={() => navigation.navigate('ScanHome')}
                style={[
                  styles.quickActionButton,
                  {
                    backgroundColor: mode === 'dark' ? '#151E33' : '#EAF0FF',
                    borderColor: mode === 'dark' ? 'rgba(255,255,255,0.12)' : '#D4E2FF',
                  },
                ]}
              >
                <Text numberOfLines={2} style={[styles.quickActionTitle, { color: theme.colors.primary }]}>
                  {t('transactions.quickActions.scanTitle')}
                </Text>
                <Text numberOfLines={2} style={[styles.quickActionSubtitle, { color: theme.colors.textMuted }]}>
                  {t('transactions.quickActions.scanSubtitle')}
                </Text>
              </Pressable>

              <Pressable
                accessibilityRole="button"
                onPress={() => navigation.navigate('Groups')}
                style={[
                  styles.quickActionButton,
                  {
                    backgroundColor: mode === 'dark' ? '#141C2B' : '#EAF9F0',
                    borderColor: mode === 'dark' ? 'rgba(255,255,255,0.12)' : '#CDEBD8',
                  },
                ]}
              >
                <Text numberOfLines={2} style={[styles.quickActionTitle, { color: theme.colors.income }]}>
                  {t('transactions.quickActions.splitTitle')}
                </Text>
                <Text numberOfLines={2} style={[styles.quickActionSubtitle, { color: theme.colors.textMuted }]}>
                  {t('transactions.quickActions.splitSubtitle')}
                </Text>
              </Pressable>
            </View>
          </View>
        }
        refreshControl={
          <RefreshControl
            onRefresh={() => {
              void transactionsQuery.refetch();
            }}
            refreshing={transactionsQuery.isRefetching && !transactionsQuery.isFetchingNextPage}
            tintColor={theme.colors.primary}
          />
        }
        renderItem={renderListItem}
        showsVerticalScrollIndicator={false}
      />
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    gap: 0,
    paddingBottom: 0,
    paddingHorizontal: 0,
    paddingTop: 0,
  },
  listContent: {
    paddingBottom: spacing.xl,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
  },
  loadingStateWrap: {
    gap: spacing.sm,
  },
  loadingStateText: {
    ...typography.body,
    textAlign: 'center',
  },
  headerWrap: {
    gap: spacing.sm,
    marginBottom: spacing.sm,
  },
  topBar: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  iconButton: {
    alignItems: 'center',
    borderRadius: radius.full,
    height: 36,
    justifyContent: 'center',
    width: 36,
  },
  iconButtonText: {
    ...typography.subheading,
    fontSize: 19,
    fontWeight: '700',
  },
  screenTitle: {
    ...typography.subheading,
    fontSize: 21,
    fontWeight: '700',
  },
  searchWrap: {
    alignItems: 'center',
    borderRadius: radius.md,
    flexDirection: 'row',
    gap: spacing.xs,
    height: 46,
    paddingHorizontal: spacing.sm,
  },
  searchIcon: {
    ...typography.subheading,
    fontSize: 14,
  },
  searchInput: {
    ...typography.body,
    flex: 1,
    fontSize: 14,
    lineHeight: 20,
    paddingVertical: 0,
  },
  filterChipRow: {
    alignItems: 'center',
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  filterChip: {
    borderRadius: radius.full,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xs,
  },
  filterChipText: {
    ...typography.caption,
    fontWeight: '700',
  },
  filterApplyButton: {
    borderRadius: radius.full,
    borderWidth: 1,
    marginLeft: 0,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xs,
  },
  filterApplyText: {
    ...typography.caption,
    fontWeight: '700',
  },
  summaryRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  quickActionsRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  quickActionButton: {
    borderRadius: radius.md,
    borderWidth: 1,
    flex: 1,
    gap: 2,
    minHeight: 58,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  quickActionTitle: {
    ...typography.subheading,
    fontSize: 16,
    fontWeight: '700',
  },
  quickActionSubtitle: {
    ...typography.caption,
    fontSize: 11,
  },
  summaryCard: {
    borderRadius: radius.md,
    borderWidth: 1,
    flex: 1,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  summaryLabel: {
    ...typography.caption,
    fontSize: 10,
    fontWeight: '700',
    letterSpacing: 0.6,
    marginBottom: spacing.xxs,
  },
  summaryIncome: {
    ...typography.subheading,
    color: '#17B26A',
    fontSize: 28,
    lineHeight: 34,
    fontWeight: '700',
    flexShrink: 1,
  },
  summaryExpense: {
    ...typography.subheading,
    color: '#F04438',
    fontSize: 28,
    lineHeight: 34,
    fontWeight: '700',
    flexShrink: 1,
  },
  groupHeader: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 1,
    marginTop: spacing.sm,
    textTransform: 'uppercase',
  },
  itemSeparator: {
    height: spacing.xs,
  },
  footerLoaderWrap: {
    alignItems: 'center',
    gap: spacing.xs,
    marginTop: spacing.md,
  },
  footerLoaderText: {
    ...typography.caption,
    fontSize: 12,
  },
  footerSpacer: {
    height: spacing.xl,
  },
  emptyText: {
    ...typography.body,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
  },
  errorText: {
    ...typography.body,
  },
  skeletonWrap: {
    gap: spacing.sm,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
  },
  skeletonHeader: {
    borderRadius: radius.md,
    height: 30,
    width: '45%',
  },
  skeletonSearch: {
    borderRadius: radius.md,
    height: 46,
    width: '100%',
  },
  skeletonChips: {
    flexDirection: 'row',
    gap: spacing.xs,
  },
  skeletonChip: {
    borderRadius: radius.full,
    height: 34,
    width: 90,
  },
  skeletonSummaryRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  skeletonSummary: {
    borderRadius: radius.md,
    flex: 1,
    height: 84,
  },
  skeletonItem: {
    borderRadius: radius.md,
    height: 66,
    width: '100%',
  },
});

===== FILE: apps/mobile/src/features/finance/screens/TransferScreen.tsx =====
import { Alert, Pressable, StyleSheet, Text, TextInput, View } from 'react-native';

import { zodResolver } from '@hookform/resolvers/zod';
import { transferCreateInputSchema } from '@mintly/shared';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { Controller, useForm } from 'react-hook-form';
import { z } from 'zod';

import { useAuth } from '@app/providers/AuthProvider';
import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { Card, Chip, PrimaryButton, ScreenContainer, Section } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import { colors, radius, spacing, typography } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

const transferFormSchema = z
  .object({
    fromAccountId: z.string().trim().min(1, 'errors.validation.selectSourceAccount'),
    toAccountId: z.string().trim().min(1, 'errors.validation.selectDestinationAccount'),
    amount: z
      .string()
      .trim()
      .min(1, 'errors.validation.amountRequired')
      .refine((value) => {
        const parsed = Number(value);
        return Number.isFinite(parsed) && parsed > 0;
      }, 'errors.validation.amountPositive'),
    occurredAt: z
      .string()
      .trim()
      .min(1, 'errors.validation.dateTimeRequired')
      .refine((value) => !Number.isNaN(Date.parse(value)), 'errors.validation.invalidIsoDateTime'),
    description: z.string().trim().max(500).optional(),
  })
  .refine((value) => value.fromAccountId !== value.toAccountId, {
    path: ['toAccountId'],
    message: 'errors.validation.sourceDestinationDifferent',
  });

type TransferFormValues = z.infer<typeof transferFormSchema>;

export function TransferScreen() {
  const { withAuth } = useAuth();
  const { t } = useI18n();
  const queryClient = useQueryClient();

  const accountsQuery = useQuery({
    queryKey: financeQueryKeys.accounts.list(),
    queryFn: () => withAuth((token) => apiClient.getAccounts(token)),
  });

  const form = useForm<TransferFormValues>({
    resolver: zodResolver(transferFormSchema),
    defaultValues: {
      fromAccountId: '',
      toAccountId: '',
      amount: '',
      occurredAt: new Date().toISOString(),
      description: '',
    },
  });

  const createTransferMutation = useMutation({
    mutationFn: (values: TransferFormValues) =>
      withAuth((token) =>
        apiClient.createTransfer(
          transferCreateInputSchema.parse({
            fromAccountId: values.fromAccountId,
            toAccountId: values.toAccountId,
            amount: Number(values.amount),
            occurredAt: new Date(values.occurredAt).toISOString(),
            description: values.description?.trim() || undefined,
          }),
          token,
        ),
      ),
    onSuccess: async () => {
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.transactions.all() }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.dashboard.recent() }),
      ]);

      form.reset({
        fromAccountId: '',
        toAccountId: '',
        amount: '',
        occurredAt: new Date().toISOString(),
        description: '',
      });
      Alert.alert(t('transfers.successTitle'), t('transfers.successMessage'));
    },
    onError: (error) => {
      Alert.alert(t('errors.transfer.createFailedTitle'), apiErrorText(error));
    },
  });

  if (accountsQuery.isLoading) {
    return (
      <ScreenContainer>
        <Card style={styles.stateCard}>
          <Text style={styles.helperText}>{t('transfers.state.loadingAccounts')}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (accountsQuery.isError) {
    return (
      <ScreenContainer>
        <Card style={styles.stateCard}>
          <Text style={styles.errorText}>{apiErrorText(accountsQuery.error)}</Text>
          <PrimaryButton label={t('common.retry')} onPress={() => void accountsQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  const accounts = accountsQuery.data?.accounts ?? [];

  if (accounts.length < 2) {
    return (
      <ScreenContainer>
        <Section title={t('transfers.title')}>
          <Card style={styles.stateCard}>
            <Text style={styles.helperText}>
              {t('transfers.state.needTwoAccounts')}
            </Text>
          </Card>
        </Section>
      </ScreenContainer>
    );
  }

  return (
    <ScreenContainer>
      <Section title={t('transfers.form.title')} subtitle={t('transfers.form.subtitle')}>
        <Card style={styles.formCard}>
          <Text style={styles.fieldLabel}>{t('transfers.form.fromAccount')}</Text>
          <Controller
            control={form.control}
            name="fromAccountId"
            render={({ field: { value, onChange } }) => (
              <View style={styles.chipWrap}>
                {accounts.map((account) => (
                  <Pressable key={`from-${account.id}`} onPress={() => onChange(account.id)}>
                    <Chip
                      label={`${account.name} (${account.currency})`}
                      tone={value === account.id ? 'expense' : 'default'}
                    />
                  </Pressable>
                ))}
              </View>
            )}
          />
          {form.formState.errors.fromAccountId ? (
            <Text style={styles.errorText}>{t(form.formState.errors.fromAccountId.message ?? '')}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>{t('transfers.form.toAccount')}</Text>
          <Controller
            control={form.control}
            name="toAccountId"
            render={({ field: { value, onChange } }) => (
              <View style={styles.chipWrap}>
                {accounts.map((account) => (
                  <Pressable key={`to-${account.id}`} onPress={() => onChange(account.id)}>
                    <Chip
                      label={`${account.name} (${account.currency})`}
                      tone={value === account.id ? 'income' : 'default'}
                    />
                  </Pressable>
                ))}
              </View>
            )}
          />
          {form.formState.errors.toAccountId ? (
            <Text style={styles.errorText}>{t(form.formState.errors.toAccountId.message ?? '')}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>{t('transfers.form.amount')}</Text>
          <Controller
            control={form.control}
            name="amount"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                keyboardType="decimal-pad"
                placeholder={t('transfers.form.amountPlaceholder')}
                placeholderTextColor={colors.textMuted}
              />
            )}
          />
          {form.formState.errors.amount ? (
            <Text style={styles.errorText}>{t(form.formState.errors.amount.message ?? '')}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>{t('transfers.form.occurredAt')}</Text>
          <Controller
            control={form.control}
            name="occurredAt"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                autoCapitalize="none"
                placeholder={t('transfers.form.occurredAtPlaceholder')}
                placeholderTextColor={colors.textMuted}
              />
            )}
          />
          {form.formState.errors.occurredAt ? (
            <Text style={styles.errorText}>{t(form.formState.errors.occurredAt.message ?? '')}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>{t('transfers.form.description')}</Text>
          <Controller
            control={form.control}
            name="description"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                placeholder={t('transfers.form.descriptionPlaceholder')}
                placeholderTextColor={colors.textMuted}
              />
            )}
          />

          <PrimaryButton
            label={createTransferMutation.isPending ? t('common.saving') : t('transfers.form.submit')}
            onPress={form.handleSubmit((values) => {
              createTransferMutation.mutate(values);
            })}
          />
        </Card>
      </Section>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  formCard: {
    gap: spacing.sm,
  },
  stateCard: {
    gap: spacing.sm,
  },
  fieldLabel: {
    ...typography.caption,
    color: colors.textMuted,
  },
  chipWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  input: {
    height: 44,
    borderWidth: 1,
    borderColor: colors.border,
    borderRadius: radius.md,
    backgroundColor: colors.surface,
    paddingHorizontal: spacing.sm,
    color: colors.text,
    ...typography.body,
  },
  helperText: {
    ...typography.body,
    color: colors.textMuted,
  },
  errorText: {
    ...typography.caption,
    color: colors.expense,
  },
});

===== FILE: apps/mobile/src/features/groups/index.ts =====
export { GroupsScreen } from './screens/GroupsScreen';
export { CreateGroupScreen } from './screens/CreateGroupScreen';
export { GroupDetailScreen } from './screens/GroupDetailScreen';
export { AddGroupExpenseScreen } from './screens/AddGroupExpenseScreen';
export { SettleUpScreen } from './screens/SettleUpScreen';

===== FILE: apps/mobile/src/features/groups/screens/AddGroupExpenseScreen.tsx =====
import { useEffect, useMemo, useState } from 'react';
import { Alert, Pressable, StyleSheet, Text, View } from 'react-native';

import { useNavigation, useRoute } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import type { RouteProp } from '@react-navigation/native';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';

import type { GroupExpenseCreateInput } from '@mintly/shared';

import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { useAuth } from '@app/providers/AuthProvider';
import {
  AppIcon,
  Card,
  GradientCard,
  MemberChip,
  PrimaryButton,
  ScreenContainer,
  SplitToggle,
  TextField,
} from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { TransactionsStackParamList } from '@core/navigation/stacks/TransactionsStack';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

type SplitMode = 'equal' | 'custom';

const CATEGORY_OPTIONS: Array<{
  id: 'food' | 'transport' | 'rent' | 'bills' | 'shopping' | 'other';
  iconName: Parameters<typeof AppIcon>[0]['name'];
  key: string;
}> = [
  { id: 'food', iconName: 'restaurant-outline', key: 'split.addExpense.categoryOptions.food' },
  { id: 'transport', iconName: 'car-sport-outline', key: 'split.addExpense.categoryOptions.transport' },
  { id: 'rent', iconName: 'home-outline', key: 'split.addExpense.categoryOptions.rent' },
  { id: 'bills', iconName: 'receipt-outline', key: 'split.addExpense.categoryOptions.bills' },
  { id: 'shopping', iconName: 'bag-outline', key: 'split.addExpense.categoryOptions.shopping' },
  { id: 'other', iconName: 'ellipse-outline', key: 'split.addExpense.categoryOptions.other' },
];

function toInputDate(value: Date): string {
  const year = value.getFullYear();
  const month = String(value.getMonth() + 1).padStart(2, '0');
  const day = String(value.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function formatMoney(amount: number, currency: string, locale: string): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

function parseDecimal(value: string): number {
  return Number(value.replace(',', '.').trim());
}

export function AddGroupExpenseScreen() {
  const route = useRoute<RouteProp<TransactionsStackParamList, 'AddGroupExpense'>>();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const queryClient = useQueryClient();
  const { withAuth, user } = useAuth();
  const { theme, mode } = useTheme();
  const { locale, t } = useI18n();

  const [title, setTitle] = useState('');
  const [amount, setAmount] = useState('');
  const [expenseDate, setExpenseDate] = useState(toInputDate(new Date()));
  const [selectedCategoryId, setSelectedCategoryId] = useState<(typeof CATEGORY_OPTIONS)[number]['id']>('food');
  const [splitMode, setSplitMode] = useState<SplitMode>('equal');
  const [paidByMemberId, setPaidByMemberId] = useState('');
  const [selectedMemberIds, setSelectedMemberIds] = useState<string[]>([]);
  const [customSplits, setCustomSplits] = useState<Record<string, string>>({});
  const [showPaidByOptions, setShowPaidByOptions] = useState(false);

  const groupQuery = useQuery({
    queryKey: financeQueryKeys.groups.detail(route.params.groupId),
    queryFn: () => withAuth((token) => apiClient.getGroup(route.params.groupId, token)),
  });

  useEffect(() => {
    if (!groupQuery.data) {
      return;
    }

    const ids = groupQuery.data.members.map((member) => member.id);
    if (!paidByMemberId && ids.length > 0) {
      setPaidByMemberId(ids[0]);
    }

    if (selectedMemberIds.length === 0 && ids.length > 0) {
      setSelectedMemberIds(ids);
    }
  }, [groupQuery.data, paidByMemberId, selectedMemberIds.length]);

  const members = groupQuery.data?.members ?? [];

  const activeMembers = useMemo(
    () => members.filter((member) => selectedMemberIds.includes(member.id)),
    [members, selectedMemberIds],
  );

  const currency = user?.baseCurrency ?? 'TRY';

  const createMutation = useMutation({
    mutationFn: (payload: GroupExpenseCreateInput) =>
      withAuth((token) => apiClient.createGroupExpense(route.params.groupId, payload, token)),
    onSuccess: async () => {
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.detail(route.params.groupId) }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.expenses(route.params.groupId) }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.list() }),
      ]);

      navigation.goBack();
    },
    onError: (error) => {
      Alert.alert(t('split.addExpense.errors.createFailedTitle'), apiErrorText(error));
    },
  });

  const validateAndBuildPayload = (): GroupExpenseCreateInput | null => {
    const trimmedTitle = title.trim();
    if (!trimmedTitle) {
      Alert.alert(
        t('split.addExpense.errors.requiredTitleTitle'),
        t('split.addExpense.errors.requiredTitleMessage'),
      );
      return null;
    }

    const parsedAmount = parseDecimal(amount);
    if (!Number.isFinite(parsedAmount) || parsedAmount <= 0) {
      Alert.alert(
        t('split.addExpense.errors.invalidAmountTitle'),
        t('split.addExpense.errors.invalidAmountMessage'),
      );
      return null;
    }

    if (!paidByMemberId) {
      Alert.alert(
        t('split.addExpense.errors.paidByRequiredTitle'),
        t('split.addExpense.errors.paidByRequiredMessage'),
      );
      return null;
    }

    if (activeMembers.length === 0) {
      Alert.alert(
        t('split.addExpense.errors.membersRequiredTitle'),
        t('split.addExpense.errors.membersRequiredMessage'),
      );
      return null;
    }

    const splits =
      splitMode === 'equal'
        ? activeMembers.map((member, index) => {
            if (index === activeMembers.length - 1) {
              const distributed =
                (activeMembers.length - 1) * Number((parsedAmount / activeMembers.length).toFixed(2));
              return {
                memberId: member.id,
                amount: Number((parsedAmount - distributed).toFixed(2)),
              };
            }

            return {
              memberId: member.id,
              amount: Number((parsedAmount / activeMembers.length).toFixed(2)),
            };
          })
        : activeMembers.map((member) => ({
            memberId: member.id,
            amount: Number((customSplits[member.id] ?? '').replace(',', '.')),
          }));

    if (splitMode === 'custom') {
      const hasInvalid = splits.some((split) => !Number.isFinite(split.amount) || split.amount < 0);
      if (hasInvalid) {
        Alert.alert(
          t('split.addExpense.errors.invalidCustomSplitTitle'),
          t('split.addExpense.errors.invalidCustomSplitMessage'),
        );
        return null;
      }

      const splitTotal = Number(splits.reduce((sum, split) => sum + split.amount, 0).toFixed(2));
      const amountTotal = Number(parsedAmount.toFixed(2));
      if (Math.abs(splitTotal - amountTotal) > 0.01) {
        Alert.alert(
          t('split.addExpense.errors.splitMismatchTitle'),
          t('split.addExpense.errors.splitMismatchMessage', {
            amount: formatMoney(amountTotal, currency, locale),
            split: formatMoney(splitTotal, currency, locale),
          }),
        );
        return null;
      }
    }

    return {
      paidByMemberId,
      title: trimmedTitle,
      amount: parsedAmount,
      currency,
      splits,
    };
  };

  const selectedPaidBy = members.find((member) => member.id === paidByMemberId);

  if (groupQuery.isLoading) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.loadingCard}>
          <AppIcon name="people-outline" size="lg" tone="primary" />
          <Text style={[styles.helperText, { color: theme.colors.textMuted }]}>{t('split.addExpense.loading')}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (groupQuery.isError || !groupQuery.data) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.errorCard}>
          <AppIcon name="alert-circle-outline" size="lg" tone="expense" />
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>{t('split.addExpense.loadErrorTitle')}</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(groupQuery.error)}</Text>
          <PrimaryButton iconName="refresh" label={t('split.addExpense.retry')} onPress={() => void groupQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  const equalShareValue =
    activeMembers.length > 0 && Number.isFinite(parseDecimal(amount))
      ? parseDecimal(amount) / activeMembers.length
      : 0;

  return (
    <ScreenContainer dark={mode === 'dark'}>
      <View style={styles.container}>
        <GradientCard>
          <View style={styles.heroHeader}>
            <AppIcon name="receipt-outline" size="md" tone="inverse" />
            <Text style={styles.heroTitle}>{t('split.addExpense.title')}</Text>
          </View>
          <Text style={styles.heroSubtitle}>{t('split.addExpense.subtitle', { group: groupQuery.data.name })}</Text>
        </GradientCard>

        <Card dark={mode === 'dark'} style={styles.formCard}>
          <TextField
            label={t('split.addExpense.fields.titleLabel')}
            value={title}
            onChangeText={setTitle}
            placeholder={t('split.addExpense.fields.titlePlaceholder')}
            returnKeyType="next"
          />

          <View style={styles.rowTwoCol}>
            <View style={styles.col}>
              <TextField
                label={t('split.addExpense.fields.amountLabel')}
                value={amount}
                onChangeText={setAmount}
                placeholder={t('split.addExpense.fields.amountPlaceholder')}
                keyboardType="decimal-pad"
                returnKeyType="done"
              />
            </View>
            <View style={styles.col}>
              <TextField
                label={t('split.addExpense.fields.dateLabel')}
                value={expenseDate}
                onChangeText={setExpenseDate}
                placeholder={t('split.addExpense.fields.datePlaceholder')}
                autoCapitalize="none"
                returnKeyType="done"
              />
            </View>
          </View>

          <View style={styles.sectionWrap}>
            <View style={styles.sectionHeader}>
              <AppIcon name="grid-outline" size="sm" tone="primary" />
              <Text style={[styles.sectionLabel, { color: theme.colors.labelMuted }]}>{t('split.addExpense.fields.categoryLabel')}</Text>
            </View>
            <View style={styles.categoryRow}>
              {CATEGORY_OPTIONS.map((item) => {
                const active = item.id === selectedCategoryId;
                return (
                  <Pressable
                    key={item.id}
                    accessibilityRole="button"
                    accessibilityLabel={t(item.key)}
                    onPress={() => setSelectedCategoryId(item.id)}
                    style={({ pressed }) => [
                      styles.categoryItem,
                      {
                        borderColor: active ? theme.colors.primary : theme.colors.border,
                        backgroundColor: active
                          ? mode === 'dark'
                            ? 'rgba(47,107,255,0.20)'
                            : '#ECF1FF'
                          : mode === 'dark'
                            ? '#111A30'
                            : '#FFFFFF',
                      },
                      pressed ? styles.pressed : null,
                    ]}
                  >
                    <AppIcon name={item.iconName} size="sm" tone={active ? 'primary' : 'muted'} />
                    <Text numberOfLines={1} style={[styles.categoryLabel, { color: theme.colors.textMuted }]}>
                      {t(item.key)}
                    </Text>
                  </Pressable>
                );
              })}
            </View>
          </View>

          <View style={styles.sectionWrap}>
            <View style={styles.sectionHeader}>
              <AppIcon name="wallet-outline" size="sm" tone="primary" />
              <Text style={[styles.sectionLabel, { color: theme.colors.labelMuted }]}>{t('split.addExpense.fields.paidByLabel')}</Text>
            </View>
            <Pressable
              accessibilityRole="button"
              onPress={() => setShowPaidByOptions((prev) => !prev)}
              style={({ pressed }) => [
                styles.dropdown,
                {
                  borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#DFE7F4',
                  backgroundColor: mode === 'dark' ? '#0F172B' : '#F9FBFF',
                },
                pressed ? styles.pressed : null,
              ]}
            >
              <Text style={[styles.dropdownText, { color: theme.colors.text }]}>
                {selectedPaidBy?.name ?? t('split.addExpense.fields.paidByPlaceholder')}
              </Text>
              <AppIcon name={showPaidByOptions ? 'chevron-up' : 'chevron-down'} size="sm" tone="muted" />
            </Pressable>

            {showPaidByOptions ? (
              <View
                style={[
                  styles.dropdownList,
                  {
                    borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#DFE7F4',
                    backgroundColor: mode === 'dark' ? '#0F172B' : '#FFFFFF',
                  },
                ]}
              >
                {members.map((member, index) => (
                  <Pressable
                    key={member.id}
                    accessibilityRole="button"
                    onPress={() => {
                      setPaidByMemberId(member.id);
                      setShowPaidByOptions(false);
                    }}
                    style={({ pressed }) => [styles.dropdownOption, pressed ? styles.pressed : null]}
                  >
                    <Text style={[styles.dropdownOptionText, { color: theme.colors.text }]}>{member.name}</Text>
                    {member.id === paidByMemberId ? <AppIcon name="checkmark" size="sm" tone="primary" /> : null}
                    {index < members.length - 1 ? (
                      <View
                        style={[
                          styles.dropdownDivider,
                          { backgroundColor: mode === 'dark' ? 'rgba(255,255,255,0.08)' : '#E6EDF8' },
                        ]}
                      />
                    ) : null}
                  </Pressable>
                ))}
              </View>
            ) : null}
          </View>

          <View style={styles.sectionWrap}>
            <View style={styles.sectionHeader}>
              <AppIcon name="people-outline" size="sm" tone="primary" />
              <Text style={[styles.sectionLabel, { color: theme.colors.labelMuted }]}>{t('split.addExpense.fields.membersLabel')}</Text>
            </View>
            <View style={styles.membersWrap}>
              {members.map((member) => {
                const selected = selectedMemberIds.includes(member.id);

                return (
                  <MemberChip
                    key={member.id}
                    name={member.name}
                    selected={selected}
                    onPress={() => {
                      setSelectedMemberIds((prev) =>
                        prev.includes(member.id) ? prev.filter((id) => id !== member.id) : [...prev, member.id],
                      );
                    }}
                  />
                );
              })}
            </View>
            <Text style={[styles.helperText, { color: theme.colors.textMuted }]}> 
              {t('split.addExpense.memberSelectedCount', { count: selectedMemberIds.length })}
            </Text>
          </View>

          <View style={styles.sectionWrap}>
            <View style={styles.sectionHeader}>
              <AppIcon name="git-compare-outline" size="sm" tone="primary" />
              <Text style={[styles.sectionLabel, { color: theme.colors.labelMuted }]}>{t('split.addExpense.fields.splitModeLabel')}</Text>
            </View>
            <SplitToggle
              value={splitMode}
              onChange={setSplitMode}
              equalLabel={t('split.addExpense.splitModes.equal')}
              customLabel={t('split.addExpense.splitModes.custom')}
            />

            {splitMode === 'equal' ? (
              <View
                style={[
                  styles.previewCard,
                  {
                    borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#DFE7F4',
                    backgroundColor: mode === 'dark' ? '#0F172B' : '#F8FAFF',
                  },
                ]}
              >
                <Text style={[styles.previewTitle, { color: theme.colors.text }]}>{t('split.addExpense.sections.equalPreview')}</Text>
                {activeMembers.map((member) => (
                  <View key={member.id} style={styles.previewRow}>
                    <Text style={[styles.previewName, { color: theme.colors.textMuted }]}>{member.name}</Text>
                    <Text style={[styles.previewValue, { color: theme.colors.text }]}> 
                      {t('split.addExpense.equalShare', {
                        amount: formatMoney(equalShareValue, currency, locale),
                      })}
                    </Text>
                  </View>
                ))}
              </View>
            ) : (
              <View style={styles.customSplitWrap}>
                <Text style={[styles.previewTitle, { color: theme.colors.text }]}>{t('split.addExpense.sections.customPreview')}</Text>
                {activeMembers.map((member) => (
                  <TextField
                    key={member.id}
                    label={t('split.addExpense.fields.splitForMemberLabel', { name: member.name })}
                    value={customSplits[member.id] ?? ''}
                    onChangeText={(value) =>
                      setCustomSplits((prev) => ({
                        ...prev,
                        [member.id]: value,
                      }))
                    }
                    placeholder={t('split.addExpense.fields.amountPlaceholder')}
                    keyboardType="decimal-pad"
                  />
                ))}
              </View>
            )}
          </View>

          <PrimaryButton
            disabled={createMutation.isPending}
            iconName={createMutation.isPending ? 'hourglass-outline' : 'checkmark-circle-outline'}
            label={
              createMutation.isPending
                ? t('split.addExpense.actions.submitting')
                : t('split.addExpense.actions.submit')
            }
            onPress={() => {
              const payload = validateAndBuildPayload();
              if (!payload) {
                return;
              }

              createMutation.mutate(payload);
            }}
          />
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  loadingCard: {
    alignItems: 'center',
    gap: spacing.xs,
  },
  heroHeader: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  heroTitle: {
    ...typography.heading,
    color: '#FFFFFF',
    fontSize: 24,
  },
  heroSubtitle: {
    ...typography.caption,
    color: '#DFE9FF',
    fontSize: 12,
  },
  formCard: {
    gap: spacing.sm,
  },
  rowTwoCol: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  col: {
    flex: 1,
  },
  sectionWrap: {
    gap: spacing.xs,
  },
  sectionHeader: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  sectionLabel: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
    letterSpacing: 0.3,
  },
  categoryRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  categoryItem: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    minWidth: 72,
    paddingHorizontal: spacing.xs,
    paddingVertical: spacing.xs,
  },
  categoryLabel: {
    ...typography.caption,
    fontSize: 10,
    fontWeight: '600',
    marginTop: 2,
  },
  dropdown: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
    minHeight: 46,
    paddingHorizontal: spacing.sm,
  },
  dropdownText: {
    ...typography.body,
    flex: 1,
    fontSize: 14,
  },
  dropdownList: {
    borderRadius: radius.md,
    borderWidth: 1,
    overflow: 'hidden',
  },
  dropdownOption: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
    minHeight: 42,
    paddingHorizontal: spacing.sm,
    position: 'relative',
  },
  dropdownOptionText: {
    ...typography.body,
    fontSize: 14,
  },
  dropdownDivider: {
    bottom: 0,
    height: 1,
    left: spacing.sm,
    position: 'absolute',
    right: spacing.sm,
  },
  membersWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  previewCard: {
    borderRadius: radius.md,
    borderWidth: 1,
    gap: spacing.xs,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  previewTitle: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
  },
  previewRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  previewName: {
    ...typography.body,
    fontSize: 14,
  },
  previewValue: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
  },
  customSplitWrap: {
    gap: spacing.xs,
  },
  helperText: {
    ...typography.caption,
    fontSize: 11,
  },
  errorCard: {
    alignItems: 'center',
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
    fontWeight: '700',
    textAlign: 'center',
  },
  errorText: {
    ...typography.body,
    textAlign: 'center',
  },
  pressed: {
    opacity: 0.86,
  },
});

===== FILE: apps/mobile/src/features/groups/screens/CreateGroupScreen.tsx =====
import { useMemo } from 'react';
import { Alert, StyleSheet, Text, View } from 'react-native';

import { zodResolver } from '@hookform/resolvers/zod';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { Controller, useForm } from 'react-hook-form';
import { z } from 'zod';

import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { useAuth } from '@app/providers/AuthProvider';
import { AppIcon, Card, PrimaryButton, ScreenContainer, TextField } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { TransactionsStackParamList } from '@core/navigation/stacks/TransactionsStack';
import { spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

function parseMembers(value: string) {
  return value
    .split('\n')
    .map((line) => line.trim())
    .filter(Boolean)
    .map((line) => {
      const parts = line.split(',').map((part) => part.trim()).filter(Boolean);

      if (parts.length >= 2) {
        return { name: parts[0], email: parts[1] };
      }

      const email = parts[0] ?? '';
      const name = email.includes('@') ? email.split('@')[0] : email;
      return { name, email };
    })
    .filter((member) => member.name.length > 0 && member.email.length > 0);
}

export function CreateGroupScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const queryClient = useQueryClient();
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();
  const { t } = useI18n();

  const formSchema = useMemo(
    () =>
      z.object({
        name: z.string().trim().min(1, t('groups.create.validation.nameRequired')).max(120),
        members: z.string().trim().optional(),
      }),
    [t],
  );

  type FormValues = z.infer<typeof formSchema>;

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      members: '',
    },
  });

  const membersValue = form.watch('members') ?? '';
  const membersPreview = useMemo(() => parseMembers(membersValue), [membersValue]);

  const createMutation = useMutation({
    mutationFn: (values: FormValues) =>
      withAuth((token) =>
        apiClient.createGroup(
          {
            name: values.name,
            members: parseMembers(values.members ?? ''),
          },
          token,
        ),
      ),
    onSuccess: async (createdGroup) => {
      await queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.all() });
      navigation.replace('GroupDetail', { groupId: createdGroup.id });
    },
    onError: (error) => {
      Alert.alert(t('groups.create.errors.createFailedTitle'), apiErrorText(error));
    },
  });

  return (
    <ScreenContainer dark={mode === 'dark'}>
      <View style={styles.container}>
        <Card dark={mode === 'dark'} style={styles.card}>
          <View style={styles.headerRow}>
            <AppIcon name="people-outline" size="md" tone="primary" />
            <Text style={[styles.title, { color: theme.colors.text }]}>{t('groups.create.title')}</Text>
          </View>
          <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}>{t('groups.create.subtitle')}</Text>

          <Controller
            control={form.control}
            name="name"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextField
                label={t('groups.create.fields.nameLabel')}
                value={value}
                onBlur={onBlur}
                onChangeText={onChange}
                placeholder={t('groups.create.fields.namePlaceholder')}
                error={form.formState.errors.name?.message}
              />
            )}
          />

          <Controller
            control={form.control}
            name="members"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextField
                label={t('groups.create.fields.membersLabel')}
                value={value ?? ''}
                onBlur={onBlur}
                onChangeText={onChange}
                placeholder={t('groups.create.fields.membersPlaceholder')}
                autoCapitalize="none"
                multiline
                numberOfLines={5}
                returnKeyType="default"
                blurOnSubmit={false}
                inputStyle={styles.membersInput}
                inputWrapStyle={styles.membersInputWrap}
              />
            )}
          />

          {membersPreview.length > 0 ? (
            <Text style={[styles.previewText, { color: theme.colors.textMuted }]}> 
              {t('groups.create.previewCount', { count: membersPreview.length })}
            </Text>
          ) : null}

          <PrimaryButton
            iconName={createMutation.isPending ? 'hourglass-outline' : 'add-circle-outline'}
            disabled={createMutation.isPending}
            label={createMutation.isPending ? t('groups.create.actions.creating') : t('groups.create.actions.create')}
            onPress={form.handleSubmit((values) => createMutation.mutate(values))}
          />
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  card: {
    gap: spacing.sm,
  },
  headerRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  title: {
    ...typography.heading,
    fontSize: 24,
  },
  subtitle: {
    ...typography.body,
  },
  membersInputWrap: {
    alignItems: 'stretch',
    height: 120,
  },
  membersInput: {
    minHeight: 100,
    paddingBottom: spacing.sm,
    paddingTop: spacing.sm,
    textAlignVertical: 'top',
  },
  previewText: {
    ...typography.caption,
  },
});

===== FILE: apps/mobile/src/features/groups/screens/GroupDetailScreen.tsx =====
import { useMemo } from 'react';
import { ActivityIndicator, FlatList, Pressable, StyleSheet, Text, View } from 'react-native';

import type { GroupExpense } from '@mintly/shared';
import { useNavigation, useRoute } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import type { RouteProp } from '@react-navigation/native';
import { useQuery } from '@tanstack/react-query';

import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { useAuth } from '@app/providers/AuthProvider';
import { AppIcon, Card, ExpenseRow, GradientCard, MemberChip, ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { TransactionsStackParamList } from '@core/navigation/stacks/TransactionsStack';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

function buildBalanceMap(expenses: GroupExpense[]) {
  const map = new Map<string, number>();

  for (const expense of expenses) {
    map.set(expense.paidByMemberId, (map.get(expense.paidByMemberId) ?? 0) + expense.amount);

    for (const split of expense.splits) {
      map.set(split.memberId, (map.get(split.memberId) ?? 0) - split.amount);
    }
  }

  return map;
}

function formatMoney(amount: number, currency: string, locale: string): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

function formatDate(value: string, locale: string): string {
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return value;
  }

  return date.toLocaleDateString(locale, {
    day: '2-digit',
    month: 'short',
  });
}

function iconForExpense(title: string): Parameters<typeof AppIcon>[0]['name'] {
  const normalized = title.toLowerCase();

  if (normalized.includes('market') || normalized.includes('grocery')) {
    return 'cart-outline';
  }

  if (normalized.includes('transport') || normalized.includes('taxi') || normalized.includes('fuel')) {
    return 'car-sport-outline';
  }

  if (normalized.includes('rent') || normalized.includes('home')) {
    return 'home-outline';
  }

  if (normalized.includes('bill') || normalized.includes('invoice')) {
    return 'receipt-outline';
  }

  return 'card-outline';
}

export function GroupDetailScreen() {
  const route = useRoute<RouteProp<TransactionsStackParamList, 'GroupDetail'>>();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const { withAuth, user } = useAuth();
  const { theme, mode } = useTheme();
  const { locale, t } = useI18n();

  const groupQuery = useQuery({
    queryKey: financeQueryKeys.groups.detail(route.params.groupId),
    queryFn: () => withAuth((token) => apiClient.getGroup(route.params.groupId, token)),
  });

  const expensesQuery = useQuery({
    queryKey: financeQueryKeys.groups.expenses(route.params.groupId),
    queryFn: () => withAuth((token) => apiClient.getGroupExpenses(route.params.groupId, token)),
  });

  const group = groupQuery.data;
  const expenses = expensesQuery.data?.expenses ?? [];

  const balanceMap = useMemo(() => buildBalanceMap(expenses), [expenses]);

  const currentMember = useMemo(
    () =>
      group?.members.find((member) => {
        if (!user) {
          return false;
        }

        return member.userId === user.id || member.email.toLowerCase() === user.email.toLowerCase();
      }) ?? null,
    [group?.members, user],
  );

  const currency = expenses[0]?.currency ?? user?.baseCurrency ?? 'TRY';

  const userBalance = currentMember ? balanceMap.get(currentMember.id) ?? 0 : 0;
  const groupTotal = expenses.reduce((sum, item) => sum + item.amount, 0);

  const userBalanceLabel =
    userBalance > 0
      ? t('split.groupDetail.balanceState.creditor')
      : userBalance < 0
        ? t('split.groupDetail.balanceState.debtor')
        : t('split.groupDetail.balanceState.settled');

  const sortedExpenses = useMemo(
    () => [...expenses].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()),
    [expenses],
  );

  const memberRows = useMemo(
    () =>
      (group?.members ?? []).map((member) => ({
        member,
        balance: balanceMap.get(member.id) ?? 0,
      })),
    [balanceMap, group?.members],
  );

  if (groupQuery.isLoading || expensesQuery.isLoading) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.loadingCard}>
          <AppIcon name="people-outline" size="xl" tone="primary" />
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={[styles.helperText, { color: theme.colors.textMuted }]}>{t('split.groupDetail.loading')}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (groupQuery.isError || expensesQuery.isError || !groupQuery.data || !expensesQuery.data) {
    const error = groupQuery.error ?? expensesQuery.error;

    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.errorCard}>
          <AppIcon name="alert-circle-outline" size="lg" tone="expense" />
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>{t('split.groupDetail.loadErrorTitle')}</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(error)}</Text>
          <Pressable
            accessibilityRole="button"
            onPress={() => {
              void groupQuery.refetch();
              void expensesQuery.refetch();
            }}
            style={({ pressed }) => [
              styles.retryButton,
              {
                backgroundColor: theme.colors.primary,
              },
              pressed ? styles.buttonPressed : null,
            ]}
          >
            <View style={styles.retryInner}>
              <AppIcon name="refresh" size="sm" tone="inverse" />
              <Text style={styles.retryLabel}>{t('split.groupDetail.retry')}</Text>
            </View>
          </Pressable>
        </Card>
      </ScreenContainer>
    );
  }

  const groupData = groupQuery.data;

  return (
    <ScreenContainer dark={mode === 'dark'} scrollable={false} contentStyle={styles.containerContent}>
      <View style={styles.screenWrap}>
        <FlatList
          contentContainerStyle={styles.content}
          data={sortedExpenses}
          keyExtractor={(item) => item.id}
          ListHeaderComponent={
            <View style={styles.headerWrap}>
              <GradientCard>
                <Text style={styles.summaryLabel}>{t('split.groupDetail.summaryTitle')}</Text>
                <Text style={styles.summaryTitle}>{groupData.name}</Text>
                <Text style={styles.summarySub}>{t('split.groupDetail.summarySubtitle')}</Text>

                <View style={styles.summaryMetrics}>
                  <View style={styles.metricBlock}>
                    <Text style={styles.metricLabel}>{t('split.groupDetail.totalSpending')}</Text>
                    <Text style={styles.metricValue}>{formatMoney(groupTotal, currency, locale)}</Text>
                  </View>

                  <View style={styles.metricBlock}>
                    <Text style={styles.metricLabel}>{t('split.groupDetail.yourBalance')}</Text>
                    <Text
                      style={[
                        styles.metricValue,
                        {
                          color:
                            userBalance > 0 ? '#B3FFD9' : userBalance < 0 ? '#FFD2CF' : '#E4ECFF',
                        },
                      ]}
                    >
                      {userBalance > 0 ? '+' : userBalance < 0 ? '-' : ''}
                      {formatMoney(Math.abs(userBalance), currency, locale)}
                    </Text>
                    <View style={styles.balanceTag}>
                      <Text style={styles.balanceTagText}>{userBalanceLabel}</Text>
                    </View>
                  </View>
                </View>
              </GradientCard>

              <View style={styles.sectionWrap}>
                <View style={styles.sectionHeader}>
                  <AppIcon name="people-outline" size="sm" tone="primary" />
                  <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>{t('split.groupDetail.membersTitle')}</Text>
                </View>
                <FlatList
                  data={memberRows}
                  horizontal
                  keyExtractor={(item) => item.member.id}
                  renderItem={({ item }) => (
                    <View style={styles.memberItemWrap}>
                      <MemberChip
                        name={item.member.name}
                        balance={item.balance}
                        currency={currency}
                        showBalance
                        selected={currentMember?.id === item.member.id}
                      />
                    </View>
                  )}
                  showsHorizontalScrollIndicator={false}
                />
              </View>

              <View style={styles.sectionHeader}>
                <AppIcon name="receipt-outline" size="sm" tone="primary" />
                <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>{t('split.groupDetail.recentExpenses')}</Text>
              </View>
            </View>
          }
          ListEmptyComponent={
            <Card dark={mode === 'dark'} style={styles.emptyCard}>
              <AppIcon name="file-tray-outline" size="lg" tone="muted" />
              <Text style={[styles.helperText, { color: theme.colors.textMuted }]}>{t('split.groupDetail.noExpenses')}</Text>
            </Card>
          }
          ItemSeparatorComponent={() => <View style={styles.separator} />}
          renderItem={({ item }) => {
            const paidBy =
              groupData.members.find((member) => member.id === item.paidByMemberId)?.name ??
              t('split.common.unknownMember');
            const yourShare =
              currentMember ? item.splits.find((split) => split.memberId === currentMember.id)?.amount ?? 0 : 0;

            const net = currentMember
              ? item.paidByMemberId === currentMember.id
                ? item.amount - yourShare
                : -yourShare
              : 0;

            const indicatorTone: 'positive' | 'negative' | 'neutral' =
              item.settledAt || net === 0 ? 'neutral' : net > 0 ? 'positive' : 'negative';

            const indicatorLabel = item.settledAt
              ? t('split.groupDetail.indicator.settled')
              : currentMember
                ? net > 0
                  ? t('split.groupDetail.indicator.youGet', {
                      amount: formatMoney(Math.abs(net), item.currency, locale),
                    })
                  : net < 0
                    ? t('split.groupDetail.indicator.youOwe', {
                        amount: formatMoney(Math.abs(net), item.currency, locale),
                      })
                    : t('split.groupDetail.indicator.noShare')
                : t('split.groupDetail.indicator.unknownShare');

            return (
              <ExpenseRow
                iconName={iconForExpense(item.title)}
                title={item.title}
                subtitle={t('split.groupDetail.expenseSubtitle', {
                  payer: paidBy,
                  date: formatDate(item.createdAt, locale),
                })}
                amount={formatMoney(item.amount, item.currency, locale)}
                indicator={indicatorLabel}
                indicatorTone={indicatorTone}
              />
            );
          }}
          showsVerticalScrollIndicator={false}
        />

        <View
          style={[
            styles.actionRow,
            {
              borderTopColor: mode === 'dark' ? 'rgba(255,255,255,0.08)' : '#DFE7F4',
              backgroundColor: theme.colors.background,
            },
          ]}
        >
          <Pressable
            accessibilityRole="button"
            onPress={() => navigation.navigate('SettleUp', { groupId: groupData.id })}
            style={({ pressed }) => [
              styles.outlineButton,
              {
                borderColor: theme.colors.primary,
                backgroundColor: mode === 'dark' ? 'rgba(47,107,255,0.12)' : '#FFFFFF',
              },
              pressed ? styles.buttonPressed : null,
            ]}
          >
            <View style={styles.buttonInner}>
              <AppIcon name="wallet-outline" size="sm" tone="primary" />
              <Text style={[styles.outlineLabel, { color: theme.colors.primary }]}>
                {t('split.groupDetail.actions.settleUp')}
              </Text>
            </View>
          </Pressable>

          <Pressable
            accessibilityRole="button"
            onPress={() => navigation.navigate('AddGroupExpense', { groupId: groupData.id })}
            style={({ pressed }) => [
              styles.primaryButton,
              {
                backgroundColor: theme.colors.primary,
              },
              pressed ? styles.buttonPressed : null,
            ]}
          >
            <View style={styles.buttonInner}>
              <AppIcon name="add-circle-outline" size="sm" tone="inverse" />
              <Text style={[styles.primaryLabel, { color: theme.colors.buttonPrimaryText }]}>
                {t('split.groupDetail.actions.addExpense')}
              </Text>
            </View>
          </Pressable>
        </View>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    gap: 0,
    paddingBottom: 0,
    paddingHorizontal: 0,
    paddingTop: 0,
  },
  screenWrap: {
    flex: 1,
  },
  content: {
    paddingBottom: spacing.xl,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
  },
  headerWrap: {
    gap: spacing.md,
    marginBottom: spacing.sm,
  },
  summaryLabel: {
    ...typography.caption,
    color: '#D4E4FF',
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 0.4,
    textTransform: 'uppercase',
  },
  summaryTitle: {
    ...typography.heading,
    color: '#FFFFFF',
    fontSize: 28,
    lineHeight: 34,
  },
  summarySub: {
    ...typography.caption,
    color: '#E4ECFF',
    fontSize: 12,
  },
  summaryMetrics: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  metricBlock: {
    backgroundColor: 'rgba(255,255,255,0.14)',
    borderRadius: radius.md,
    flex: 1,
    gap: 4,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  metricLabel: {
    ...typography.caption,
    color: '#DCE7FF',
    fontSize: 10,
    fontWeight: '700',
    letterSpacing: 0.3,
    textTransform: 'uppercase',
  },
  metricValue: {
    ...typography.subheading,
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: '700',
  },
  balanceTag: {
    alignSelf: 'flex-start',
    backgroundColor: 'rgba(7, 18, 48, 0.35)',
    borderRadius: radius.full,
    paddingHorizontal: spacing.xs,
    paddingVertical: 2,
  },
  balanceTagText: {
    ...typography.caption,
    color: '#FFFFFF',
    fontSize: 10,
    fontWeight: '700',
  },
  sectionWrap: {
    gap: spacing.xs,
  },
  sectionTitle: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  sectionHeader: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  memberItemWrap: {
    marginRight: spacing.xs,
  },
  separator: {
    height: spacing.xs,
  },
  actionRow: {
    borderTopWidth: 1,
    flexDirection: 'row',
    gap: spacing.sm,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
    paddingBottom: spacing.md,
  },
  outlineButton: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flex: 1,
    justifyContent: 'center',
    minHeight: 46,
    paddingHorizontal: spacing.md,
  },
  outlineLabel: {
    ...typography.subheading,
    fontSize: 14,
    fontWeight: '700',
  },
  buttonInner: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    justifyContent: 'center',
  },
  primaryButton: {
    alignItems: 'center',
    borderRadius: radius.md,
    flex: 1,
    justifyContent: 'center',
    minHeight: 46,
    paddingHorizontal: spacing.md,
  },
  primaryLabel: {
    ...typography.subheading,
    fontSize: 14,
    fontWeight: '700',
  },
  emptyCard: {
    alignItems: 'center',
    gap: spacing.xs,
  },
  helperText: {
    ...typography.body,
  },
  loadingCard: {
    alignItems: 'center',
    gap: spacing.sm,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
    fontWeight: '700',
  },
  errorText: {
    ...typography.body,
  },
  retryButton: {
    alignItems: 'center',
    borderRadius: radius.md,
    justifyContent: 'center',
    minHeight: 44,
  },
  retryLabel: {
    ...typography.subheading,
    color: '#FFFFFF',
    fontSize: 14,
    fontWeight: '700',
  },
  retryInner: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    justifyContent: 'center',
  },
  buttonPressed: {
    opacity: 0.86,
  },
});

===== FILE: apps/mobile/src/features/groups/screens/GroupsScreen.tsx =====
import { FlatList, Pressable, StyleSheet, Text, View } from 'react-native';

import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useQuery } from '@tanstack/react-query';

import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { useAuth } from '@app/providers/AuthProvider';
import { AppIcon, Card, Chip, PrimaryButton, ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { TransactionsStackParamList } from '@core/navigation/stacks/TransactionsStack';
import { spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

function GroupsLoadingSkeleton({ dark }: { dark: boolean }) {
  const block = dark ? '#171C2B' : '#E8EDF7';

  return (
    <View style={styles.skeletonWrap}>
      <View style={[styles.skeletonTitle, { backgroundColor: block }]} />
      <View style={[styles.skeletonSubtitle, { backgroundColor: block }]} />
      <View style={[styles.skeletonButton, { backgroundColor: block }]} />
      <View style={[styles.skeletonCard, { backgroundColor: block }]} />
      <View style={[styles.skeletonCard, { backgroundColor: block }]} />
      <View style={[styles.skeletonCard, { backgroundColor: block }]} />
    </View>
  );
}

export function GroupsScreen() {
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();
  const { t } = useI18n();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();

  const groupsQuery = useQuery({
    queryKey: financeQueryKeys.groups.list(),
    queryFn: () => withAuth((token) => apiClient.getGroups(token)),
  });

  const groups = groupsQuery.data?.groups ?? [];

  if (groupsQuery.isLoading) {
    return (
      <ScreenContainer dark={mode === 'dark'} scrollable={false} contentStyle={styles.containerContent}>
        <GroupsLoadingSkeleton dark={mode === 'dark'} />
        <Text style={[styles.loadingText, { color: theme.colors.textMuted }]}>{t('groups.list.loading')}</Text>
      </ScreenContainer>
    );
  }

  if (groupsQuery.isError) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.feedbackCard}>
          <AppIcon name="alert-circle-outline" size="lg" tone="expense" />
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>{t('groups.list.errorTitle')}</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(groupsQuery.error)}</Text>
          <PrimaryButton iconName="refresh" label={t('common.retry')} onPress={() => void groupsQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  return (
    <ScreenContainer dark={mode === 'dark'} scrollable={false} contentStyle={styles.containerContent}>
      <FlatList
        contentContainerStyle={styles.content}
        data={groups}
        keyExtractor={(item) => item.id}
        ListHeaderComponent={
          <View style={styles.header}>
            <View style={styles.titleRow}>
              <AppIcon name="people-outline" size="md" tone="primary" />
              <Text numberOfLines={1} style={[styles.title, { color: theme.colors.text }]}>
                {t('groups.list.title')}
              </Text>
            </View>
            <Text numberOfLines={2} style={[styles.subtitle, { color: theme.colors.textMuted }]}>
              {t('groups.list.subtitle')}
            </Text>
            <PrimaryButton
              iconName="add-circle-outline"
              label={t('groups.list.createButton')}
              onPress={() => navigation.navigate('CreateGroup')}
            />
          </View>
        }
        ListEmptyComponent={
          <Card dark={mode === 'dark'} style={styles.feedbackCard}>
            <AppIcon name="people-circle-outline" size="lg" tone="muted" />
            <Text style={[styles.helperText, { color: theme.colors.textMuted }]}>{t('groups.list.empty')}</Text>
          </Card>
        }
        ItemSeparatorComponent={() => <View style={styles.separator} />}
        renderItem={({ item }) => (
          <Pressable
            accessibilityRole="button"
            onPress={() => navigation.navigate('GroupDetail', { groupId: item.id })}
          >
            <Card dark={mode === 'dark'} style={styles.groupCard}>
              <View style={styles.groupNameRow}>
                <AppIcon name="people" size="sm" tone="primary" />
                <Text numberOfLines={1} style={[styles.groupName, { color: theme.colors.text }]}>
                  {item.name}
                </Text>
              </View>
              <View style={styles.memberRow}>
                {item.members.slice(0, 4).map((member) => (
                  <Chip key={member.id} label={member.name} dark={mode === 'dark'} />
                ))}
              </View>
              <Text numberOfLines={1} style={[styles.memberCount, { color: theme.colors.textMuted }]}>
                {t('groups.list.memberCount', { count: item.members.length })}
              </Text>
            </Card>
          </Pressable>
        )}
        showsVerticalScrollIndicator={false}
      />
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    gap: 0,
    paddingBottom: 0,
    paddingHorizontal: 0,
    paddingTop: 0,
  },
  content: {
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
    paddingBottom: spacing.xl,
    gap: spacing.sm,
  },
  header: {
    gap: spacing.sm,
    marginBottom: spacing.sm,
  },
  titleRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    minWidth: 0,
  },
  title: {
    ...typography.heading,
    fontSize: 24,
    flexShrink: 1,
  },
  subtitle: {
    ...typography.body,
    lineHeight: 20,
  },
  groupCard: {
    gap: spacing.xs,
  },
  groupNameRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    minWidth: 0,
  },
  groupName: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
    flex: 1,
    minWidth: 0,
  },
  memberRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  memberCount: {
    ...typography.caption,
    fontSize: 12,
  },
  separator: {
    height: spacing.sm,
  },
  feedbackCard: {
    alignItems: 'center',
    gap: spacing.xs,
  },
  helperText: {
    ...typography.body,
    textAlign: 'center',
  },
  loadingText: {
    ...typography.body,
    textAlign: 'center',
  },
  errorTitle: {
    ...typography.subheading,
    fontWeight: '700',
    textAlign: 'center',
  },
  errorText: {
    ...typography.body,
    textAlign: 'center',
  },
  skeletonWrap: {
    gap: spacing.sm,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
  },
  skeletonTitle: {
    borderRadius: 10,
    height: 34,
    width: '52%',
  },
  skeletonSubtitle: {
    borderRadius: 10,
    height: 20,
    width: '78%',
  },
  skeletonButton: {
    borderRadius: 12,
    height: 48,
    width: '100%',
  },
  skeletonCard: {
    borderRadius: 14,
    height: 112,
    width: '100%',
  },
});

===== FILE: apps/mobile/src/features/groups/screens/SettleUpScreen.tsx =====
import { Alert, StyleSheet, Text, View } from 'react-native';

import { useNavigation, useRoute } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import type { RouteProp } from '@react-navigation/native';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';

import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { useAuth } from '@app/providers/AuthProvider';
import { AppIcon, Card, PrimaryButton, ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { TransactionsStackParamList } from '@core/navigation/stacks/TransactionsStack';
import { spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

function formatMoney(amount: number, currency: string, locale: string): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

export function SettleUpScreen() {
  const route = useRoute<RouteProp<TransactionsStackParamList, 'SettleUp'>>();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const queryClient = useQueryClient();
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();
  const { locale, t } = useI18n();

  const expensesQuery = useQuery({
    queryKey: financeQueryKeys.groups.expenses(route.params.groupId),
    queryFn: () => withAuth((token) => apiClient.getGroupExpenses(route.params.groupId, token)),
  });

  const settleMutation = useMutation({
    mutationFn: () => withAuth((token) => apiClient.settleGroup(route.params.groupId, token)),
    onSuccess: async (response) => {
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.expenses(route.params.groupId) }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.detail(route.params.groupId) }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.list() }),
      ]);

      Alert.alert(
        t('groups.settle.successTitle'),
        t('groups.settle.successMessage', { count: response.settledCount }),
      );
      navigation.goBack();
    },
    onError: (error) => {
      Alert.alert(t('groups.settle.errorTitle'), apiErrorText(error));
    },
  });

  if (expensesQuery.isLoading) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.feedbackCard}>
          <AppIcon name="time-outline" size="lg" tone="primary" />
          <Text style={[styles.helperText, { color: theme.colors.textMuted }]}>{t('groups.settle.loading')}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (expensesQuery.isError || !expensesQuery.data) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.feedbackCard}>
          <AppIcon name="alert-circle-outline" size="lg" tone="expense" />
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>{t('groups.settle.loadErrorTitle')}</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(expensesQuery.error)}</Text>
          <PrimaryButton iconName="refresh" label={t('common.retry')} onPress={() => void expensesQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  const unsettled = expensesQuery.data.expenses.filter((expense) => !expense.settledAt);
  const unsettledTotal = unsettled.reduce((sum, expense) => sum + expense.amount, 0);
  const currency = unsettled[0]?.currency ?? 'TRY';

  return (
    <ScreenContainer dark={mode === 'dark'}>
      <View style={styles.container}>
        <Card dark={mode === 'dark'} style={styles.card}>
          <View style={styles.headerRow}>
            <AppIcon name="wallet-outline" size="md" tone="primary" />
            <Text style={[styles.title, { color: theme.colors.text }]}>{t('groups.settle.title')}</Text>
          </View>
          <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}>{t('groups.settle.subtitle')}</Text>

          <View style={styles.summaryRow}>
            <Text style={[styles.summaryLabel, { color: theme.colors.textMuted }]}>{t('groups.settle.openExpenses')}</Text>
            <Text style={[styles.summaryValue, { color: theme.colors.text }]}>{String(unsettled.length)}</Text>
          </View>

          <View style={styles.summaryRow}>
            <Text style={[styles.summaryLabel, { color: theme.colors.textMuted }]}>{t('groups.settle.openAmount')}</Text>
            <Text style={[styles.summaryValue, { color: theme.colors.text }]}> 
              {formatMoney(unsettledTotal, currency, locale)}
            </Text>
          </View>

          <PrimaryButton
            iconName={settleMutation.isPending ? 'hourglass-outline' : 'checkmark-circle-outline'}
            disabled={settleMutation.isPending || unsettled.length === 0}
            label={settleMutation.isPending ? t('groups.settle.actions.settling') : t('groups.settle.actions.markSettled')}
            onPress={() => settleMutation.mutate()}
          />
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  card: {
    gap: spacing.sm,
  },
  headerRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  title: {
    ...typography.heading,
    fontSize: 24,
  },
  subtitle: {
    ...typography.body,
  },
  summaryRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  summaryLabel: {
    ...typography.body,
  },
  summaryValue: {
    ...typography.subheading,
    fontWeight: '700',
  },
  helperText: {
    ...typography.body,
    textAlign: 'center',
  },
  feedbackCard: {
    alignItems: 'center',
    gap: spacing.xs,
  },
  errorTitle: {
    ...typography.subheading,
    fontWeight: '700',
    textAlign: 'center',
  },
  errorText: {
    ...typography.body,
    textAlign: 'center',
  },
});

===== FILE: apps/mobile/src/features/onboarding/index.ts =====
export { OnboardingNavigator } from './screens/OnboardingNavigator';
export { getOnboardingCompleted, setOnboardingCompleted } from './screens/onboardingStorage';

===== FILE: apps/mobile/src/features/onboarding/screens/OnboardingNavigator.tsx =====
import { createContext, useContext, useMemo } from 'react';

import { createNativeStackNavigator } from '@react-navigation/native-stack';

import { createStackOptions } from '@core/navigation/createStackOptions';
import { useTheme } from '@shared/theme';
import { OnboardingStep1Screen } from './OnboardingStep1Screen';
import { OnboardingStep2Screen } from './OnboardingStep2Screen';
import { OnboardingStep3Screen } from './OnboardingStep3Screen';

export type OnboardingStackParamList = {
  OnboardingStep1: undefined;
  OnboardingStep2: undefined;
  OnboardingStep3: undefined;
};

export type OnboardingMode = 'gate' | 'preview';

interface OnboardingNavigatorProps {
  mode?: OnboardingMode;
  onFinished?: () => void;
}

interface OnboardingFlowContextValue {
  mode: OnboardingMode;
  finish: () => void;
}

const Stack = createNativeStackNavigator<OnboardingStackParamList>();
const OnboardingFlowContext = createContext<OnboardingFlowContextValue | null>(null);

export function useOnboardingFlow(): OnboardingFlowContextValue {
  const context = useContext(OnboardingFlowContext);

  if (!context) {
    throw new Error('useOnboardingFlow must be used inside OnboardingNavigator');
  }

  return context;
}

export function OnboardingNavigator({ mode = 'preview', onFinished }: OnboardingNavigatorProps) {
  const { theme } = useTheme();

  const contextValue = useMemo<OnboardingFlowContextValue>(
    () => ({
      mode,
      finish: () => {
        onFinished?.();
      },
    }),
    [mode, onFinished],
  );

  return (
    <OnboardingFlowContext.Provider value={contextValue}>
      <Stack.Navigator
        initialRouteName="OnboardingStep1"
        screenOptions={{
          ...createStackOptions(theme),
          headerShown: false,
          animation: 'slide_from_right',
        }}
      >
        <Stack.Screen name="OnboardingStep1" component={OnboardingStep1Screen} />
        <Stack.Screen name="OnboardingStep2" component={OnboardingStep2Screen} />
        <Stack.Screen name="OnboardingStep3" component={OnboardingStep3Screen} />
      </Stack.Navigator>
    </OnboardingFlowContext.Provider>
  );
}

===== FILE: apps/mobile/src/features/onboarding/screens/OnboardingStep1Screen.tsx =====
import type { NativeStackScreenProps } from '@react-navigation/native-stack';

import { useI18n } from '@shared/i18n';
import { OnboardingStepFrame } from './OnboardingStepFrame';
import { useOnboardingFlow, type OnboardingStackParamList } from './OnboardingNavigator';

type Props = NativeStackScreenProps<OnboardingStackParamList, 'OnboardingStep1'>;

export function OnboardingStep1Screen({ navigation }: Props) {
  const { finish } = useOnboardingFlow();
  const { t } = useI18n();

  return (
    <OnboardingStepFrame
      step={1}
      title={t('onboarding.step1.title')}
      subtitle={t('onboarding.step1.subtitle')}
      illustrationIcon="💳"
      actionLabel={t('onboarding.next')}
      onActionPress={() => navigation.navigate('OnboardingStep2')}
      onSkipPress={finish}
    />
  );
}

===== FILE: apps/mobile/src/features/onboarding/screens/OnboardingStep2Screen.tsx =====
import type { NativeStackScreenProps } from '@react-navigation/native-stack';

import { useI18n } from '@shared/i18n';
import { OnboardingStepFrame } from './OnboardingStepFrame';
import { useOnboardingFlow, type OnboardingStackParamList } from './OnboardingNavigator';

type Props = NativeStackScreenProps<OnboardingStackParamList, 'OnboardingStep2'>;

export function OnboardingStep2Screen({ navigation }: Props) {
  const { finish } = useOnboardingFlow();
  const { t } = useI18n();

  return (
    <OnboardingStepFrame
      step={2}
      title={t('onboarding.step2.title')}
      subtitle={t('onboarding.step2.subtitle')}
      illustrationIcon="📊"
      actionLabel={t('onboarding.next')}
      onActionPress={() => navigation.navigate('OnboardingStep3')}
      onSkipPress={finish}
    />
  );
}

===== FILE: apps/mobile/src/features/onboarding/screens/OnboardingStep3Screen.tsx =====
import type { NativeStackScreenProps } from '@react-navigation/native-stack';

import { useI18n } from '@shared/i18n';
import { OnboardingStepFrame } from './OnboardingStepFrame';
import { useOnboardingFlow, type OnboardingStackParamList } from './OnboardingNavigator';

type Props = NativeStackScreenProps<OnboardingStackParamList, 'OnboardingStep3'>;

export function OnboardingStep3Screen(_: Props) {
  const { finish, mode } = useOnboardingFlow();
  const { t } = useI18n();

  return (
    <OnboardingStepFrame
      step={3}
      title={mode === 'gate' ? t('onboarding.step3.titleGate') : t('onboarding.step3.titlePreview')}
      subtitle={t('onboarding.step3.subtitle')}
      illustrationIcon="✨"
      actionLabel={t('onboarding.getStarted')}
      onActionPress={finish}
      onSkipPress={undefined}
    />
  );
}

===== FILE: apps/mobile/src/features/onboarding/screens/OnboardingStepFrame.tsx =====
import { Pressable, StyleSheet, Text, View } from 'react-native';

import { ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import { radius, spacing, typography, useTheme } from '@shared/theme';

interface OnboardingStepFrameProps {
  step: 1 | 2 | 3;
  title: string;
  subtitle: string;
  illustrationIcon: string;
  actionLabel: string;
  onActionPress: () => void;
  onSkipPress?: () => void;
}

export function OnboardingStepFrame({
  step,
  title,
  subtitle,
  illustrationIcon,
  actionLabel,
  onActionPress,
  onSkipPress,
}: OnboardingStepFrameProps) {
  const { theme, mode } = useTheme();
  const { t } = useI18n();
  const dark = mode === 'dark';

  return (
    <ScreenContainer dark={dark} scrollable={false} contentStyle={styles.containerContent}>
      <View style={styles.screen}>
        <View style={styles.topRow}>
          <View
            style={[
              styles.stepPill,
              {
                backgroundColor: dark
                  ? withAlpha(theme.colors.primary, 0.24)
                  : withAlpha(theme.colors.primary, 0.12),
                borderColor: dark
                  ? withAlpha(theme.colors.primary, 0.42)
                  : withAlpha(theme.colors.primary, 0.24),
              },
            ]}
          >
            <Text style={[styles.stepPillText, { color: theme.colors.primary }]}>
              {t('onboarding.stepLabel', { current: step, total: 3 })}
            </Text>
          </View>

          {onSkipPress ? (
            <Pressable
              accessibilityRole="button"
              onPress={onSkipPress}
              style={({ pressed }) => [styles.skipButton, pressed && styles.pressed]}
            >
              <Text style={[styles.skipText, { color: theme.colors.textMuted }]}>{t('onboarding.skip')}</Text>
            </Pressable>
          ) : (
            <View style={styles.skipPlaceholder} />
          )}
        </View>

        <View
          style={[
            styles.heroCard,
            {
              backgroundColor: dark ? theme.colors.cardBackground : theme.colors.surface,
              borderColor: theme.colors.cardBorder,
              shadowColor: theme.shadows.card.shadowColor,
              shadowOpacity: dark ? 0.34 : theme.shadows.card.shadowOpacity,
              shadowRadius: dark ? 20 : theme.shadows.card.shadowRadius,
              shadowOffset: dark ? { width: 0, height: 12 } : theme.shadows.card.shadowOffset,
              elevation: dark ? 10 : theme.shadows.card.elevation,
            },
          ]}
        >
          <View pointerEvents="none" style={styles.illustrationWrap}>
            <View
              style={[
                styles.glowA,
                { backgroundColor: dark ? theme.colors.authGlowTop : withAlpha(theme.colors.primary, 0.18) },
              ]}
            />
            <View
              style={[
                styles.glowB,
                { backgroundColor: dark ? theme.colors.authGlowBottom : withAlpha(theme.colors.primary, 0.12) },
              ]}
            />
          </View>

          <View style={[styles.iconBadge, { backgroundColor: theme.colors.primary }]}>
            <Text style={styles.iconBadgeText}>{illustrationIcon}</Text>
          </View>

          <Text style={[styles.title, { color: theme.colors.text }]}>{title}</Text>
          <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}>{subtitle}</Text>
        </View>

        <View style={styles.dotRow}>
          {[1, 2, 3].map((index) => (
            <View
              key={`dot-${index}`}
              style={[
                styles.dot,
                index === step
                  ? { backgroundColor: theme.colors.primary, width: 22 }
                  : { backgroundColor: withAlpha(theme.colors.textMuted, dark ? 0.5 : 0.35), width: 8 },
              ]}
            />
          ))}
        </View>

        <Pressable
          accessibilityRole="button"
          onPress={onActionPress}
          style={({ pressed }) => [
            styles.primaryButton,
            { backgroundColor: theme.colors.buttonPrimaryBackground },
            pressed && styles.pressed,
          ]}
        >
          <Text style={[styles.primaryButtonText, { color: theme.colors.buttonPrimaryText }]}>{actionLabel}</Text>
        </Pressable>
      </View>
    </ScreenContainer>
  );
}

function withAlpha(hexColor: string, alpha: number): string {
  const color = hexColor.trim();
  const hex = color.startsWith('#') ? color.slice(1) : color;

  if (!/^[0-9a-fA-F]{6}$/.test(hex)) {
    return color;
  }

  const red = Number.parseInt(hex.slice(0, 2), 16);
  const green = Number.parseInt(hex.slice(2, 4), 16);
  const blue = Number.parseInt(hex.slice(4, 6), 16);
  return `rgba(${red}, ${green}, ${blue}, ${Math.max(0, Math.min(alpha, 1))})`;
}

const styles = StyleSheet.create({
  containerContent: {
    flexGrow: 1,
  },
  screen: {
    flex: 1,
    justifyContent: 'space-between',
    gap: spacing.lg,
  },
  topRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
    minHeight: 34,
  },
  stepPill: {
    borderRadius: radius.full,
    borderWidth: 1,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xxs,
  },
  stepPillText: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 0.5,
    textTransform: 'uppercase',
  },
  skipButton: {
    borderRadius: radius.full,
    minHeight: 34,
    justifyContent: 'center',
    paddingHorizontal: spacing.sm,
  },
  skipText: {
    ...typography.body,
    fontWeight: '600',
  },
  skipPlaceholder: {
    width: 54,
  },
  heroCard: {
    alignItems: 'center',
    borderRadius: radius.xl,
    borderWidth: 1,
    gap: spacing.sm,
    overflow: 'hidden',
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.xl,
    position: 'relative',
  },
  illustrationWrap: {
    ...StyleSheet.absoluteFillObject,
  },
  glowA: {
    borderRadius: 160,
    height: 220,
    position: 'absolute',
    right: -80,
    top: -90,
    width: 220,
  },
  glowB: {
    borderRadius: 180,
    bottom: -120,
    height: 240,
    left: -120,
    position: 'absolute',
    width: 240,
  },
  iconBadge: {
    alignItems: 'center',
    borderRadius: radius.full,
    height: 68,
    justifyContent: 'center',
    marginBottom: spacing.xs,
    width: 68,
  },
  iconBadgeText: {
    fontSize: 30,
  },
  title: {
    ...typography.title,
    fontSize: 32,
    lineHeight: 38,
    textAlign: 'center',
  },
  subtitle: {
    ...typography.body,
    fontSize: 16,
    lineHeight: 24,
    maxWidth: 320,
    textAlign: 'center',
  },
  dotRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    justifyContent: 'center',
  },
  dot: {
    borderRadius: radius.full,
    height: 8,
  },
  primaryButton: {
    alignItems: 'center',
    borderRadius: radius.lg,
    minHeight: 54,
    justifyContent: 'center',
    paddingHorizontal: spacing.lg,
  },
  primaryButtonText: {
    ...typography.subheading,
    fontSize: 17,
    fontWeight: '700',
  },
  pressed: {
    opacity: 0.86,
  },
});

===== FILE: apps/mobile/src/features/onboarding/screens/onboardingStorage.ts =====
import * as SecureStore from 'expo-secure-store';

const ONBOARDING_COMPLETED_KEY = 'finsight:onboarding-completed';

export async function getOnboardingCompleted(): Promise<boolean> {
  try {
    return (await SecureStore.getItemAsync(ONBOARDING_COMPLETED_KEY)) === 'true';
  } catch {
    return false;
  }
}

export async function setOnboardingCompleted(completed: boolean): Promise<void> {
  try {
    if (completed) {
      await SecureStore.setItemAsync(ONBOARDING_COMPLETED_KEY, 'true');
      return;
    }

    await SecureStore.deleteItemAsync(ONBOARDING_COMPLETED_KEY);
  } catch {
    // Keep onboarding flow non-blocking even if local persistence fails.
  }
}


===== FILE: apps/mobile/src/features/profile/index.ts =====
export { ProfileScreen } from './screens/ProfileScreen';
export { EditProfileScreen } from './screens/EditProfileScreen';
export { SettingsScreen } from './screens/SettingsScreen';
export { SecurityScreen } from './screens/SecurityScreen';
export { AboutScreen } from './screens/AboutScreen';

===== FILE: apps/mobile/src/features/profile/screens/AboutScreen.tsx =====
import { StyleSheet, Text, View } from 'react-native';

import { Card, ScreenContainer, Section } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import { spacing, typography, useTheme } from '@shared/theme';

export function AboutScreen() {
  const { theme } = useTheme();
  const { t } = useI18n();

  return (
    <ScreenContainer>
      <Section title={t('profile.about.title')} subtitle={t('profile.about.subtitle')}>
        <Card style={styles.card}>
          <InfoRow label={t('profile.about.appNameLabel')} value={t('common.appName')} />
          <InfoRow label={t('profile.about.versionLabel')} value={t('profile.about.versionValue')} />
          <InfoRow label={t('profile.about.buildLabel')} value={t('profile.about.buildValue')} />
        </Card>
      </Section>

      <Section title={t('profile.about.notesTitle')}>
        <Card style={styles.card}>
          <Text style={[styles.note, { color: theme.colors.textMuted }]}>
            {t('profile.about.noteOne')}
          </Text>
          <Text style={[styles.note, { color: theme.colors.textMuted }]}>
            {t('profile.about.noteTwo')}
          </Text>
        </Card>
      </Section>
    </ScreenContainer>
  );
}

function InfoRow({ label, value }: { label: string; value: string }) {
  const { theme } = useTheme();

  return (
    <View style={styles.infoRow}>
      <Text style={[styles.infoLabel, { color: theme.colors.textMuted }]}>{label}</Text>
      <Text style={[styles.infoValue, { color: theme.colors.text }]}>{value}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    gap: spacing.sm,
  },
  infoRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    gap: spacing.md,
  },
  infoLabel: {
    ...typography.caption,
  },
  infoValue: {
    ...typography.body,
    fontWeight: '600',
  },
  note: {
    ...typography.body,
  },
});

===== FILE: apps/mobile/src/features/profile/screens/EditProfileScreen.tsx =====
import { useEffect, useMemo, useState } from 'react';
import { Pressable, StyleSheet, Text, View } from 'react-native';

import { useAuth } from '@app/providers/AuthProvider';
import { Card, PrimaryButton, ScreenContainer, TextField } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import { radius, spacing, typography, useTheme } from '@shared/theme';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/profil_düzenle_(dark)/screen.png
// no touch/keyboard behavior changed by this PR.

export function EditProfileScreen() {
  const { user, clearAuthError } = useAuth();
  const { theme, mode } = useTheme();
  const { t } = useI18n();

  const [name, setName] = useState(user?.name ?? '');
  const [isSaving, setIsSaving] = useState(false);
  const [nameError, setNameError] = useState<string | null>(null);
  const [message, setMessage] = useState<string | null>(null);

  useEffect(() => {
    setName(user?.name ?? '');
  }, [user?.name]);

  const helperText = useMemo(() => {
    if (message) {
      return t('profile.edit.updateNotAvailableCode');
    }

    return t('profile.edit.helper');
  }, [message, t]);

  const onSave = async () => {
    clearAuthError();
    setMessage(null);

    if (!name.trim()) {
      setNameError(t('auth.validation.nameRequired'));
      return;
    }

    setNameError(null);
    setIsSaving(true);

    setTimeout(() => {
      setIsSaving(false);
      setMessage('PROFILE_UPDATE_NOT_AVAILABLE');
    }, 350);
  };

  const dark = mode === 'dark';
  const panelBg = dark ? '#15192A' : '#FFFFFF';
  const panelBorder = dark ? '#2A2D42' : '#E4EAF5';

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.container}>
        <Card
          dark={dark}
          style={[
            styles.avatarCard,
            {
              borderColor: panelBorder,
              backgroundColor: panelBg,
            },
          ]}
        >
          <View style={styles.avatarWrap}>
            <View style={[styles.avatar, { backgroundColor: dark ? '#242B42' : '#EAF1FF' }]}>
              <Text style={[styles.avatarInitial, { color: theme.colors.primary }]}> 
                {(user?.name?.trim() || user?.email || 'F').charAt(0).toUpperCase()}
              </Text>
            </View>
            <Pressable
              accessibilityRole="button"
              style={[styles.cameraBadge, { backgroundColor: theme.colors.primary }]}
            >
              <Text style={styles.cameraText}>📷</Text>
            </Pressable>
          </View>

          <Text style={[styles.avatarTitle, { color: theme.colors.text }]}>{t('profile.edit.photoTitle')}</Text>
          <Text style={[styles.avatarSubtitle, { color: theme.colors.textMuted }]}>{t('profile.edit.photoSubtitle')}</Text>
        </Card>

        <Card
          dark={dark}
          style={[
            styles.formCard,
            {
              borderColor: panelBorder,
              backgroundColor: panelBg,
            },
          ]}
        >
          <TextField
            autoCapitalize="words"
            autoComplete="name"
            error={nameError}
            label={t('profile.edit.fullNameLabel')}
            onChangeText={(value) => {
              setName(value);
              setNameError(null);
            }}
            placeholder={t('profile.edit.fullNamePlaceholder')}
            textContentType="name"
            value={name}
          />

          <TextField
            autoCapitalize="none"
            autoComplete="email"
            editable={false}
            label={t('profile.edit.emailLabel')}
            onChangeText={() => {}}
            placeholder="-"
            textContentType="emailAddress"
            value={user?.email ?? '-'}
          />

          <TextField
            autoCapitalize="characters"
            autoComplete="off"
            editable={false}
            label={t('profile.edit.baseCurrencyLabel')}
            onChangeText={() => {}}
            placeholder="-"
            value={user?.baseCurrency ?? '-'}
          />

          <PrimaryButton
            disabled={isSaving}
            label={isSaving ? t('common.saving') : t('profile.edit.save')}
            onPress={() => {
              void onSave();
            }}
          />

          <Text
            style={[
              styles.helperText,
              { color: message ? theme.colors.expense : theme.colors.textMuted },
            ]}
          >
            {helperText}
          </Text>
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  avatarCard: {
    alignItems: 'center',
    gap: spacing.xxs,
  },
  avatarWrap: {
    marginBottom: spacing.xs,
    position: 'relative',
  },
  avatar: {
    alignItems: 'center',
    borderRadius: radius.full,
    height: 96,
    justifyContent: 'center',
    width: 96,
  },
  avatarInitial: {
    ...typography.heading,
    fontSize: 34,
    fontWeight: '700',
  },
  cameraBadge: {
    alignItems: 'center',
    borderRadius: radius.full,
    bottom: 0,
    height: 30,
    justifyContent: 'center',
    position: 'absolute',
    right: 0,
    width: 30,
  },
  cameraText: {
    color: '#FFFFFF',
    fontSize: 13,
  },
  avatarTitle: {
    ...typography.subheading,
    fontWeight: '700',
  },
  avatarSubtitle: {
    ...typography.caption,
    fontSize: 12,
  },
  formCard: {
    gap: spacing.md,
  },
  helperText: {
    ...typography.caption,
    fontSize: 12,
    lineHeight: 18,
  },
});

===== FILE: apps/mobile/src/features/profile/screens/ProfileScreen.tsx =====
import { useMemo, useState } from 'react';
import { ActivityIndicator, Pressable, StyleSheet, Text, View } from 'react-native';

import { useNavigation } from '@react-navigation/native';
import { useQuery } from '@tanstack/react-query';

import { apiClient } from '@core/api/client';
import { financeQueryKeys } from '@core/api/queryKeys';
import { useAuth } from '@app/providers/AuthProvider';
import { AppIcon, Card, ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { RootTabParamList } from '@core/navigation/types';
import { radius, spacing, typography, useTheme } from '@shared/theme';
import { apiErrorText } from '@shared/utils/apiErrorText';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/profil_(dark)_2/screen.png
// no touch/keyboard behavior changed by this PR.

function formatSync(value: Date): string {
  return value.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

export function ProfileScreen() {
  const navigation = useNavigation<any>();
  const { withAuth, user, logout } = useAuth();
  const { theme, mode } = useTheme();
  const { t } = useI18n();
  const [isLoggingOut, setIsLoggingOut] = useState(false);

  const accountsQuery = useQuery({
    queryKey: financeQueryKeys.accounts.list(),
    queryFn: () => withAuth((token) => apiClient.getAccounts(token)),
  });

  const displayName = user?.name?.trim() || t('profile.defaultUserName');
  const displayEmail = user?.email ?? t('common.notAvailable');
  const accountCount = accountsQuery.data?.accounts.length ?? 0;
  const lastSyncLabel = useMemo(() => formatSync(new Date()), []);

  const dark = mode === 'dark';

  const handleLogout = async () => {
    if (isLoggingOut) {
      return;
    }

    setIsLoggingOut(true);
    await logout();
    setIsLoggingOut(false);
  };

  const goToAnalyticsScreen = (screen: 'AiAdvisor' | 'WeeklyReport') => {
    const parent = navigation.getParent?.();
    const root = parent?.getParent?.();
    const target = (root ?? parent ?? navigation) as {
      navigate: (
        routeName: keyof RootTabParamList,
        params?: RootTabParamList['AnalyticsTab'],
      ) => void;
    };

    target.navigate('AnalyticsTab', { screen });
  };

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.container}>
        <Card
          dark={dark}
          style={[
            styles.profileCard,
            {
              borderColor: dark ? '#2A2D42' : '#E4EAF5',
              backgroundColor: dark ? '#15192A' : '#FFFFFF',
            },
          ]}
        >
          <View style={styles.avatarWrap}>
            <View style={[styles.avatar, { backgroundColor: dark ? '#242B42' : '#EAF1FF' }]}>
              <Text style={[styles.avatarInitial, { color: theme.colors.primary }]}>
                {displayName.charAt(0).toUpperCase()}
              </Text>
            </View>
            <View style={styles.verifiedChip}>
              <Text style={styles.verifiedDot}>✓</Text>
            </View>
          </View>

          <Text style={[styles.name, { color: theme.colors.text }]}>{displayName}</Text>
          <Text style={[styles.email, { color: theme.colors.textMuted }]}>{displayEmail}</Text>

          <View
            style={[
              styles.premiumPill,
              { backgroundColor: dark ? 'rgba(66,17,212,0.22)' : 'rgba(47,107,255,0.12)' },
            ]}
          >
            <Text style={[styles.premiumText, { color: theme.colors.primary }]}>{t('profile.premiumMember')}</Text>
          </View>
        </Card>

        <Card
          dark={dark}
          style={[
            styles.statsCard,
            {
              borderColor: dark ? '#2A2D42' : '#E4EAF5',
              backgroundColor: dark ? '#15192A' : '#FFFFFF',
            },
          ]}
        >
          <View style={styles.statItem}>
            <Text style={[styles.statLabel, { color: theme.colors.textMuted }]}>{t('profile.baseCurrency')}</Text>
            <Text style={[styles.statValue, { color: theme.colors.text }]}>{user?.baseCurrency ?? t('common.notAvailable')}</Text>
          </View>
          <View style={[styles.statsDivider, { backgroundColor: dark ? '#2A2D42' : '#E4EAF5' }]} />
          <View style={styles.statItem}>
            <Text style={[styles.statLabel, { color: theme.colors.textMuted }]}>{t('profile.accounts')}</Text>
            <Text style={[styles.statValue, { color: theme.colors.text }]}>
              {accountsQuery.isLoading ? t('common.loadingShort') : String(accountCount)}
            </Text>
          </View>
          <View style={[styles.statsDivider, { backgroundColor: dark ? '#2A2D42' : '#E4EAF5' }]} />
          <View style={styles.statItem}>
            <Text style={[styles.statLabel, { color: theme.colors.textMuted }]}>{t('profile.lastSync')}</Text>
            <Text style={[styles.statValue, { color: theme.colors.text }]}>{lastSyncLabel}</Text>
          </View>
        </Card>

        {accountsQuery.isError ? (
          <Text style={[styles.queryError, { color: theme.colors.expense }]}>{apiErrorText(accountsQuery.error)}</Text>
        ) : null}

        <View style={styles.sectionHeader}>
          <AppIcon name="settings-outline" size="sm" tone="muted" />
          <Text style={[styles.sectionTitle, { color: theme.colors.textMuted }]}>{t('profile.accountSettings')}</Text>
        </View>
        <Card
          dark={dark}
          style={[
            styles.listCard,
            {
              borderColor: dark ? '#2A2D42' : '#E4EAF5',
              backgroundColor: dark ? '#15192A' : '#FFFFFF',
            },
          ]}
        >
          <SettingsRow iconName="person-circle-outline" label={t('profile.rows.personalInfo')} subtitle={t('profile.rows.personalInfoSubtitle')} onPress={() => navigation.navigate('EditProfile')} />
          <Divider />
          <SettingsRow iconName="wallet-outline" label={t('profile.rows.myAccounts')} subtitle={t('profile.rows.myAccountsSubtitle')} onPress={() => navigation.navigate('Accounts')} />
          <Divider />
          <SettingsRow iconName="settings-outline" label={t('profile.rows.appSettings')} subtitle={t('profile.rows.appSettingsSubtitle')} onPress={() => navigation.navigate('Settings')} />
          <Divider />
          <SettingsRow iconName="shield-checkmark-outline" label={t('profile.rows.security')} subtitle={t('profile.rows.securitySubtitle')} onPress={() => navigation.navigate('Security')} />
        </Card>

        <View style={styles.sectionHeader}>
          <AppIcon name="help-buoy-outline" size="sm" tone="muted" />
          <Text style={[styles.sectionTitle, { color: theme.colors.textMuted }]}>{t('profile.support')}</Text>
        </View>
        <Card
          dark={dark}
          style={[
            styles.listCard,
            {
              borderColor: dark ? '#2A2D42' : '#E4EAF5',
              backgroundColor: dark ? '#15192A' : '#FFFFFF',
            },
          ]}
        >
          <SettingsRow iconName="information-circle-outline" label={t('profile.rows.about')} subtitle={t('profile.rows.aboutSubtitle')} onPress={() => navigation.navigate('About')} />
          <Divider />
          <SettingsRow iconName="sparkles-outline" label={t('profile.rows.aiAdvisor')} subtitle={t('profile.rows.aiAdvisorSubtitle')} onPress={() => goToAnalyticsScreen('AiAdvisor')} />
          <Divider />
          <SettingsRow iconName="stats-chart-outline" label={t('profile.rows.weeklyReport')} subtitle={t('profile.rows.weeklyReportSubtitle')} onPress={() => goToAnalyticsScreen('WeeklyReport')} />
          <Divider />
          <Pressable
            accessibilityRole="button"
            disabled={isLoggingOut}
            onPress={() => {
              void handleLogout();
            }}
            style={({ pressed }) => [
              styles.logoutRow,
              {
                backgroundColor: dark ? 'rgba(240,68,56,0.12)' : '#FFF1F1',
                opacity: pressed ? 0.85 : 1,
              },
            ]}
          >
            <View style={[styles.logoutIconWrap, { backgroundColor: dark ? 'rgba(240,68,56,0.2)' : '#FFE3E3' }]}>
              <AppIcon name="log-out-outline" size="sm" tone="expense" />
            </View>
            <View style={styles.rowTextWrap}>
              <Text style={styles.logoutLabel}>{isLoggingOut ? t('profile.loggingOut') : t('profile.logOut')}</Text>
              <Text style={styles.logoutSubtext}>{t('profile.useDifferentAccount')}</Text>
            </View>
          </Pressable>
        </Card>

        {isLoggingOut ? (
          <View style={styles.overlaySpinner}>
            <ActivityIndicator color={theme.colors.primary} size="small" />
          </View>
        ) : null}
      </View>
    </ScreenContainer>
  );
}

function SettingsRow({
  iconName,
  label,
  subtitle,
  onPress,
}: {
  iconName: Parameters<typeof AppIcon>[0]['name'];
  label: string;
  subtitle: string;
  onPress: () => void;
}) {
  const { theme, mode } = useTheme();

  return (
    <Pressable
      accessibilityRole="button"
      onPress={onPress}
      style={({ pressed }) => [styles.row, pressed && styles.rowPressed]}
    >
      <View style={[styles.rowIconWrap, { backgroundColor: mode === 'dark' ? 'rgba(66,17,212,0.18)' : '#ECF2FF' }]}>
        <AppIcon name={iconName} size="sm" tone="primary" />
      </View>
      <View style={styles.rowTextWrap}>
        <Text style={[styles.rowTitle, { color: theme.colors.text }]}>{label}</Text>
        <Text style={[styles.rowSubtitle, { color: theme.colors.textMuted }]}>{subtitle}</Text>
      </View>
      <AppIcon name="chevron-forward" size="sm" tone="muted" />
    </Pressable>
  );
}

function Divider() {
  const { mode } = useTheme();

  return <View style={[styles.divider, { backgroundColor: mode === 'dark' ? '#2A2D42' : '#E4EAF5' }]} />;
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  profileCard: {
    alignItems: 'center',
    gap: spacing.xxs,
  },
  avatarWrap: {
    marginBottom: spacing.xs,
    position: 'relative',
  },
  avatar: {
    alignItems: 'center',
    borderRadius: radius.full,
    height: 92,
    justifyContent: 'center',
    width: 92,
  },
  avatarInitial: {
    ...typography.heading,
    fontSize: 34,
    fontWeight: '700',
  },
  verifiedChip: {
    alignItems: 'center',
    backgroundColor: '#17B26A',
    borderRadius: radius.full,
    bottom: 2,
    height: 24,
    justifyContent: 'center',
    position: 'absolute',
    right: 2,
    width: 24,
  },
  verifiedDot: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: '700',
  },
  name: {
    ...typography.heading,
    fontSize: 24,
    fontWeight: '700',
  },
  email: {
    ...typography.body,
    fontSize: 14,
  },
  premiumPill: {
    borderRadius: radius.full,
    marginTop: spacing.xs,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xxs,
  },
  premiumText: {
    ...typography.caption,
    fontWeight: '700',
    letterSpacing: 0.5,
  },
  statsCard: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
    minHeight: 90,
  },
  statItem: {
    flex: 1,
    gap: spacing.xxs,
  },
  statLabel: {
    ...typography.caption,
    fontSize: 11,
    letterSpacing: 0.5,
    textTransform: 'uppercase',
  },
  statValue: {
    ...typography.subheading,
    fontSize: 15,
    fontWeight: '700',
  },
  statsDivider: {
    height: 38,
    width: 1,
  },
  sectionTitle: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 1,
    marginTop: spacing.xs,
    paddingHorizontal: 0,
  },
  sectionHeader: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    marginTop: spacing.xs,
    paddingHorizontal: spacing.xs,
  },
  listCard: {
    paddingHorizontal: 0,
    paddingVertical: spacing.xs,
  },
  row: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.sm,
    paddingHorizontal: spacing.md,
    paddingVertical: spacing.sm,
  },
  rowPressed: {
    opacity: 0.86,
  },
  rowIconWrap: {
    alignItems: 'center',
    borderRadius: radius.md,
    height: 36,
    justifyContent: 'center',
    width: 36,
  },
  rowTextWrap: {
    flex: 1,
    gap: 2,
  },
  rowTitle: {
    ...typography.body,
    fontWeight: '600',
  },
  rowSubtitle: {
    ...typography.caption,
    fontSize: 11,
  },
  divider: {
    height: 1,
    marginHorizontal: spacing.md,
  },
  logoutRow: {
    alignItems: 'center',
    borderRadius: radius.md,
    flexDirection: 'row',
    gap: spacing.sm,
    marginHorizontal: spacing.md,
    marginTop: spacing.xs,
    minHeight: 54,
    paddingHorizontal: spacing.sm,
  },
  logoutIconWrap: {
    alignItems: 'center',
    borderRadius: radius.md,
    height: 34,
    justifyContent: 'center',
    width: 34,
  },
  logoutLabel: {
    ...typography.body,
    color: '#F04438',
    fontWeight: '700',
  },
  logoutSubtext: {
    ...typography.caption,
    color: '#F97066',
    fontSize: 11,
  },
  queryError: {
    ...typography.caption,
    fontSize: 12,
    paddingHorizontal: spacing.xs,
  },
  overlaySpinner: {
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: spacing.xs,
  },
});

===== FILE: apps/mobile/src/features/profile/screens/SecurityScreen.tsx =====
import { useState } from 'react';
import { Alert, Pressable, StyleSheet, Switch, Text, View } from 'react-native';

import { Card, ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import { radius, spacing, typography, useTheme } from '@shared/theme';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/güvenlik_ve_gizlilik_ayarları/screen.png
// no touch/keyboard behavior changed by this PR.

export function SecurityScreen() {
  const { theme, mode } = useTheme();
  const { t } = useI18n();
  const dark = mode === 'dark';

  const [biometricEnabled, setBiometricEnabled] = useState(true);
  const [twoFactorEnabled, setTwoFactorEnabled] = useState(false);
  const [sharingEnabled, setSharingEnabled] = useState(true);

  const panelBg = dark ? '#15192A' : '#FFFFFF';
  const panelBorder = dark ? '#2A2D42' : '#E4EAF5';

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.container}>
        <Card
          dark={dark}
          style={[
            styles.scoreCard,
            {
              borderColor: dark ? 'rgba(66,17,212,0.35)' : '#DDE8FF',
              backgroundColor: dark ? 'rgba(66,17,212,0.16)' : '#EEF3FF',
            },
          ]}
        >
          <View style={[styles.scoreIconWrap, { backgroundColor: theme.colors.primary }]}>
            <Text style={styles.scoreIcon}>🛡️</Text>
          </View>
          <View style={styles.scoreTextWrap}>
            <Text style={[styles.scoreTitle, { color: theme.colors.text }]}>{t('profile.security.scoreTitle')}</Text>
            <Text style={[styles.scoreSubtitle, { color: theme.colors.textMuted }]}>{t('profile.security.scoreSubtitle')}</Text>
          </View>
        </Card>

        <SectionTitle title={t('profile.security.sections.accessControl')} />
        <Card
          dark={dark}
          style={[
            styles.groupCard,
            {
              borderColor: panelBorder,
              backgroundColor: panelBg,
            },
          ]}
        >
          <ToggleRow
            icon="🧬"
            label={t('profile.security.items.biometric.title')}
            subtitle={t('profile.security.items.biometric.subtitle')}
            value={biometricEnabled}
            onValueChange={setBiometricEnabled}
          />
          <Divider />
          <ToggleRow
            icon="🔐"
            label={t('profile.security.items.twoFactor.title')}
            subtitle={t('profile.security.items.twoFactor.subtitle')}
            value={twoFactorEnabled}
            onValueChange={setTwoFactorEnabled}
          />
          <Divider />
          <ActionRow
            icon="🕘"
            label={t('profile.security.items.accountActivity.title')}
            subtitle={t('profile.security.items.accountActivity.subtitle')}
          />
        </Card>

        <SectionTitle title={t('profile.security.sections.dataPrivacy')} />
        <Card
          dark={dark}
          style={[
            styles.groupCard,
            {
              borderColor: panelBorder,
              backgroundColor: panelBg,
            },
          ]}
        >
          <ToggleRow
            icon="🤝"
            label={t('profile.security.items.thirdParty.title')}
            subtitle={t('profile.security.items.thirdParty.subtitle')}
            value={sharingEnabled}
            onValueChange={setSharingEnabled}
          />
          <Divider />
          <ActionRow
            icon="⬇️"
            label={t('profile.security.items.downloadData.title')}
            subtitle={t('profile.security.items.downloadData.subtitle')}
          />
          <Divider />
          <ActionRow
            icon="📜"
            label={t('profile.security.items.privacyPolicy.title')}
            subtitle={t('profile.security.items.privacyPolicy.subtitle')}
          />
        </Card>

        <SectionTitle title={t('profile.security.sections.dangerZone')} accent />
        <Card
          dark={dark}
          style={[
            styles.dangerCard,
            {
              borderColor: dark ? 'rgba(240,68,56,0.30)' : '#FFD4D2',
              backgroundColor: dark ? 'rgba(240,68,56,0.09)' : '#FFF4F4',
            },
          ]}
        >
          <Pressable
            accessibilityRole="button"
            onPress={() => {
              Alert.alert(t('profile.security.delete.title'), t('profile.security.delete.notAvailable'));
            }}
            style={({ pressed }) => [styles.dangerButton, pressed && styles.dangerPressed]}
          >
            <Text style={styles.dangerButtonText}>{t('profile.security.delete.cta')}</Text>
          </Pressable>
          <Text style={[styles.dangerHint, { color: theme.colors.textMuted }]}>
            {t('profile.security.delete.hint')}
          </Text>
        </Card>
      </View>
    </ScreenContainer>
  );
}

function SectionTitle({ title, accent = false }: { title: string; accent?: boolean }) {
  const { theme } = useTheme();

  return (
    <Text style={[styles.sectionTitle, { color: accent ? '#F04438' : theme.colors.primary }]}>{title}</Text>
  );
}

function ToggleRow({
  icon,
  label,
  subtitle,
  value,
  onValueChange,
}: {
  icon: string;
  label: string;
  subtitle: string;
  value: boolean;
  onValueChange: (next: boolean) => void;
}) {
  const { theme, mode } = useTheme();
  const dark = mode === 'dark';

  return (
    <View style={styles.row}>
      <View style={[styles.iconWrap, { backgroundColor: dark ? 'rgba(66,17,212,0.18)' : '#ECF2FF' }]}>
        <Text style={styles.iconText}>{icon}</Text>
      </View>

      <View style={styles.rowTextWrap}>
        <Text style={[styles.rowTitle, { color: theme.colors.text }]}>{label}</Text>
        <Text style={[styles.rowSubtitle, { color: theme.colors.textMuted }]}>{subtitle}</Text>
      </View>

      <Switch
        trackColor={{ false: dark ? '#3A3F56' : '#CBD5E1', true: dark ? '#3A238A' : '#CAD8FF' }}
        thumbColor={value ? theme.colors.primary : '#E2E8F0'}
        onValueChange={onValueChange}
        value={value}
      />
    </View>
  );
}

function ActionRow({ icon, label, subtitle }: { icon: string; label: string; subtitle: string }) {
  const { theme, mode } = useTheme();
  const dark = mode === 'dark';

  return (
    <Pressable accessibilityRole="button" style={({ pressed }) => [styles.row, pressed && styles.rowPressed]}>
      <View style={[styles.iconWrap, { backgroundColor: dark ? 'rgba(66,17,212,0.18)' : '#ECF2FF' }]}>
        <Text style={styles.iconText}>{icon}</Text>
      </View>

      <View style={styles.rowTextWrap}>
        <Text style={[styles.rowTitle, { color: theme.colors.text }]}>{label}</Text>
        <Text style={[styles.rowSubtitle, { color: theme.colors.textMuted }]}>{subtitle}</Text>
      </View>

      <Text style={[styles.chevron, { color: theme.colors.textMuted }]}>{'>'}</Text>
    </Pressable>
  );
}

function Divider() {
  const { mode } = useTheme();

  return <View style={[styles.divider, { backgroundColor: mode === 'dark' ? '#2A2D42' : '#E4EAF5' }]} />;
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  scoreCard: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.sm,
  },
  scoreIconWrap: {
    alignItems: 'center',
    borderRadius: radius.full,
    height: 44,
    justifyContent: 'center',
    width: 44,
  },
  scoreIcon: {
    fontSize: 18,
  },
  scoreTextWrap: {
    flex: 1,
    gap: spacing.xxs,
  },
  scoreTitle: {
    ...typography.subheading,
    fontWeight: '700',
  },
  scoreSubtitle: {
    ...typography.caption,
    fontSize: 12,
  },
  sectionTitle: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 1,
    paddingHorizontal: spacing.xs,
  },
  groupCard: {
    paddingHorizontal: 0,
    paddingVertical: spacing.xs,
  },
  row: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.sm,
    minHeight: 58,
    paddingHorizontal: spacing.md,
  },
  rowPressed: {
    opacity: 0.86,
  },
  iconWrap: {
    alignItems: 'center',
    borderRadius: radius.md,
    height: 36,
    justifyContent: 'center',
    width: 36,
  },
  iconText: {
    fontSize: 16,
  },
  rowTextWrap: {
    flex: 1,
    gap: 2,
  },
  rowTitle: {
    ...typography.body,
    fontWeight: '600',
  },
  rowSubtitle: {
    ...typography.caption,
    fontSize: 11,
  },
  chevron: {
    ...typography.subheading,
    fontSize: 16,
    fontWeight: '700',
  },
  divider: {
    height: 1,
    marginHorizontal: spacing.md,
  },
  dangerCard: {
    gap: spacing.sm,
  },
  dangerButton: {
    alignItems: 'center',
    borderColor: '#F04438',
    borderRadius: radius.md,
    borderWidth: 1,
    justifyContent: 'center',
    minHeight: 44,
  },
  dangerPressed: {
    opacity: 0.86,
  },
  dangerButtonText: {
    ...typography.caption,
    color: '#F04438',
    fontWeight: '700',
    letterSpacing: 0.3,
  },
  dangerHint: {
    ...typography.caption,
    fontSize: 11,
    textAlign: 'center',
  },
});

===== FILE: apps/mobile/src/features/profile/screens/SettingsScreen.tsx =====
import { useState, type ReactNode } from 'react';
import { Pressable, StyleSheet, Switch, Text, View } from 'react-native';

import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';

import { AppIcon, Card, ScreenContainer } from '@shared/ui';
import { useI18n, type SupportedLocale } from '@shared/i18n';
import type { ProfileStackParamList } from '@core/navigation/stacks/ProfileStack';
import { radius, spacing, typography, useTheme, type ThemePreference } from '@shared/theme';

const themeOptions: ThemePreference[] = ['system', 'light', 'dark'];
const localeOptions: SupportedLocale[] = ['tr', 'en', 'ru'];

export function SettingsScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<ProfileStackParamList>>();
  const { theme, mode, preference, setPreference } = useTheme();
  const { t, locale, setLocale } = useI18n();

  const [notificationsEnabled, setNotificationsEnabled] = useState(true);
  const [biometricEnabled, setBiometricEnabled] = useState(false);

  const dark = mode === 'dark';
  const panelBg = dark ? '#15192A' : '#FFFFFF';
  const panelBorder = dark ? '#2A2D42' : '#E4EAF5';

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.container}>
        <Card
          dark={dark}
          style={[
            styles.profileHint,
            {
              borderColor: panelBorder,
              backgroundColor: panelBg,
            },
          ]}
        >
          <View style={[styles.profileIcon, { backgroundColor: dark ? 'rgba(66,17,212,0.22)' : '#ECF2FF' }]}> 
            <AppIcon name="person-outline" size="lg" tone="primary" />
          </View>
          <Text style={[styles.profileName, { color: theme.colors.text }]}>{t('profile.settings.userTitle')}</Text>
          <Text style={[styles.profilePlan, { color: theme.colors.primary }]}>{t('profile.settings.plan')}</Text>
        </Card>

        <SettingsGroup
          title={t('profile.settings.sections.application')}
          items={[
            {
              iconName: 'language-outline',
              label: t('profile.settings.items.language.title'),
              subtitle: t('profile.settings.items.language.subtitle'),
              customRight: (
                <View style={styles.optionChipRow}>
                  {localeOptions.map((option) => {
                    const active = locale === option;
                    return (
                      <Pressable
                        key={option}
                        accessibilityRole="button"
                        onPress={() => {
                          void setLocale(option);
                        }}
                        style={[
                          styles.optionChip,
                          {
                            borderColor: active ? theme.colors.primary : panelBorder,
                            backgroundColor: active
                              ? dark
                                ? 'rgba(66,17,212,0.22)'
                                : '#ECF2FF'
                              : dark
                                ? '#121624'
                                : '#FFFFFF',
                          },
                        ]}
                      >
                        <Text style={[styles.optionChipText, { color: active ? theme.colors.primary : theme.colors.textMuted }]}> 
                          {t(`profile.settings.locale.${option}`)}
                        </Text>
                      </Pressable>
                    );
                  })}
                </View>
              ),
            },
            {
              iconName: 'color-palette-outline',
              label: t('profile.settings.items.theme.title'),
              subtitle: t('profile.settings.items.theme.subtitle'),
              customRight: (
                <View style={styles.optionChipRow}>
                  {themeOptions.map((option) => {
                    const active = preference === option;
                    return (
                      <Pressable
                        key={option}
                        accessibilityRole="button"
                        onPress={() => setPreference(option)}
                        style={[
                          styles.optionChip,
                          {
                            borderColor: active ? theme.colors.primary : panelBorder,
                            backgroundColor: active
                              ? dark
                                ? 'rgba(66,17,212,0.22)'
                                : '#ECF2FF'
                              : dark
                                ? '#121624'
                                : '#FFFFFF',
                          },
                        ]}
                      >
                        <Text style={[styles.optionChipText, { color: active ? theme.colors.primary : theme.colors.textMuted }]}> 
                          {t(`profile.settings.theme.${option}`)}
                        </Text>
                      </Pressable>
                    );
                  })}
                </View>
              ),
            },
            {
              iconName: 'notifications-outline',
              label: t('profile.settings.items.notifications.title'),
              subtitle: t('profile.settings.items.notifications.subtitle'),
              customRight: (
                <Switch
                  trackColor={{ false: dark ? '#3A3F56' : '#CBD5E1', true: dark ? '#3A238A' : '#CAD8FF' }}
                  thumbColor={notificationsEnabled ? theme.colors.primary : '#E2E8F0'}
                  onValueChange={setNotificationsEnabled}
                  value={notificationsEnabled}
                />
              ),
            },
          ]}
        />

        <SettingsGroup
          title={t('profile.settings.sections.privacy')}
          items={[
            {
              iconName: 'finger-print-outline',
              label: t('profile.settings.items.biometric.title'),
              subtitle: t('profile.settings.items.biometric.subtitle'),
              customRight: (
                <Switch
                  trackColor={{ false: dark ? '#3A3F56' : '#CBD5E1', true: dark ? '#3A238A' : '#CAD8FF' }}
                  thumbColor={biometricEnabled ? theme.colors.primary : '#E2E8F0'}
                  onValueChange={setBiometricEnabled}
                  value={biometricEnabled}
                />
              ),
            },
            {
              iconName: 'shield-checkmark-outline',
              label: t('profile.settings.items.security.title'),
              subtitle: t('profile.settings.items.security.subtitle'),
              chevron: true,
            },
          ]}
        />

        <SettingsGroup
          title={t('profile.settings.sections.support')}
          items={[
            {
              iconName: 'sparkles-outline',
              label: t('profile.settings.items.howItWorks.title'),
              subtitle: t('profile.settings.items.howItWorks.subtitle'),
              onPress: () => navigation.navigate('HowItWorks'),
              chevron: true,
            },
            {
              iconName: 'help-circle-outline',
              label: t('profile.settings.items.helpCenter.title'),
              subtitle: t('profile.settings.items.helpCenter.subtitle'),
            },
            {
              iconName: 'information-circle-outline',
              label: t('profile.settings.items.version.title'),
              subtitle: t('profile.settings.items.version.subtitle'),
            },
          ]}
        />
      </View>
    </ScreenContainer>
  );
}

function SettingsGroup({
  title,
  items,
}: {
  title: string;
  items: Array<{
    iconName: Parameters<typeof AppIcon>[0]['name'];
    label: string;
    subtitle: string;
    value?: string;
    chevron?: boolean;
    customRight?: ReactNode;
    onPress?: () => void;
  }>;
}) {
  const { theme, mode } = useTheme();
  const dark = mode === 'dark';

  return (
    <View style={styles.groupWrap}>
      <Text style={[styles.groupTitle, { color: theme.colors.primary }]}>{title}</Text>
      <Card
        dark={dark}
        style={[
          styles.groupCard,
          {
            borderColor: dark ? '#2A2D42' : '#E4EAF5',
            backgroundColor: dark ? '#15192A' : '#FFFFFF',
          },
        ]}
      >
        {items.map((item, index) => (
          <View key={`${item.label}-${index}`}>
            {item.onPress ? (
              <Pressable
                accessibilityRole="button"
                onPress={item.onPress}
                style={({ pressed }) => [styles.row, pressed && styles.rowPressed]}
              >
                <View style={[styles.leadingIconWrap, { backgroundColor: dark ? 'rgba(66,17,212,0.18)' : '#ECF2FF' }]}> 
                  <AppIcon name={item.iconName} size="sm" tone="primary" />
                </View>

                <View style={styles.textWrap}>
                  <Text style={[styles.rowTitle, { color: theme.colors.text }]}>{item.label}</Text>
                  <Text style={[styles.rowSubtitle, { color: theme.colors.textMuted }]}>{item.subtitle}</Text>
                </View>

                {item.customRight ?? (
                  <View style={styles.rightMeta}>
                    {item.value ? <Text style={[styles.valueText, { color: theme.colors.textMuted }]}>{item.value}</Text> : null}
                    {item.chevron ? <AppIcon name="chevron-forward" size="sm" tone="muted" /> : null}
                  </View>
                )}
              </Pressable>
            ) : (
              <View style={styles.row}>
                <View style={[styles.leadingIconWrap, { backgroundColor: dark ? 'rgba(66,17,212,0.18)' : '#ECF2FF' }]}> 
                  <AppIcon name={item.iconName} size="sm" tone="primary" />
                </View>

                <View style={styles.textWrap}>
                  <Text style={[styles.rowTitle, { color: theme.colors.text }]}>{item.label}</Text>
                  <Text style={[styles.rowSubtitle, { color: theme.colors.textMuted }]}>{item.subtitle}</Text>
                </View>

                {item.customRight ?? (
                  <View style={styles.rightMeta}>
                    {item.value ? <Text style={[styles.valueText, { color: theme.colors.textMuted }]}>{item.value}</Text> : null}
                    {item.chevron ? <AppIcon name="chevron-forward" size="sm" tone="muted" /> : null}
                  </View>
                )}
              </View>
            )}

            {index < items.length - 1 ? (
              <View style={[styles.divider, { backgroundColor: dark ? '#2A2D42' : '#E4EAF5' }]} />
            ) : null}
          </View>
        ))}
      </Card>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.md,
  },
  profileHint: {
    alignItems: 'center',
    gap: spacing.xxs,
  },
  profileIcon: {
    alignItems: 'center',
    borderRadius: radius.full,
    height: 64,
    justifyContent: 'center',
    marginBottom: spacing.xs,
    width: 64,
  },
  profileName: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  profilePlan: {
    ...typography.caption,
    fontWeight: '700',
    letterSpacing: 0.5,
    textTransform: 'uppercase',
  },
  groupWrap: {
    gap: spacing.xs,
  },
  groupTitle: {
    ...typography.caption,
    fontWeight: '700',
    letterSpacing: 0.8,
    textTransform: 'uppercase',
  },
  groupCard: {
    paddingHorizontal: 0,
    paddingVertical: 0,
  },
  row: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.sm,
    minHeight: 64,
    paddingHorizontal: spacing.md,
    paddingVertical: spacing.xs,
  },
  rowPressed: {
    opacity: 0.86,
  },
  leadingIconWrap: {
    alignItems: 'center',
    borderRadius: radius.md,
    height: 34,
    justifyContent: 'center',
    width: 34,
  },
  textWrap: {
    flex: 1,
    gap: 2,
  },
  rowTitle: {
    ...typography.body,
    fontWeight: '600',
  },
  rowSubtitle: {
    ...typography.caption,
    fontSize: 11,
  },
  rightMeta: {
    alignItems: 'flex-end',
    gap: spacing.xxs,
  },
  valueText: {
    ...typography.caption,
    fontWeight: '700',
  },
  divider: {
    height: 1,
    marginHorizontal: spacing.md,
  },
  optionChipRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xxs,
    justifyContent: 'flex-end',
    maxWidth: 176,
  },
  optionChip: {
    borderRadius: radius.full,
    borderWidth: 1,
    minHeight: 26,
    justifyContent: 'center',
    paddingHorizontal: spacing.xs,
  },
  optionChipText: {
    ...typography.caption,
    fontSize: 10,
    fontWeight: '700',
  },
});

===== FILE: apps/mobile/src/features/scan/index.ts =====
export { ScanHomeScreen } from './screens/ScanHomeScreen';
export { ScanCameraScreen } from './screens/ScanCameraScreen';
export { ScanReviewScreen } from './screens/ScanReviewScreen';

===== FILE: apps/mobile/src/features/scan/screens/ScanCameraScreen.tsx =====
import { useRef, useState } from 'react';
import { ActivityIndicator, Pressable, StyleSheet, Text, View } from 'react-native';

import { CameraView, useCameraPermissions } from 'expo-camera';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';

import { Card, ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { TransactionsStackParamList } from '@core/navigation/stacks/TransactionsStack';
import { radius, spacing, typography, useTheme } from '@shared/theme';

export function ScanCameraScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const { theme, mode } = useTheme();
  const { t } = useI18n();
  const [permission, requestPermission] = useCameraPermissions();
  const [isCapturing, setIsCapturing] = useState(false);
  const cameraRef = useRef<CameraView | null>(null);

  const dark = mode === 'dark';

  const permissionGranted = permission?.granted ?? false;

  async function handleCapture() {
    if (!cameraRef.current || isCapturing) {
      return;
    }

    setIsCapturing(true);
    try {
      const photo = await cameraRef.current.takePictureAsync({ quality: 0.6 });
      if (!photo?.uri) {
        return;
      }

      navigation.navigate('ScanReview', { photoUri: photo.uri });
    } finally {
      setIsCapturing(false);
    }
  }

  if (!permission) {
    return (
      <ScreenContainer dark={dark}>
        <Card dark={dark} style={styles.stateCard}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={[styles.stateText, { color: theme.colors.textMuted }]}>{t('scan.camera.state.preparing')}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (!permissionGranted) {
    return (
      <ScreenContainer dark={dark}>
        <Card dark={dark} style={styles.permissionCard}>
          <Text style={[styles.permissionTitle, { color: theme.colors.text }]}>{t('scan.camera.permission.title')}</Text>
          <Text style={[styles.permissionText, { color: theme.colors.textMuted }]}> 
            {t('scan.camera.permission.subtitle')}
          </Text>

          <Pressable
            accessibilityRole="button"
            onPress={() => {
              void requestPermission();
            }}
            style={[styles.primaryAction, { backgroundColor: theme.colors.primary }]}
          >
            <Text style={styles.primaryActionLabel}>{t('scan.camera.permission.allow')}</Text>
          </Pressable>
        </Card>
      </ScreenContainer>
    );
  }

  return (
    <ScreenContainer dark={dark} contentStyle={styles.containerContent} scrollable={false}>
      <View style={styles.container}>
        <View style={[styles.cameraWrap, { borderColor: theme.colors.border }]}> 
          <CameraView
            ref={cameraRef}
            style={StyleSheet.absoluteFill}
            facing="back"
            mode="picture"
          />
        </View>

        <View style={styles.footerActions}>
          <Pressable
            accessibilityRole="button"
            onPress={() => navigation.goBack()}
            style={[styles.secondaryAction, { borderColor: theme.colors.border }]}
          >
            <Text style={[styles.secondaryActionLabel, { color: theme.colors.textMuted }]}>{t('common.cancel')}</Text>
          </Pressable>

          <Pressable
            accessibilityRole="button"
            onPress={() => {
              void handleCapture();
            }}
            style={[styles.captureAction, { backgroundColor: theme.colors.primary }]}
          >
            {isCapturing ? (
              <ActivityIndicator color="#FFFFFF" size="small" />
            ) : (
              <Text style={styles.captureActionLabel}>{t('scan.camera.capture')}</Text>
            )}
          </Pressable>
        </View>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    gap: 0,
    paddingBottom: spacing.md,
  },
  container: {
    flex: 1,
    gap: spacing.sm,
  },
  cameraWrap: {
    borderRadius: radius.xl,
    borderWidth: 1,
    flex: 1,
    overflow: 'hidden',
  },
  footerActions: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  primaryAction: {
    alignItems: 'center',
    borderRadius: radius.md,
    height: 48,
    justifyContent: 'center',
    paddingHorizontal: spacing.lg,
  },
  primaryActionLabel: {
    ...typography.subheading,
    color: '#FFFFFF',
    fontWeight: '700',
  },
  secondaryAction: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flex: 1,
    height: 48,
    justifyContent: 'center',
    paddingHorizontal: spacing.lg,
  },
  secondaryActionLabel: {
    ...typography.subheading,
    fontWeight: '700',
  },
  captureAction: {
    alignItems: 'center',
    borderRadius: radius.md,
    flex: 2,
    height: 48,
    justifyContent: 'center',
    paddingHorizontal: spacing.lg,
  },
  captureActionLabel: {
    ...typography.subheading,
    color: '#FFFFFF',
    fontWeight: '700',
  },
  stateCard: {
    alignItems: 'center',
    gap: spacing.sm,
    justifyContent: 'center',
    minHeight: 160,
  },
  stateText: {
    ...typography.body,
  },
  permissionCard: {
    gap: spacing.sm,
  },
  permissionTitle: {
    ...typography.heading,
    fontSize: 24,
  },
  permissionText: {
    ...typography.body,
  },
});

===== FILE: apps/mobile/src/features/scan/screens/ScanHomeScreen.tsx =====
import { Pressable, StyleSheet, Text, View } from 'react-native';

import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';

import { Card, PrimaryButton, ScreenContainer } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { TransactionsStackParamList } from '@core/navigation/stacks/TransactionsStack';
import { radius, spacing, typography, useTheme } from '@shared/theme';

export function ScanHomeScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const { theme, mode } = useTheme();
  const { t } = useI18n();
  const dark = mode === 'dark';

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.container}>
        <Card dark={dark} style={styles.heroCard}>
          <View style={[styles.heroIconWrap, { backgroundColor: theme.colors.primaryMuted }]}> 
            <Text style={styles.heroIcon}>◎</Text>
          </View>
          <Text style={[styles.title, { color: theme.colors.text }]}>{t('scan.home.title')}</Text>
          <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}> 
            {t('scan.home.subtitle')}
          </Text>

          <View style={styles.stepsWrap}>
            <View style={styles.stepRow}>
              <View style={[styles.stepDot, { backgroundColor: theme.colors.primary }]} />
              <Text style={[styles.stepText, { color: theme.colors.textMuted }]}>{t('scan.home.steps.capture')}</Text>
            </View>
            <View style={styles.stepRow}>
              <View style={[styles.stepDot, { backgroundColor: theme.colors.primary }]} />
              <Text style={[styles.stepText, { color: theme.colors.textMuted }]}>{t('scan.home.steps.review')}</Text>
            </View>
            <View style={styles.stepRow}>
              <View style={[styles.stepDot, { backgroundColor: theme.colors.primary }]} />
              <Text style={[styles.stepText, { color: theme.colors.textMuted }]}>{t('scan.home.steps.create')}</Text>
            </View>
          </View>

          <PrimaryButton
            label={t('scan.home.cta')}
            onPress={() => navigation.navigate('ScanCamera')}
          />
        </Card>

        <Pressable
          accessibilityRole="button"
          onPress={() => navigation.navigate('Transactions')}
          style={styles.backButton}
        >
          <Text style={[styles.backLabel, { color: theme.colors.primary }]}>{t('scan.home.back')}</Text>
        </Pressable>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  heroCard: {
    gap: spacing.sm,
  },
  heroIconWrap: {
    alignItems: 'center',
    alignSelf: 'center',
    borderRadius: radius.full,
    height: 64,
    justifyContent: 'center',
    width: 64,
  },
  heroIcon: {
    ...typography.heading,
    color: '#FFFFFF',
    fontSize: 26,
    lineHeight: 30,
  },
  title: {
    ...typography.heading,
    fontSize: 26,
    textAlign: 'center',
  },
  subtitle: {
    ...typography.body,
    textAlign: 'center',
  },
  stepsWrap: {
    gap: spacing.xs,
  },
  stepRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  stepDot: {
    borderRadius: radius.full,
    height: 8,
    width: 8,
  },
  stepText: {
    ...typography.body,
    flex: 1,
  },
  backButton: {
    alignItems: 'center',
    paddingVertical: spacing.xs,
  },
  backLabel: {
    ...typography.caption,
    fontSize: 13,
    fontWeight: '700',
  },
});

===== FILE: apps/mobile/src/features/scan/screens/ScanReviewScreen.tsx =====
import { useEffect, useMemo, useState } from 'react';
import { Alert, Image, Pressable, StyleSheet, Text, View } from 'react-native';

import { useNavigation, useRoute } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import type { RouteProp } from '@react-navigation/native';

import { Card, PrimaryButton, ScreenContainer, TextField } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { RootTabParamList } from '@core/navigation/types';
import type { TransactionsStackParamList } from '@core/navigation/stacks/TransactionsStack';
import { radius, spacing, typography, useTheme } from '@shared/theme';

function stableHash(value: string): number {
  let hash = 0;
  for (let i = 0; i < value.length; i += 1) {
    hash = (hash * 31 + value.charCodeAt(i)) >>> 0;
  }
  return hash;
}

function toDateOnly(value: Date): string {
  const year = value.getUTCFullYear();
  const month = String(value.getUTCMonth() + 1).padStart(2, '0');
  const day = String(value.getUTCDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function buildMockExtraction(uri: string) {
  const hash = stableHash(uri);
  const amount = ((hash % 15000) / 100 + 50).toFixed(2);
  const daysBack = hash % 11;
  const date = new Date();
  date.setUTCDate(date.getUTCDate() - daysBack);

  const merchants = ['Migros', 'Starbucks', 'Carrefour', 'Shell', 'Getir', 'LC Waikiki'];
  const merchantName = merchants[hash % merchants.length] ?? 'Market';

  return {
    merchantName,
    amount,
    date: toDateOnly(date),
  };
}

export function ScanReviewScreen() {
  const { theme, mode } = useTheme();
  const { t } = useI18n();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const route = useRoute<RouteProp<TransactionsStackParamList, 'ScanReview'>>();

  const dark = mode === 'dark';

  const initialMock = useMemo(() => buildMockExtraction(route.params.photoUri), [route.params.photoUri]);

  const [merchantName, setMerchantName] = useState(initialMock.merchantName);
  const [amount, setAmount] = useState(initialMock.amount);
  const [receiptDate, setReceiptDate] = useState(initialMock.date);

  useEffect(() => {
    setMerchantName(initialMock.merchantName);
    setAmount(initialMock.amount);
    setReceiptDate(initialMock.date);
  }, [initialMock]);

  function handleCreateTransaction() {
    const parsedAmount = Number(amount);
    const occurredAt = new Date(`${receiptDate}T12:00:00.000Z`);

    if (!Number.isFinite(parsedAmount) || parsedAmount <= 0) {
      Alert.alert(t('scan.review.errors.invalidAmountTitle'), t('scan.review.errors.invalidAmountMessage'));
      return;
    }

    if (Number.isNaN(occurredAt.getTime())) {
      Alert.alert(t('scan.review.errors.invalidDateTitle'), t('scan.review.errors.invalidDateMessage'));
      return;
    }

    const parent = navigation.getParent();
    if (!parent) {
      Alert.alert(t('scan.review.errors.navigationTitle'), t('scan.review.errors.navigationMessage'));
      return;
    }

    const params: RootTabParamList['AddTab'] = {
      prefill: {
        amount: parsedAmount.toFixed(2),
        description: merchantName.trim() || t('scan.review.defaults.description'),
        occurredAt: occurredAt.toISOString(),
      },
    };

    (parent as { navigate: (routeName: keyof RootTabParamList, params?: RootTabParamList['AddTab']) => void }).navigate(
      'AddTab',
      params,
    );
  }

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.container}>
        <Card dark={dark} style={styles.previewCard}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>{t('scan.review.previewTitle')}</Text>
          <Image source={{ uri: route.params.photoUri }} style={styles.previewImage} />
        </Card>

        <Card dark={dark} style={styles.formCard}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>{t('scan.review.formTitle')}</Text>

          <TextField
            label={t('scan.review.fields.merchant')}
            value={merchantName}
            onChangeText={setMerchantName}
            placeholder={t('scan.review.fields.merchantPlaceholder')}
            autoCapitalize="words"
          />

          <TextField
            label={t('scan.review.fields.amount')}
            value={amount}
            onChangeText={setAmount}
            placeholder={t('scan.review.fields.amountPlaceholder')}
            keyboardType="decimal-pad"
          />

          <TextField
            label={t('scan.review.fields.date')}
            value={receiptDate}
            onChangeText={setReceiptDate}
            placeholder={t('scan.review.fields.datePlaceholder')}
            autoCapitalize="none"
          />

          <PrimaryButton label={t('scan.review.createTransaction')} onPress={handleCreateTransaction} />

          <Pressable
            accessibilityRole="button"
            onPress={() => navigation.navigate('ScanCamera')}
            style={styles.retakeButton}
          >
            <Text style={[styles.retakeLabel, { color: theme.colors.primary }]}>{t('scan.review.retake')}</Text>
          </Pressable>
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  previewCard: {
    gap: spacing.xs,
  },
  formCard: {
    gap: spacing.sm,
  },
  sectionTitle: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  previewImage: {
    borderRadius: radius.md,
    height: 220,
    width: '100%',
  },
  retakeButton: {
    alignItems: 'center',
    paddingVertical: spacing.xs,
  },
  retakeLabel: {
    ...typography.caption,
    fontSize: 13,
    fontWeight: '700',
  },
});

===== FILE: apps/mobile/src/features/stitch/screens/ModuleHubScreen.tsx =====
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { Pressable, StyleSheet, Text, View } from 'react-native';

import { Card, Chip, ScreenContainer, Section } from '@shared/ui';
import { useI18n } from '@shared/i18n';
import type { ModuleStackParamList } from '@core/navigation/types';
import { colors, spacing, typography } from '@shared/theme';
import { moduleLabels } from '@core/stitch/moduleLabels';
import { getScreensByModule, type StitchModule } from '@core/stitch/screenInventory';

interface ModuleHubScreenProps extends NativeStackScreenProps<ModuleStackParamList, 'Hub'> {
  title: string;
  subtitle: string;
  modules: StitchModule[];
}

export function ModuleHubScreen({ navigation, title, subtitle, modules }: ModuleHubScreenProps) {
  const { t } = useI18n();
  const screens = getScreensByModule(modules).sort((a, b) => a.folderName.localeCompare(b.folderName, 'tr'));

  const grouped = modules.map((moduleName) => ({
    moduleName,
    items: screens.filter((screen) => screen.module === moduleName),
  }));

  return (
    <ScreenContainer>
      <Card style={styles.hero}>
        <Text style={styles.heroTitle}>{title}</Text>
        <Text style={styles.heroSubtitle}>{subtitle}</Text>
        <View style={styles.heroChips}>
          <Chip label={t('stitch.hub.totalScreens', { count: screens.length })} tone="primary" />
          <Chip label={t('stitch.hub.staticPlaceholders')} />
          <Chip label={t('stitch.hub.noApi')} />
        </View>
      </Card>

      {grouped.map((group) => (
        <Section
          key={group.moduleName}
          title={t(moduleLabels[group.moduleName])}
          subtitle={t('stitch.hub.totalScreens', { count: group.items.length })}
        >
          {group.items.map((screen) => (
            <Pressable
              key={screen.screenKey}
              style={({ pressed }) => [styles.row, pressed && styles.rowPressed]}
              onPress={() => navigation.navigate('StitchPreview', { screenKey: screen.screenKey })}
            >
              <Text style={styles.rowTitle}>{screen.folderName}</Text>
              <View style={styles.rowMeta}>
                <Chip label={screen.hasCodeHtml ? t('stitch.hub.codeHtml') : t('stitch.hub.pngOnly')} />
                {screen.isDark ? <Chip label={t('stitch.hub.dark')} /> : null}
              </View>
            </Pressable>
          ))}
        </Section>
      ))}
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  hero: {
    gap: spacing.sm,
    backgroundColor: colors.primary,
    borderColor: '#1F4CC2',
  },
  heroTitle: {
    ...typography.heading,
    color: '#FFFFFF',
  },
  heroSubtitle: {
    ...typography.body,
    color: '#D8E5FF',
  },
  heroChips: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  row: {
    borderWidth: 1,
    borderColor: colors.border,
    borderRadius: 12,
    padding: spacing.sm,
    gap: spacing.xs,
    backgroundColor: colors.surface,
  },
  rowPressed: {
    opacity: 0.88,
  },
  rowTitle: {
    ...typography.body,
    color: colors.text,
    fontWeight: '600',
  },
  rowMeta: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
});

===== FILE: apps/mobile/src/features/stitch/screens/StitchPreviewScreen.tsx =====
import type { NativeStackScreenProps } from '@react-navigation/native-stack';
import { StyleSheet, Text, View } from 'react-native';

import {
  Card,
  CategoryRow,
  Chip,
  PrimaryButton,
  ScreenContainer,
  Section,
  StatCard,
  TransactionRow,
} from '@shared/ui';
import { I18N_KEYS } from '@shared/i18n/keys';
import { useI18n } from '@shared/i18n';
import type { ModuleStackParamList } from '@core/navigation/types';
import { colors, radius, spacing, typography } from '@shared/theme';
import { moduleLabels } from '@core/stitch/moduleLabels';
import { getScreenByKey } from '@core/stitch/screenInventory';

type Props = NativeStackScreenProps<ModuleStackParamList, 'StitchPreview'>;

const categoryRows = [
  { titleKey: 'stitch.preview.category.groceriesTitle', subtitleKey: 'stitch.preview.category.groceriesSubtitle', amount: '-$140.50' },
  { titleKey: 'stitch.preview.category.transportTitle', subtitleKey: 'stitch.preview.category.transportSubtitle', amount: '-$48.20' },
  { titleKey: 'stitch.preview.category.salaryTitle', subtitleKey: 'stitch.preview.category.salarySubtitle', amount: '+$2,900.00', tone: 'income' as const },
];

const transactions = [
  { titleKey: 'stitch.preview.tx.coffee', dateKey: 'stitch.preview.txDate.today0920', amount: '-$8.40', type: 'expense' as const },
  { titleKey: 'stitch.preview.tx.clientPayout', dateKey: 'stitch.preview.txDate.today0810', amount: '+$420.00', type: 'income' as const },
  { titleKey: 'stitch.preview.tx.gym', dateKey: 'stitch.preview.txDate.yesterday', amount: '-$39.00', type: 'expense' as const },
];

const settingsRows = [
  { titleKey: 'stitch.preview.settings.notificationsTitle', subtitleKey: 'stitch.preview.settings.notificationsSubtitle' },
  { titleKey: 'stitch.preview.settings.securityTitle', subtitleKey: 'stitch.preview.settings.securitySubtitle' },
  { titleKey: 'stitch.preview.settings.helpTitle', subtitleKey: 'stitch.preview.settings.helpSubtitle' },
];

export function StitchPreviewScreen({ route }: Props) {
  const { t } = useI18n();
  const screen = getScreenByKey(route.params.screenKey);

  if (!screen) {
    return (
      <ScreenContainer>
        <Card>
          <Text style={styles.errorTitle}>{t('stitch.preview.errors.notFoundTitle')}</Text>
          <Text style={styles.errorBody}>{t('stitch.preview.errors.notFoundBody')}</Text>
        </Card>
      </ScreenContainer>
    );
  }

  const dark = screen.isDark;
  const textColor = dark ? colors.dark.text : colors.text;
  const textMutedColor = dark ? colors.dark.textMuted : colors.textMuted;

  return (
    <ScreenContainer dark={dark}>
      <Card dark={dark} style={styles.headerCard}>
        <Text style={[styles.headerTitle, { color: textColor }]}>{screen.folderName}</Text>
        <Text style={[styles.headerSub, { color: textMutedColor }]}>{screen.folderPath}</Text>
        <View style={styles.chipsRow}>
          <Chip label={t(moduleLabels[screen.module])} tone="primary" dark={dark} />
          <Chip label={screen.hasCodeHtml ? t('stitch.preview.chips.codeHtmlUsed') : t('stitch.preview.chips.pngPlaceholder')} dark={dark} />
          {screen.isDark ? <Chip label={t('stitch.preview.chips.darkVariant')} dark={dark} /> : <Chip label={t('stitch.preview.chips.lightVariant')} dark={dark} />}
        </View>
      </Card>

      {screen.module === 'dashboard' ? <DashboardLayout dark={dark} t={t} /> : null}
      {screen.module === 'transactions' ? <TransactionsLayout dark={dark} t={t} /> : null}
      {screen.module === 'analytics' ? <AnalyticsLayout dark={dark} t={t} /> : null}
      {screen.module === 'split' ? <SplitLayout dark={dark} t={t} /> : null}
      {screen.module === 'scan' ? <ScanLayout dark={dark} t={t} /> : null}
      {screen.module === 'profile' ? <ProfileLayout dark={dark} t={t} /> : null}
      {screen.module === 'auth' ? <AuthLayout dark={dark} t={t} /> : null}
      {screen.module === 'other' ? <OtherLayout dark={dark} t={t} /> : null}
    </ScreenContainer>
  );
}

function DashboardLayout({
  dark,
  t,
}: {
  dark: boolean;
  t: (key: string, params?: Record<string, string | number>) => string;
}) {
  return (
    <>
      <Section title={t('stitch.preview.dashboard.accountSnapshot')} subtitle={t('stitch.preview.dashboard.overviewCards')} dark={dark}>
        <View style={styles.gridRow}>
          <StatCard label={t('stitch.preview.dashboard.currentBalance')} value="$14,230" detail={t('stitch.preview.dashboard.updated1mAgo')} tone="primary" dark={dark} />
          <StatCard label={t('stitch.preview.dashboard.monthlyIncome')} value="$5,400" detail="+8.2%" tone="income" dark={dark} />
        </View>
      </Section>

      <Section title={t('stitch.preview.dashboard.categoryPulse')} subtitle={t('stitch.preview.dashboard.topCategories')} dark={dark}>
        {categoryRows.map((item) => (
          <CategoryRow
            key={item.titleKey}
            title={t(item.titleKey)}
            subtitle={t(item.subtitleKey)}
            amount={item.amount}
            amountTone={item.tone ?? 'expense'}
            dark={dark}
          />
        ))}
      </Section>

      <Section title={t('stitch.preview.dashboard.recentActivity')} dark={dark}>
        {transactions.map((item) => (
          <TransactionRow
            key={`${item.titleKey}-${item.dateKey}`}
            title={t(item.titleKey)}
            date={t(item.dateKey)}
            amount={item.amount}
            type={item.type}
            dark={dark}
          />
        ))}
      </Section>
    </>
  );
}

function TransactionsLayout({
  dark,
  t,
}: {
  dark: boolean;
  t: (key: string, params?: Record<string, string | number>) => string;
}) {
  return (
    <>
      <Section title={t('stitch.preview.transactions.feed')} subtitle={t('stitch.preview.transactions.filtersSubtitle')} dark={dark}>
        <View style={styles.chipsRow}>
          <Chip label={t('transactions.filters.all')} tone="primary" dark={dark} />
          <Chip label={t('analytics.income')} tone="income" dark={dark} />
          <Chip label={t('analytics.expense')} tone="expense" dark={dark} />
        </View>
        {transactions.map((item) => (
          <TransactionRow
            key={`${item.titleKey}-${item.dateKey}`}
            title={t(item.titleKey)}
            date={t(item.dateKey)}
            amount={item.amount}
            type={item.type}
            dark={dark}
          />
        ))}
      </Section>
      <PrimaryButton label={t('stitch.preview.transactions.addNew')} />
    </>
  );
}

function AnalyticsLayout({
  dark,
  t,
}: {
  dark: boolean;
  t: (key: string, params?: Record<string, string | number>) => string;
}) {
  const chartBars = [72, 46, 90, 58, 34, 78];
  const bg = dark ? colors.dark.surface : colors.surface;
  const border = dark ? colors.dark.border : colors.border;

  return (
    <>
      <Section title={t('stitch.preview.analytics.spendingTrend')} subtitle={t('stitch.preview.analytics.weeklyBars')} dark={dark}>
        <Card dark={dark}>
          <View style={styles.chartWrap}>
            {chartBars.map((height, index) => (
              <View key={`bar-${index}`} style={[styles.barTrack, { backgroundColor: bg, borderColor: border }]}> 
                <View
                  style={[
                    styles.barFill,
                    {
                      height,
                      backgroundColor: index % 2 === 0 ? colors.chartA : colors.chartB,
                    },
                  ]}
                />
              </View>
            ))}
          </View>
        </Card>
      </Section>

      <Section title={t('stitch.preview.analytics.highlights')} dark={dark}>
        <View style={styles.gridRow}>
          <StatCard label={t('stitch.preview.analytics.food')} value="34%" tone="expense" dark={dark} />
          <StatCard label={t('stitch.preview.analytics.savings')} value="21%" tone="income" dark={dark} />
        </View>
      </Section>
    </>
  );
}

function SplitLayout({
  dark,
  t,
}: {
  dark: boolean;
  t: (key: string, params?: Record<string, string | number>) => string;
}) {
  return (
    <>
      <Section title={t('stitch.preview.split.groupOverview')} subtitle={t('stitch.preview.split.expenseSplitScenario')} dark={dark}>
        <Card dark={dark}>
          <Text style={[styles.groupTitle, { color: dark ? colors.dark.text : colors.text }]}>{t('stitch.preview.split.weekendTrip')}</Text>
          <View style={styles.chipsRow}>
            <Chip label={t('stitch.preview.split.memberAylin')} dark={dark} />
            <Chip label={t('stitch.preview.split.memberMert')} dark={dark} />
            <Chip label={t('stitch.preview.split.memberDeniz')} dark={dark} />
            <Chip label={t('stitch.preview.split.memberYou')} tone="primary" dark={dark} />
          </View>
        </Card>

        <CategoryRow
          title={t('stitch.preview.split.youOweMert')}
          subtitle={t('stitch.preview.split.accommodation')}
          amount="-$56.00"
          amountTone="expense"
          dark={dark}
        />
        <CategoryRow
          title={t('stitch.preview.split.aylinOwesYou')}
          subtitle={t('stitch.preview.split.carRental')}
          amount="+$32.00"
          amountTone="income"
          dark={dark}
        />
      </Section>
      <PrimaryButton label={t('stitch.preview.split.settleGroupExpense')} />
    </>
  );
}

function ScanLayout({
  dark,
  t,
}: {
  dark: boolean;
  t: (key: string, params?: Record<string, string | number>) => string;
}) {
  return (
    <>
      <Section title={t('stitch.preview.scan.receiptScan')} subtitle={t('stitch.preview.scan.cameraFramePlaceholder')} dark={dark}>
        <Card dark={dark} style={styles.scanCard}>
          <View style={[styles.scanFrame, { borderColor: dark ? '#35528A' : '#9DB8F8' }]}>
            <Text style={[styles.scanText, { color: dark ? colors.dark.textMuted : colors.textMuted }]}>
              {t('stitch.preview.scan.alignReceipt')}
            </Text>
          </View>
        </Card>
      </Section>
      <PrimaryButton label={t('stitch.preview.scan.captureReceipt')} />
    </>
  );
}

function ProfileLayout({
  dark,
  t,
}: {
  dark: boolean;
  t: (key: string, params?: Record<string, string | number>) => string;
}) {
  return (
    <>
      <Section title={t('stitch.preview.profile.summary')} dark={dark}>
        <Card dark={dark} style={styles.profileCard}>
          <View style={styles.avatar}>
            <Text style={styles.avatarText}>{t('common.appInitials')}</Text>
          </View>
          <View style={styles.profileMeta}>
            <Text style={[styles.profileName, { color: dark ? colors.dark.text : colors.text }]}>{t('profile.defaultUserName')}</Text>
            <Text style={[styles.profileEmail, { color: dark ? colors.dark.textMuted : colors.textMuted }]}>
              {t('stitch.preview.profile.sampleEmail')}
            </Text>
          </View>
        </Card>
      </Section>

      <Section title={t(I18N_KEYS.common.navigation.stacks.settings.headerTitle)} dark={dark}>
        {settingsRows.map((item) => (
          <CategoryRow
            key={item.titleKey}
            title={t(item.titleKey)}
            subtitle={t(item.subtitleKey)}
            amount=">"
            amountTone="neutral"
            dark={dark}
          />
        ))}
      </Section>
    </>
  );
}

function AuthLayout({
  dark,
  t,
}: {
  dark: boolean;
  t: (key: string, params?: Record<string, string | number>) => string;
}) {
  const surface = dark ? colors.dark.surface : colors.surface;
  const border = dark ? colors.dark.border : colors.border;
  const textMuted = dark ? colors.dark.textMuted : colors.textMuted;

  return (
    <>
      <Section title={t('stitch.preview.auth.authenticationForm')} subtitle={t('stitch.preview.auth.onboardingLoginPlaceholder')} dark={dark}>
        <Card dark={dark} style={styles.authCard}>
          <InputPlaceholder label={t('auth.login.fields.emailLabel')} border={border} bg={surface} textMuted={textMuted} />
          <InputPlaceholder label={t('auth.login.fields.passwordLabel')} border={border} bg={surface} textMuted={textMuted} />
          <InputPlaceholder label={t('stitch.preview.auth.phoneOtp')} border={border} bg={surface} textMuted={textMuted} />
        </Card>
      </Section>
      <PrimaryButton label={t('common.continue')} />
    </>
  );
}

function OtherLayout({
  dark,
  t,
}: {
  dark: boolean;
  t: (key: string, params?: Record<string, string | number>) => string;
}) {
  return (
    <>
      <Section title={t('stitch.preview.other.contentUtility')} subtitle={t('stitch.preview.other.helpCenterDetailPages')} dark={dark}>
        <Card dark={dark}>
          <Text style={[styles.groupTitle, { color: dark ? colors.dark.text : colors.text }]}>
            {t('stitch.preview.other.helpCenterTitle')}
          </Text>
          <Text style={[styles.helperText, { color: dark ? colors.dark.textMuted : colors.textMuted }]}> 
            {t('stitch.preview.other.helpCenterDescription')}
          </Text>
          <View style={styles.chipsRow}>
            <Chip label={t('stitch.preview.other.faq')} dark={dark} />
            <Chip label={t('stitch.preview.other.debtGuide')} dark={dark} />
            <Chip label={t('stitch.preview.other.budgetTips')} dark={dark} />
          </View>
        </Card>
      </Section>
    </>
  );
}

function InputPlaceholder({
  label,
  border,
  bg,
  textMuted,
}: {
  label: string;
  border: string;
  bg: string;
  textMuted: string;
}) {
  return (
    <View style={[styles.inputPlaceholder, { borderColor: border, backgroundColor: bg }]}> 
      <Text style={[styles.inputLabel, { color: textMuted }]}>{label}</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  headerCard: {
    gap: spacing.sm,
  },
  headerTitle: {
    ...typography.heading,
  },
  headerSub: {
    ...typography.caption,
  },
  chipsRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  gridRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.sm,
  },
  chartWrap: {
    minHeight: 160,
    flexDirection: 'row',
    alignItems: 'flex-end',
    justifyContent: 'space-between',
    gap: spacing.xs,
  },
  barTrack: {
    flex: 1,
    minWidth: 26,
    borderRadius: radius.md,
    borderWidth: 1,
    padding: spacing.xxs,
    justifyContent: 'flex-end',
    height: 120,
  },
  barFill: {
    borderRadius: radius.sm,
    width: '100%',
  },
  groupTitle: {
    ...typography.subheading,
    marginBottom: spacing.xs,
  },
  helperText: {
    ...typography.body,
    marginBottom: spacing.sm,
  },
  scanCard: {
    alignItems: 'center',
  },
  scanFrame: {
    width: '100%',
    minHeight: 210,
    borderWidth: 2,
    borderStyle: 'dashed',
    borderRadius: radius.lg,
    alignItems: 'center',
    justifyContent: 'center',
  },
  scanText: {
    ...typography.body,
  },
  profileCard: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.sm,
  },
  avatar: {
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: colors.primary,
    alignItems: 'center',
    justifyContent: 'center',
  },
  avatarText: {
    ...typography.subheading,
    color: '#FFFFFF',
  },
  profileMeta: {
    flex: 1,
    gap: spacing.xxs,
  },
  profileName: {
    ...typography.subheading,
  },
  profileEmail: {
    ...typography.caption,
  },
  authCard: {
    gap: spacing.sm,
  },
  inputPlaceholder: {
    borderWidth: 1,
    borderRadius: radius.md,
    minHeight: 46,
    justifyContent: 'center',
    paddingHorizontal: spacing.sm,
  },
  inputLabel: {
    ...typography.body,
  },
  errorTitle: {
    ...typography.heading,
    color: colors.text,
  },
  errorBody: {
    ...typography.body,
    color: colors.textMuted,
    marginTop: spacing.xs,
  },
});

===== FILE: apps/mobile/src/shared/i18n/index.ts =====
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as Localization from 'expo-localization';
import i18n from 'i18next';
import { createElement, useCallback, useEffect, useMemo, useState, type ReactNode } from 'react';
import { I18nextProvider, initReactI18next, useTranslation } from 'react-i18next';

import en from './locales/en.json';
import ru from './locales/ru.json';
import tr from './locales/tr.json';

export type SupportedLocale = 'tr' | 'en' | 'ru';

const LANGUAGE_STORAGE_KEY = 'finsight:language';
const DEFAULT_LOCALE: SupportedLocale = 'en';

const resources = {
  tr: { translation: tr },
  en: { translation: en },
  ru: { translation: ru },
} as const;

let initPromise: Promise<void> | null = null;

function normalizeLocale(locale: string | null | undefined): SupportedLocale {
  if (!locale) {
    return DEFAULT_LOCALE;
  }

  const lowered = locale.toLowerCase();
  if (lowered.startsWith('tr')) {
    return 'tr';
  }

  if (lowered.startsWith('ru')) {
    return 'ru';
  }

  return 'en';
}

function detectDeviceLocale(): SupportedLocale {
  const locale = Localization.getLocales()[0]?.languageCode;
  return normalizeLocale(locale);
}

async function initI18n(): Promise<void> {
  if (i18n.isInitialized) {
    return;
  }

  if (!initPromise) {
    initPromise = (async () => {
      const stored = await AsyncStorage.getItem(LANGUAGE_STORAGE_KEY);
      const locale = normalizeLocale(stored ?? detectDeviceLocale());

      await i18n.use(initReactI18next).init({
        resources,
        lng: locale,
        fallbackLng: DEFAULT_LOCALE,
        interpolation: { escapeValue: false },
        compatibilityJSON: 'v4',
        returnNull: false,
        returnEmptyString: false,
        parseMissingKeyHandler: (key) => (__DEV__ ? key : ''),
      });
    })();
  }

  await initPromise;
}

interface I18nContextValue {
  locale: SupportedLocale;
  setLocale: (locale: SupportedLocale) => Promise<void>;
  t: (key: string, params?: Record<string, string | number>) => string;
}

export function I18nProvider({ children }: { children: ReactNode }) {
  const [ready, setReady] = useState(i18n.isInitialized);

  useEffect(() => {
    let mounted = true;

    void initI18n().finally(() => {
      if (mounted) {
        setReady(true);
      }
    });

    return () => {
      mounted = false;
    };
  }, []);

  if (!ready) {
    return null;
  }

  return createElement(I18nextProvider, { i18n }, children);
}

export function useI18n(): I18nContextValue {
  const { t, i18n: instance } = useTranslation();

  const locale = normalizeLocale(instance.resolvedLanguage ?? instance.language);

  const setLocale = useCallback(async (nextLocale: SupportedLocale) => {
    const normalized = normalizeLocale(nextLocale);
    await instance.changeLanguage(normalized);
    await AsyncStorage.setItem(LANGUAGE_STORAGE_KEY, normalized);
  }, [instance]);

  const translate = useCallback((key: string, params?: Record<string, string | number>) => {
    const hasKey = instance.exists(key);
    if (!hasKey) {
      return __DEV__ ? key : '';
    }

    return t(key, params);
  }, [instance, t]);

  return useMemo(() => ({
    locale,
    setLocale,
    t: translate,
  }), [locale, setLocale, translate]);
}

export { LANGUAGE_STORAGE_KEY };

===== FILE: apps/mobile/src/shared/i18n/keys.ts =====
export const I18N_KEYS = {
  common: {
    buttons: {
      save: 'common.buttons.save',
      cancel: 'common.buttons.cancel',
      retry: 'common.buttons.retry',
      delete: 'common.buttons.delete',
    },
    navigation: {
      tabs: {
        home: {
          label: 'common.navigation.tabs.home.label',
        },
        transactions: {
          label: 'common.navigation.tabs.transactions.label',
          shortLabel: 'common.navigation.tabs.transactions.shortLabel',
        },
        analytics: {
          label: 'common.navigation.tabs.analytics.label',
          shortLabel: 'common.navigation.tabs.analytics.shortLabel',
        },
        groups: {
          label: 'common.navigation.tabs.groups.label',
          shortLabel: 'common.navigation.tabs.groups.shortLabel',
        },
        add: {
          label: 'common.navigation.tabs.add.label',
        },
        profile: {
          label: 'common.navigation.tabs.profile.label',
          shortLabel: 'common.navigation.tabs.profile.shortLabel',
        },
      },
      stacks: {
        dashboard: {
          headerTitle: 'common.navigation.stacks.dashboard.header.title',
        },
        analytics: {
          headerTitle: 'common.navigation.stacks.analytics.header.title',
        },
        aiAdvisor: {
          headerTitle: 'common.navigation.stacks.aiAdvisor.header.title',
        },
        weeklyReport: {
          headerTitle: 'common.navigation.stacks.weeklyReport.header.title',
        },
        budgets: {
          headerTitle: 'common.navigation.stacks.budgets.header.title',
        },
        groups: {
          headerTitle: 'common.navigation.stacks.groups.header.title',
        },
        createGroup: {
          headerTitle: 'common.navigation.stacks.createGroup.header.title',
        },
        groupDetail: {
          headerTitle: 'common.navigation.stacks.groupDetail.header.title',
        },
        addGroupExpense: {
          headerTitle: 'common.navigation.stacks.addGroupExpense.header.title',
        },
        settleUp: {
          headerTitle: 'common.navigation.stacks.settleUp.header.title',
        },
        transfer: {
          headerTitle: 'common.navigation.stacks.transfer.header.title',
        },
        recurring: {
          headerTitle: 'common.navigation.stacks.recurring.header.title',
        },
        scanReceipt: {
          headerTitle: 'common.navigation.stacks.scanReceipt.header.title',
        },
        camera: {
          headerTitle: 'common.navigation.stacks.camera.header.title',
        },
        reviewScan: {
          headerTitle: 'common.navigation.stacks.reviewScan.header.title',
        },
        profile: {
          headerTitle: 'common.navigation.stacks.profile.header.title',
        },
        editProfile: {
          headerTitle: 'common.navigation.stacks.editProfile.header.title',
        },
        settings: {
          headerTitle: 'common.navigation.stacks.settings.header.title',
        },
        security: {
          headerTitle: 'common.navigation.stacks.security.header.title',
        },
        about: {
          headerTitle: 'common.navigation.stacks.about.header.title',
        },
        accounts: {
          headerTitle: 'common.navigation.stacks.accounts.header.title',
        },
      },
      preview: {
        screen: {
          header: {
            title: 'common.navigation.preview.screen.header.title',
            suffix: 'common.navigation.preview.screen.header.suffix',
          },
        },
      },
    },
  },
} as const;

===== FILE: apps/mobile/src/shared/i18n/locales/en.json =====
{
  "accounts": {
    "baseCurrency": {
      "empty": "No base currency yet. Pick one for your first account.",
      "value": "Base currency: {{currency}}"
    },
    "form": {
      "create": "Create Account",
      "creating": "Creating...",
      "currencyLabel": "Currency",
      "currencyPlaceholder": "USD",
      "nameLabel": "Account name",
      "namePlaceholder": "e.g. Main Bank",
      "typeLabel": "Type"
    },
    "sections": {
      "baseCurrency": {
        "subtitle": "Locked for all accounts after first setup",
        "title": "Base Currency"
      },
      "create": {
        "title": "Create Account"
      },
      "list": {
        "title": "Your Accounts",
        "total": "{{count}} total"
      },
      "session": {
        "title": "Account Session"
      }
    },
    "session": {
      "signedIn": "Signed in"
    },
    "state": {
      "empty": "No accounts created yet.",
      "loadErrorTitle": "Could not load accounts",
      "loading": "Loading accounts..."
    }
  },
  "advisor": {
    "advice": "Advice",
    "expense": "Expense",
    "income": "Income",
    "monthlySnapshot": "Monthly Snapshot",
    "net": "Net",
    "nextActions": "Next Actions",
    "noActions": "No action items right now.",
    "noAdvice": "No advice for this month yet.",
    "severity": {
      "info": "Info",
      "success": "Success",
      "warning": "Warning"
    },
    "state": {
      "errorTitle": "Advisor unavailable",
      "noData": "No advisor data available."
    },
    "subtitle": "Personalized insights from your monthly activity.",
    "title": "AI Financial Advisor"
  },
  "aiAdvisor": {
    "advice": "Advice",
    "expense": "Expense",
    "income": "Income",
    "monthlySnapshot": "Monthly Snapshot",
    "net": "Net",
    "nextActions": "Next Actions",
    "noActions": "No action items right now.",
    "noAdvice": "No advice for this month yet.",
    "severity": {
      "info": "Info",
      "success": "Success",
      "warning": "Warning"
    },
    "state": {
      "errorTitle": "Advisor unavailable",
      "noData": "No advisor data available."
    },
    "subtitle": "Personalized insights from your monthly activity.",
    "title": "AI Financial Advisor"
  },
  "analytics": {
    "aiAdvisor": "AI Advisor",
    "aiAdvisorCta": "Open AI Advisor",
    "aiAdvisorSubtitle": "Review personalized action items.",
    "dailyTrends": "Daily Trends",
    "days": {
      "fri": "Fri",
      "mon": "Mon",
      "sat": "Sat",
      "sun": "Sun",
      "thu": "Thu",
      "tue": "Tue",
      "wed": "Wed"
    },
    "expense": "Expense",
    "fromLastMonth": "%{{percent}} from last month",
    "income": "Income",
    "last7Days": "Last 7 Days",
    "loadingCategories": "Loading categories...",
    "mainCategory": "Main Category",
    "noCategories": "No category data for this period.",
    "noCategory": "Uncategorized",
    "percentOfTotal": "{{percent}}% of total",
    "premiumInsights": "Premium Insights",
    "range": {
      "monthly": "Monthly",
      "weekly": "Weekly",
      "yearly": "Yearly"
    },
    "refreshingTrend": "Refreshing trend...",
    "state": {
      "errorTitle": "Analytics unavailable",
      "noData": "No analytics data available."
    },
    "title": "Spending Analysis",
    "topCategories": "Top Categories",
    "totalSpending": "Total Spending",
    "transactionsCount": "{{count}} transactions",
    "weeklyReport": "Weekly Report",
    "weeklyReportSubtitle": "Check your weekly health score."
  },
  "app": {
    "state": {
      "preparing": "Preparing FinSight...",
      "restoring": "Restoring session..."
    }
  },
  "auth": {
    "brandTitle": "Smart Finance AI",
    "common": {
      "apple": "Apple",
      "google": "Google",
      "or": "OR",
      "orContinueWith": "OR CONTINUE WITH"
    },
    "forgot": {
      "fields": {
        "emailLabel": "Email Address",
        "emailPlaceholder": "name@company.com"
      },
      "secureBadge": "SECURE FINANCIAL AI ENCRYPTION",
      "submit": "Send Reset Link",
      "subtitle": "Enter your email address to receive a password reset link. We'll help you get back into your financial dashboard.",
      "success": "If this email exists, reset instructions were sent.",
      "title": "Forgot Password"
    },
    "links": {
      "haveAccount": "Already have an account?",
      "joinNow": "Join Now",
      "noAccount": "Don't have an account?",
      "signIn": "Sign In"
    },
    "login": {
      "fallbackError": "Unable to sign in. Please try again.",
      "fields": {
        "emailLabel": "Email Address",
        "emailPlaceholder": "name@company.com",
        "passwordLabel": "Password",
        "passwordPlaceholder": "••••••••"
      },
      "forgot": "Forgot?",
      "hidePassword": "Hide password",
      "secureBadge": "SECURE ENCRYPTED LOGIN",
      "showPassword": "Show password",
      "submit": "Sign In to Account",
      "subtitle": "Please enter your details to sign in",
      "welcomeBack": "Welcome Back"
    },
    "register": {
      "fallbackError": "Unable to create account.",
      "fields": {
        "emailLabel": "Email Address",
        "emailPlaceholder": "ornek@mail.com",
        "nameLabel": "Full Name",
        "namePlaceholder": "Enter your full name",
        "passwordLabel": "Password"
      },
      "submit": "Create Account",
      "subtitle": "Start managing your financial future with AI",
      "title": "Create Account"
    },
    "validation": {
      "emailInvalid": "Enter a valid email address.",
      "emailRequired": "Email is required.",
      "loginInvalidInput": "Please enter a valid email and password.",
      "nameRequired": "Name is required.",
      "passwordMin": "Password must be at least 8 characters.",
      "passwordRequired": "Password is required.",
      "registerInvalidInput": "Please check your registration details."
    }
  },
  "budgets": {
    "composer": {
      "amountPlaceholder": "0.00",
      "category": "Category",
      "create": "Create Budget",
      "creating": "Creating...",
      "limitAmount": "Limit Amount",
      "noCategories": "All expense categories already have budgets for this month.",
      "title": "Add Budget"
    },
    "delete": {
      "message": "Delete {{category}} budget for {{month}}?",
      "title": "Delete budget"
    },
    "inline": {
      "saveLimit": "Save Limit",
      "updateLimit": "Update limit"
    },
    "overview": {
      "aiHintPrefix": "AI suggests you're on track to save",
      "aiHintSuffix": "this month.",
      "leftLabel": "{{remaining}} left",
      "spentLabel": "{{spent}} spent ({{percent}}%)",
      "totalMonthlyBudget": "TOTAL MONTHLY BUDGET"
    },
    "row": {
      "left": "{{remaining}} left",
      "over": "OVER",
      "spentOf": "Spent {{spent}} of {{limit}}"
    },
    "sections": {
      "spendingCategories": "Spending Categories",
      "viewHistory": "View History"
    },
    "state": {
      "empty": "No budgets set for this month yet.",
      "unavailableTitle": "Budgets unavailable",
      "updating": "Updating budgets..."
    },
    "title": "Budget Planning"
  },
  "common": {
    "appInitials": "FS",
    "appName": "FinSight",
    "cancel": "Cancel",
    "close": "Close",
    "continue": "Continue",
    "delete": "Delete",
    "edit": "Edit",
    "goBack": "Go back",
    "loadingShort": "Loading...",
    "notAvailable": "N/A",
    "now": "Now",
    "pause": "Pause",
    "resume": "Resume",
    "retry": "Retry",
    "save": "Save",
    "saving": "Saving...",
    "view": "View",
    "buttons": {
      "save": "Save",
      "cancel": "Cancel",
      "retry": "Retry",
      "delete": "Delete"
    },
    "navigation": {
      "tabs": {
        "home": {
          "label": "Home"
        },
        "transactions": {
          "label": "Transactions",
          "shortLabel": "Records"
        },
        "analytics": {
          "label": "Analytics",
          "shortLabel": "Insights"
        },
        "groups": {
          "label": "Groups",
          "shortLabel": "Groups"
        },
        "add": {
          "label": "Add"
        },
        "profile": {
          "label": "Profile",
          "shortLabel": "Profile"
        }
      },
      "stacks": {
        "dashboard": {
          "header": {
            "title": "Dashboard"
          }
        },
        "analytics": {
          "header": {
            "title": "Analytics"
          }
        },
        "aiAdvisor": {
          "header": {
            "title": "AI Advisor"
          }
        },
        "weeklyReport": {
          "header": {
            "title": "Weekly Report"
          }
        },
        "budgets": {
          "header": {
            "title": "Budgets"
          }
        },
        "groups": {
          "header": {
            "title": "Split Groups"
          }
        },
        "createGroup": {
          "header": {
            "title": "Create Group"
          }
        },
        "groupDetail": {
          "header": {
            "title": "Group Detail"
          }
        },
        "addGroupExpense": {
          "header": {
            "title": "Add Group Expense"
          }
        },
        "settleUp": {
          "header": {
            "title": "Settle Up"
          }
        },
        "transfer": {
          "header": {
            "title": "Transfer"
          }
        },
        "recurring": {
          "header": {
            "title": "Recurring"
          }
        },
        "scanReceipt": {
          "header": {
            "title": "Scan Receipt"
          }
        },
        "camera": {
          "header": {
            "title": "Camera"
          }
        },
        "reviewScan": {
          "header": {
            "title": "Review Scan"
          }
        },
        "profile": {
          "header": {
            "title": "Profile"
          }
        },
        "editProfile": {
          "header": {
            "title": "Edit Profile"
          }
        },
        "settings": {
          "header": {
            "title": "Settings"
          }
        },
        "security": {
          "header": {
            "title": "Security"
          }
        },
        "about": {
          "header": {
            "title": "About"
          }
        },
        "accounts": {
          "header": {
            "title": "Accounts"
          }
        }
      },
      "preview": {
        "screen": {
          "header": {
            "title": "Screen Preview",
            "suffix": "Preview"
          }
        }
      }
    }
  },
  "dashboard": {
    "accountFallback": "Account",
    "accountTypes": {
      "bank": "Bank",
      "cash": "Cash",
      "credit": "Credit"
    },
    "accounts": "Accounts",
    "addExpense": "Add Expense",
    "addIncome": "Add Income",
    "aiAction": "Get Insight",
    "aiActive": "AI ACTIVE",
    "aiAdvisor": "AI Advisor",
    "aiAnalysisTitle": "AI Analysis",
    "currentBalance": "Current Balance",
    "expense": "Expense",
    "greeting": "Welcome,",
    "income": "Income",
    "insight": {
      "noSavingsHighlight": "Your savings rate is",
      "noSavingsMessage": "this month. Let's improve it with smart tips.",
      "savingsMessage": "more than your recent average.",
      "thisMonth": "This month you saved"
    },
    "premiumSection": "Premium",
    "quickActions": "Quick Actions",
    "recentTransactions": "Recent Transactions",
    "scanReceipt": "Scan Receipt",
    "state": {
      "errorTitle": "Dashboard unavailable",
      "loading": "Loading dashboard...",
      "noAccounts": "No accounts found.",
      "noData": "No dashboard data available.",
      "noTransactions": "No recent transactions yet."
    },
    "time": {
      "dayWithTime": "{{day}} • {{time}}",
      "today": "Today, {{time}}",
      "yesterday": "Yesterday, {{time}}"
    },
    "transaction": {
      "expenseTitle": "Expense",
      "incomeTitle": "Income",
      "transferContext": "Transfer",
      "transferTitle": "Transfer"
    },
    "trend": {
      "decrease": "Compared to last month -{{percent}}%",
      "increase": "Compared to last month +{{percent}}%",
      "stable": "Compared to last month, stable"
    },
    "viewAll": "See All",
    "weeklyReport": "Weekly Report"
  },
  "debug": {
    "input": {
      "firstPlaceholder": "First input",
      "goLogin": "Go to Login",
      "goRegister": "Go to Register",
      "secondPlaceholder": "Second input",
      "subtitle": "This screen uses plain TextInput only. Check focus/blur logs in Metro console.",
      "title": "Debug Input Isolation"
    }
  },
  "errors": {
    "account": {
      "createFailedTitle": "Create account failed",
      "updateFailedTitle": "Update account failed"
    },
    "auth": {
      "logoutFailedTitle": "Logout failed",
      "sessionNotAvailable": "Session not available"
    },
    "budget": {
      "createFailedTitle": "Create budget failed",
      "deleteFailedTitle": "Delete budget failed",
      "updateFailedTitle": "Update budget failed"
    },
    "recurring": {
      "createFailedTitle": "Create recurring failed",
      "deleteFailedTitle": "Delete recurring failed",
      "updateFailedTitle": "Update recurring failed"
    },
    "transaction": {
      "createFailedTitle": "Create transaction failed"
    },
    "transfer": {
      "createFailedTitle": "Transfer failed"
    }
  },
  "groups": {
    "create": {
      "actions": {
        "create": "Create Group",
        "creating": "Creating..."
      },
      "errors": {
        "createFailedTitle": "Create group failed"
      },
      "fields": {
        "membersLabel": "Members (comma separated emails)",
        "membersPlaceholder": "alice@mail.com, bob@mail.com",
        "nameLabel": "Group name",
        "namePlaceholder": "Weekend trip"
      },
      "previewCount": "{{count}} members will be added",
      "subtitle": "Set up a shared expense group",
      "title": "Create Group",
      "validation": {
        "nameRequired": "Group name is required"
      }
    },
    "list": {
      "createButton": "Create Group",
      "empty": "No groups yet. Create one to start splitting.",
      "errorTitle": "Could not load groups",
      "loading": "Loading groups...",
      "memberCount": "{{count}} members",
      "subtitle": "Track shared expenses and balances",
      "title": "Groups"
    },
    "settle": {
      "actions": {
        "markSettled": "Mark Settled",
        "settling": "Settling..."
      },
      "errorTitle": "Settle up failed",
      "loadErrorTitle": "Could not load group",
      "loading": "Loading group data...",
      "openAmount": "Open amount",
      "openExpenses": "Open expenses",
      "subtitle": "Mark all open group expenses as settled",
      "successMessage": "Group expenses were marked as settled.",
      "successTitle": "Settled",
      "title": "Settle Up"
    }
  },
  "navigation": {
    "stack": {
      "about": "About",
      "accounts": "Accounts",
      "addGroupExpense": "Add Group Expense",
      "aiAdvisor": "AI Advisor",
      "analytics": "Analytics",
      "budgets": "Budgets",
      "camera": "Camera",
      "createGroup": "Create Group",
      "dashboard": "Dashboard",
      "editProfile": "Edit Profile",
      "groupDetail": "Group Detail",
      "profile": "Profile",
      "recurring": "Recurring",
      "reviewScan": "Review Scan",
      "scanReceipt": "Scan Receipt",
      "security": "Security",
      "settings": "Settings",
      "settleUp": "Settle Up",
      "splitGroups": "Split Groups",
      "transfer": "Transfer",
      "weeklyReport": "Weekly Report"
    },
    "tabs": {
      "add": "Add",
      "analytics": "Analytics",
      "analyticsShort": "Insights",
      "groups": "Groups",
      "groupsShort": "Groups",
      "home": "Home",
      "profile": "Profile",
      "profileShort": "Profile",
      "transactions": "Transactions",
      "transactionsShort": "Records"
    }
  },
  "onboarding": {
    "getStarted": "Get started",
    "next": "Next",
    "skip": "Skip",
    "step1": {
      "subtitle": "Keep every expense, income, and transfer in one clear timeline built for daily finance habits.",
      "title": "Track everything"
    },
    "step2": {
      "subtitle": "See category breakdowns, monthly trends, and budget usage so you always know where money goes.",
      "title": "Understand spending"
    },
    "step3": {
      "subtitle": "Create your account or sign in, then personalize accounts, categories, and budgets in minutes.",
      "titleGate": "Ready to begin?",
      "titlePreview": "You are all set"
    },
    "stepLabel": "Step {{current}}/{{total}}"
  },
  "profile": {
    "about": {
      "appNameLabel": "App Name",
      "buildLabel": "Build",
      "buildValue": "Development",
      "noteOne": "FinSight helps track accounts, transactions, analytics, and budgets using a single base currency.",
      "noteTwo": "Authentication includes access and refresh tokens with guarded navigation.",
      "notesTitle": "Notes",
      "subtitle": "Product and build information",
      "title": "About FinSight",
      "versionLabel": "Version",
      "versionValue": "1.0.0"
    },
    "accountSettings": "ACCOUNT & SETTINGS",
    "accounts": "Accounts",
    "baseCurrency": "Base Currency",
    "defaultUserName": "FinSight User",
    "edit": {
      "baseCurrencyLabel": "Base Currency",
      "emailLabel": "Email",
      "fullNameLabel": "Full Name",
      "fullNamePlaceholder": "Your full name",
      "helper": "Profile update endpoint is not available yet. UI is ready for PATCH /me integration.",
      "photoSubtitle": "Tap to change (UI only)",
      "photoTitle": "Profile Photo",
      "save": "Save Changes",
      "updateNotAvailableCode": "PROFILE_UPDATE_NOT_AVAILABLE"
    },
    "lastSync": "Last Sync",
    "logOut": "Log out",
    "loggingOut": "Signing out...",
    "premiumMember": "PREMIUM MEMBER",
    "rows": {
      "about": "About FinSight",
      "aboutSubtitle": "Version and legal information",
      "aiAdvisor": "AI Advisor",
      "aiAdvisorSubtitle": "Open personalized financial advice",
      "appSettings": "Settings",
      "appSettingsSubtitle": "Theme and application preferences",
      "myAccounts": "My accounts",
      "myAccountsSubtitle": "View and manage your accounts",
      "personalInfo": "Personal info",
      "personalInfoSubtitle": "Name, email and profile details",
      "security": "Security",
      "securitySubtitle": "Password and session protection",
      "weeklyReport": "Weekly Report",
      "weeklyReportSubtitle": "View score and weekly outlook"
    },
    "security": {
      "delete": {
        "cta": "Delete Account and All Data",
        "hint": "This action is permanent and cannot be undone.",
        "notAvailable": "This action is not available yet.",
        "title": "Delete Account"
      },
      "items": {
        "accountActivity": {
          "subtitle": "Review recent devices",
          "title": "Account Activity"
        },
        "biometric": {
          "subtitle": "Use Face ID or Fingerprint",
          "title": "Biometric Login"
        },
        "downloadData": {
          "subtitle": "Request export package",
          "title": "Download Personal Data"
        },
        "privacyPolicy": {
          "subtitle": "How FinSight protects data",
          "title": "Privacy Policy"
        },
        "thirdParty": {
          "subtitle": "Manage partner data access",
          "title": "Third-party Sharing"
        },
        "twoFactor": {
          "subtitle": "Extra verification for sign in",
          "title": "Two-Factor Authentication"
        }
      },
      "scoreSubtitle": "2 of 3 recommended controls are active.",
      "scoreTitle": "Security Score: Strong",
      "sections": {
        "accessControl": "ACCESS CONTROL",
        "dangerZone": "DANGER ZONE",
        "dataPrivacy": "DATA & PRIVACY"
      }
    },
    "settings": {
      "items": {
        "biometric": {
          "subtitle": "Use Face ID / Fingerprint",
          "title": "Biometric Login"
        },
        "helpCenter": {
          "subtitle": "Guides and support",
          "title": "Help Center"
        },
        "howItWorks": {
          "subtitle": "View onboarding again",
          "title": "How it works"
        },
        "language": {
          "subtitle": "Choose app language",
          "title": "Language"
        },
        "notifications": {
          "subtitle": "Receive important updates",
          "title": "Notifications"
        },
        "security": {
          "subtitle": "Advanced security settings",
          "title": "Security"
        },
        "theme": {
          "subtitle": "System, light, or dark",
          "title": "Theme"
        },
        "version": {
          "subtitle": "FinSight 1.0.0",
          "title": "Version"
        }
      },
      "plan": "Premium Plan",
      "sections": {
        "application": "Application",
        "privacy": "Privacy",
        "support": "Support"
      },
      "userTitle": "Demo User"
    },
    "support": "SUPPORT",
    "useDifferentAccount": "Use a different account"
  },
  "recurring": {
    "actions": {
      "create": "Create Rule"
    },
    "cadence": {
      "monthly": "MONTHLY",
      "weekly": "WEEKLY"
    },
    "delete": {
      "message": "Delete this recurring rule?",
      "title": "Delete recurring rule"
    },
    "fields": {
      "account": "Account",
      "amount": "Amount",
      "amountPlaceholder": "0.00",
      "cadence": "Cadence",
      "categoryWithType": "Category ({{type}})",
      "dayOfMonth": "Day of month (1-28)",
      "dayOfWeek": "Day of week (0=Sun ... 6=Sat)",
      "dayPlaceholder": "1",
      "description": "Description",
      "descriptionPlaceholder": "Optional note",
      "fromAccount": "From account",
      "kind": "Kind",
      "startAt": "Start At (ISO)",
      "startAtPlaceholder": "2026-02-17T10:30:00.000Z",
      "toAccount": "To account",
      "type": "Type"
    },
    "kind": {
      "normal": "NORMAL",
      "transfer": "TRANSFER"
    },
    "rule": {
      "account": "Account: {{account}}",
      "amount": "Amount: {{amount}}",
      "cadence": "Cadence: {{cadence}}",
      "category": "Category: {{category}}",
      "from": "From: {{account}}",
      "nextRun": "Next run: {{date}}",
      "normal": "Normal rule",
      "note": "Note: {{note}}",
      "to": "To: {{account}}",
      "transfer": "Transfer rule",
      "type": "Type: {{type}}"
    },
    "sections": {
      "existing": "Existing Rules",
      "totalRules": "{{count}} rules"
    },
    "state": {
      "empty": "No recurring rules yet.",
      "loading": "Loading recurring data..."
    },
    "status": {
      "active": "ACTIVE",
      "paused": "PAUSED"
    },
    "subtitle": "Create scheduler-ready rules",
    "successMessage": "The rule is now active.",
    "successTitle": "Recurring rule created",
    "title": "Recurring Rules"
  },
  "scan": {
    "camera": {
      "capture": "Capture",
      "permission": {
        "allow": "Allow camera",
        "subtitle": "Allow camera permission to scan receipts.",
        "title": "Camera access needed"
      },
      "state": {
        "preparing": "Preparing camera..."
      }
    },
    "home": {
      "back": "Back to transactions",
      "cta": "Scan receipt",
      "steps": {
        "capture": "Capture receipt image",
        "create": "Create transaction with prefill",
        "review": "Review extracted fields"
      },
      "subtitle": "Capture a bill photo and prefill transaction details in seconds.",
      "title": "Scan Receipt"
    },
    "review": {
      "createTransaction": "Create transaction",
      "defaults": {
        "description": "Receipt transaction"
      },
      "errors": {
        "invalidAmountMessage": "Please enter a positive amount.",
        "invalidAmountTitle": "Invalid amount",
        "invalidDateMessage": "Please enter a valid date (YYYY-MM-DD).",
        "invalidDateTitle": "Invalid date",
        "navigationMessage": "Could not open Add Transaction screen.",
        "navigationTitle": "Navigation error"
      },
      "fields": {
        "amount": "Amount",
        "amountPlaceholder": "0.00",
        "date": "Date",
        "datePlaceholder": "YYYY-MM-DD",
        "merchant": "Merchant",
        "merchantPlaceholder": "Merchant name"
      },
      "formTitle": "Extracted Fields (Mock)",
      "previewTitle": "Receipt Preview",
      "retake": "Retake photo"
    }
  },
  "split": {
    "addExpense": {
      "actions": {
        "submit": "Create Expense",
        "submitting": "Saving..."
      },
      "categoryOptions": {
        "bills": "Bills",
        "food": "Food",
        "other": "Other",
        "rent": "Rent",
        "shopping": "Shopping",
        "transport": "Transport"
      },
      "equalShare": "{{amount}}",
      "errors": {
        "createFailedTitle": "Create expense failed",
        "invalidAmountMessage": "Please enter a positive amount.",
        "invalidAmountTitle": "Invalid amount",
        "invalidCustomSplitMessage": "Enter valid non-negative amounts for each selected member.",
        "invalidCustomSplitTitle": "Invalid custom split",
        "membersRequiredMessage": "Please select at least one member.",
        "membersRequiredTitle": "Members required",
        "paidByRequiredMessage": "Please choose who paid.",
        "paidByRequiredTitle": "Paid by required",
        "requiredTitleMessage": "Please enter an expense title.",
        "requiredTitleTitle": "Title required",
        "splitMismatchMessage": "Amount {{amount}} does not match split total {{split}}.",
        "splitMismatchTitle": "Split total mismatch"
      },
      "fields": {
        "amountLabel": "Amount",
        "amountPlaceholder": "0.00",
        "categoryLabel": "Category",
        "dateLabel": "Date",
        "datePlaceholder": "YYYY-MM-DD",
        "membersLabel": "Members",
        "paidByLabel": "Paid by",
        "paidByPlaceholder": "Select member",
        "splitForMemberLabel": "Split: {{name}}",
        "splitModeLabel": "Split mode",
        "titleLabel": "Title",
        "titlePlaceholder": "Dinner"
      },
      "loadErrorTitle": "Could not load group",
      "loading": "Loading group members...",
      "memberSelectedCount": "{{count}} members selected",
      "retry": "Retry",
      "sections": {
        "customPreview": "Custom split amounts",
        "equalPreview": "Equal split preview"
      },
      "splitModes": {
        "custom": "Custom",
        "equal": "Equal"
      },
      "subtitle": "{{group}}",
      "title": "Add Group Expense"
    },
    "common": {
      "unknownMember": "Unknown member"
    },
    "groupDetail": {
      "actions": {
        "addExpense": "Add Expense",
        "settleUp": "Settle Up"
      },
      "balanceState": {
        "creditor": "You are creditor",
        "debtor": "You are debtor",
        "settled": "Balanced"
      },
      "expenseSubtitle": "{{payer}} • {{date}}",
      "indicator": {
        "noShare": "No share",
        "settled": "Settled",
        "unknownShare": "Share unavailable",
        "youGet": "You get {{amount}}",
        "youOwe": "You owe {{amount}}"
      },
      "loadErrorTitle": "Could not load group details",
      "loading": "Loading group details...",
      "member": {
        "balanced": "Balanced",
        "creditor": "Creditor",
        "debtor": "Debtor"
      },
      "membersTitle": "Members",
      "noExpenses": "No group expenses yet.",
      "recentExpenses": "Recent Expenses",
      "retry": "Retry",
      "summarySubtitle": "Shared expenses overview",
      "summaryTitle": "Group Summary",
      "totalSpending": "Total spending",
      "yourBalance": "Your balance"
    }
  },
  "stitch": {
    "hub": {
      "codeHtml": "code.html",
      "dark": "dark",
      "noApi": "No API",
      "pngOnly": "png only",
      "staticPlaceholders": "Static placeholders",
      "totalScreens": "{{count}} Stitch screens"
    },
    "preview": {
      "analytics": {
        "food": "Food",
        "highlights": "Highlights",
        "savings": "Savings",
        "spendingTrend": "Spending Trend",
        "weeklyBars": "Weekly bars"
      },
      "auth": {
        "authenticationForm": "Authentication Form",
        "onboardingLoginPlaceholder": "Onboarding / login placeholder",
        "phoneOtp": "Phone / OTP"
      },
      "chips": {
        "codeHtmlUsed": "code.html hierarchy used",
        "darkVariant": "Dark variant",
        "lightVariant": "Light variant",
        "pngPlaceholder": "png-driven placeholder"
      },
      "dashboard": {
        "accountSnapshot": "Account Snapshot",
        "categoryPulse": "Category Pulse",
        "currentBalance": "Current Balance",
        "monthlyIncome": "Monthly Income",
        "overviewCards": "Overview cards",
        "recentActivity": "Recent Activity",
        "topCategories": "Top categories",
        "updated1mAgo": "Updated 1m ago"
      },
      "errors": {
        "notFoundBody": "The requested Stitch screen key does not exist in the inventory.",
        "notFoundTitle": "Screen not found"
      },
      "other": {
        "budgetTips": "Budget Tips",
        "contentUtility": "Content / Utility",
        "debtGuide": "Debt Guide",
        "faq": "FAQ",
        "helpCenterDescription": "Category cards, article previews, and quick links are represented here as static placeholders.",
        "helpCenterDetailPages": "Help center + detail pages",
        "helpCenterTitle": "FinSight Help Center"
      },
      "profile": {
        "sampleEmail": "user@finsight.app",
        "summary": "Profile Summary"
      },
      "scan": {
        "alignReceipt": "Align receipt in frame",
        "cameraFramePlaceholder": "Camera frame placeholder",
        "captureReceipt": "Capture Receipt",
        "receiptScan": "Receipt Scan"
      },
      "split": {
        "accommodation": "Accommodation",
        "aylinOwesYou": "Aylin owes you",
        "carRental": "Car rental",
        "expenseSplitScenario": "Expense split scenario",
        "groupOverview": "Group Overview",
        "memberAylin": "Aylin",
        "memberDeniz": "Deniz",
        "memberMert": "Mert",
        "memberYou": "You",
        "settleGroupExpense": "Settle Group Expense",
        "weekendTrip": "Weekend Trip",
        "youOweMert": "You owe Mert"
      },
      "transactions": {
        "addNew": "Add New Transaction",
        "feed": "Transaction Feed",
        "filtersSubtitle": "List + quick filters"
      }
    }
  },
  "transactionDetail": {
    "actions": {
      "delete": "Delete Transaction",
      "downloadReceipt": "Download Receipt",
      "splitExpense": "Split Expense"
    },
    "fields": {
      "account": "Account",
      "category": "Category",
      "dateTime": "Date & Time",
      "noCategory": "No category"
    },
    "location": {
      "placeholder": "Barbaros Mah. No:3, Istanbul"
    },
    "notes": {
      "empty": "No description was added for this transaction.",
      "title": "My Notes"
    },
    "receipt": {
      "title": "Digital Receipt"
    },
    "state": {
      "loadErrorTitle": "Could not load transaction details",
      "loading": "Loading transaction details..."
    },
    "status": {
      "completed": "Completed"
    },
    "title": "Transaction Detail"
  },
  "transactions": {
    "accountFallback": "Account",
    "actions": {
      "loadMore": "Load more",
      "search": "Search"
    },
    "create": {
      "fields": {
        "account": "Account",
        "amount": "Amount",
        "amountPlaceholder": "0.00",
        "category": "Category",
        "currency": "Currency",
        "description": "Description",
        "descriptionPlaceholder": "Optional note",
        "occurredAt": "Date & Time (ISO)",
        "occurredAtPlaceholder": "2026-02-17T10:30:00.000Z"
      },
      "sections": {
        "details": "Transaction Details",
        "step": "Step 1 of 1"
      },
      "selectAccountFirst": "Select account first",
      "state": {
        "loadErrorTitle": "Could not load transaction form",
        "loading": "Loading add transaction form..."
      },
      "submit": "Save Transaction",
      "subtitle": "Create a new income or expense record.",
      "successMessage": "The transaction was saved successfully.",
      "successTitle": "Transaction created",
      "title": "Add Transaction"
    },
    "filters": {
      "all": "All"
    },
    "group": {
      "other": "OTHER",
      "today": "TODAY",
      "yesterday": "YESTERDAY"
    },
    "quickActions": {
      "scanSubtitle": "Receipt OCR flow",
      "scanTitle": "Scan",
      "splitSubtitle": "Groups & settle up",
      "splitTitle": "Split"
    },
    "row": {
      "expenseTitle": "Expense",
      "incomeTitle": "Income",
      "transferBadge": "TRANSFER",
      "transferHint": "Transfer • {{time}}",
      "transferTitle": "Account Transfer",
      "typeHint": "{{type}} • {{time}}"
    },
    "searchPlaceholder": "Search transaction or store...",
    "state": {
      "empty": "No transactions match these filters.",
      "loadErrorTitle": "Could not load transactions",
      "loadingMore": "Loading more..."
    },
    "summary": {
      "totalExpense": "TOTAL EXPENSE",
      "totalIncome": "TOTAL INCOME"
    },
    "title": "Transaction History"
  },
  "transfers": {
    "form": {
      "amount": "Amount",
      "amountPlaceholder": "0.00",
      "description": "Description",
      "descriptionPlaceholder": "Optional note",
      "fromAccount": "From account",
      "occurredAt": "Occurred At (ISO)",
      "occurredAtPlaceholder": "2026-02-17T10:30:00.000Z",
      "submit": "Create Transfer",
      "subtitle": "Creates paired in/out transfer transactions",
      "title": "Transfer Funds",
      "toAccount": "To account"
    },
    "state": {
      "loadingAccounts": "Loading accounts...",
      "needTwoAccounts": "Create at least two accounts before making a transfer."
    },
    "successMessage": "Funds were moved successfully.",
    "successTitle": "Transfer created",
    "title": "Transfer"
  },
  "weeklyReport": {
    "highlights": "Highlights",
    "nextWeekForecast": "Next Week Forecast",
    "noHighlights": "No highlights this week.",
    "noRisks": "No risks detected.",
    "riskFlags": "Risk Flags",
    "scoreOutOf": "/100",
    "state": {
      "errorTitle": "Weekly report unavailable",
      "noData": "No weekly report available."
    },
    "subtitle": "Financial health summary and next-week outlook.",
    "title": "Weekly Report"
  },
  "settings": {
    "general": {
      "title": "Settings"
    },
    "language": {
      "label": "Language"
    },
    "theme": {
      "label": "Theme"
    },
    "notifications": {
      "label": "Notifications"
    }
  }
}

===== FILE: apps/mobile/src/shared/i18n/locales/ru.json =====
{
  "accounts": {
    "baseCurrency": {
      "empty": "No base currency yet. Pick one for your first account.",
      "value": "Base currency: {{currency}}"
    },
    "form": {
      "create": "Create Account",
      "creating": "Creating...",
      "currencyLabel": "Currency",
      "currencyPlaceholder": "USD",
      "nameLabel": "Account name",
      "namePlaceholder": "e.g. Main Bank",
      "typeLabel": "Type"
    },
    "sections": {
      "baseCurrency": {
        "subtitle": "Locked for all accounts after first setup",
        "title": "Base Currency"
      },
      "create": {
        "title": "Create Account"
      },
      "list": {
        "title": "Your Accounts",
        "total": "{{count}} total"
      },
      "session": {
        "title": "Account Session"
      }
    },
    "session": {
      "signedIn": "Signed in"
    },
    "state": {
      "empty": "No accounts created yet.",
      "loadErrorTitle": "Could not load accounts",
      "loading": "Loading accounts..."
    }
  },
  "advisor": {
    "advice": "Советы",
    "expense": "Расход",
    "income": "Доход",
    "monthlySnapshot": "Срез за месяц",
    "net": "Итог",
    "nextActions": "Следующие шаги",
    "noActions": "Сейчас нет действий.",
    "noAdvice": "Пока нет советов за этот месяц.",
    "severity": {
      "info": "Инфо",
      "success": "Хорошо",
      "warning": "Внимание"
    },
    "state": {
      "errorTitle": "Советник недоступен",
      "noData": "Нет данных советника."
    },
    "subtitle": "Персональные рекомендации по вашей активности за месяц.",
    "title": "AI Финансовый советник"
  },
  "aiAdvisor": {
    "advice": "Советы",
    "expense": "Расход",
    "income": "Доход",
    "monthlySnapshot": "Срез за месяц",
    "net": "Итог",
    "nextActions": "Следующие шаги",
    "noActions": "Сейчас нет действий.",
    "noAdvice": "Пока нет советов за этот месяц.",
    "severity": {
      "info": "Инфо",
      "success": "Хорошо",
      "warning": "Внимание"
    },
    "state": {
      "errorTitle": "Советник недоступен",
      "noData": "Нет данных советника."
    },
    "subtitle": "Персональные рекомендации по вашей активности за месяц.",
    "title": "AI Финансовый советник"
  },
  "analytics": {
    "aiAdvisor": "AI Советник",
    "aiAdvisorCta": "Открыть AI Советника",
    "aiAdvisorSubtitle": "Проверьте персональные действия.",
    "dailyTrends": "Дневной тренд",
    "days": {
      "fri": "Пт",
      "mon": "Пн",
      "sat": "Сб",
      "sun": "Вс",
      "thu": "Чт",
      "tue": "Вт",
      "wed": "Ср"
    },
    "expense": "Расход",
    "fromLastMonth": "%{{percent}} к прошлому месяцу",
    "income": "Доход",
    "last7Days": "Последние 7 дней",
    "loadingCategories": "Загрузка категорий...",
    "mainCategory": "Главная категория",
    "noCategories": "Нет данных по категориям за период.",
    "noCategory": "Без категории",
    "percentOfTotal": "{{percent}}% от общего",
    "premiumInsights": "Премиум инсайты",
    "range": {
      "monthly": "Месяц",
      "weekly": "Неделя",
      "yearly": "Год"
    },
    "refreshingTrend": "Обновление тренда...",
    "state": {
      "errorTitle": "Аналитика недоступна",
      "noData": "Нет аналитических данных."
    },
    "title": "Анализ расходов",
    "topCategories": "Топ категорий",
    "totalSpending": "Всего расходов",
    "transactionsCount": "{{count}} операций",
    "weeklyReport": "Недельный отчёт",
    "weeklyReportSubtitle": "Проверьте недельный индекс здоровья."
  },
  "app": {
    "state": {
      "preparing": "Подготовка FinSight...",
      "restoring": "Восстановление сессии..."
    }
  },
  "auth": {
    "brandTitle": "Smart Finance AI",
    "common": {
      "apple": "Apple",
      "google": "Google",
      "or": "OR",
      "orContinueWith": "OR CONTINUE WITH"
    },
    "forgot": {
      "fields": {
        "emailLabel": "Email Address",
        "emailPlaceholder": "name@company.com"
      },
      "secureBadge": "SECURE FINANCIAL AI ENCRYPTION",
      "submit": "Send Reset Link",
      "subtitle": "Enter your email address to receive a password reset link. We'll help you get back into your financial dashboard.",
      "success": "If this email exists, reset instructions were sent.",
      "title": "Forgot Password"
    },
    "links": {
      "haveAccount": "Already have an account?",
      "joinNow": "Join Now",
      "noAccount": "Don't have an account?",
      "signIn": "Sign In"
    },
    "login": {
      "fallbackError": "Unable to sign in. Please try again.",
      "fields": {
        "emailLabel": "Email Address",
        "emailPlaceholder": "name@company.com",
        "passwordLabel": "Password",
        "passwordPlaceholder": "••••••••"
      },
      "forgot": "Forgot?",
      "hidePassword": "Hide password",
      "secureBadge": "SECURE ENCRYPTED LOGIN",
      "showPassword": "Show password",
      "submit": "Sign In to Account",
      "subtitle": "Please enter your details to sign in",
      "welcomeBack": "Welcome Back"
    },
    "register": {
      "fallbackError": "Unable to create account.",
      "fields": {
        "emailLabel": "Email Address",
        "emailPlaceholder": "ornek@mail.com",
        "nameLabel": "Full Name",
        "namePlaceholder": "Enter your full name",
        "passwordLabel": "Password"
      },
      "submit": "Create Account",
      "subtitle": "Start managing your financial future with AI",
      "title": "Create Account"
    },
    "validation": {
      "emailInvalid": "Enter a valid email address.",
      "emailRequired": "Email is required.",
      "loginInvalidInput": "Please enter a valid email and password.",
      "nameRequired": "Name is required.",
      "passwordMin": "Password must be at least 8 characters.",
      "passwordRequired": "Password is required.",
      "registerInvalidInput": "Please check your registration details."
    }
  },
  "budgets": {
    "composer": {
      "amountPlaceholder": "0.00",
      "category": "Category",
      "create": "Create Budget",
      "creating": "Creating...",
      "limitAmount": "Limit Amount",
      "noCategories": "All expense categories already have budgets for this month.",
      "title": "Add Budget"
    },
    "delete": {
      "message": "Delete {{category}} budget for {{month}}?",
      "title": "Delete budget"
    },
    "inline": {
      "saveLimit": "Save Limit",
      "updateLimit": "Update limit"
    },
    "overview": {
      "aiHintPrefix": "AI suggests you're on track to save",
      "aiHintSuffix": "this month.",
      "leftLabel": "{{remaining}} left",
      "spentLabel": "{{spent}} spent ({{percent}}%)",
      "totalMonthlyBudget": "TOTAL MONTHLY BUDGET"
    },
    "row": {
      "left": "{{remaining}} left",
      "over": "OVER",
      "spentOf": "Spent {{spent}} of {{limit}}"
    },
    "sections": {
      "spendingCategories": "Spending Categories",
      "viewHistory": "View History"
    },
    "state": {
      "empty": "No budgets set for this month yet.",
      "unavailableTitle": "Budgets unavailable",
      "updating": "Updating budgets..."
    },
    "title": "Budget Planning"
  },
  "common": {
    "appInitials": "FS",
    "appName": "FinSight",
    "cancel": "Cancel",
    "close": "Close",
    "continue": "Continue",
    "delete": "Delete",
    "edit": "Edit",
    "goBack": "Go back",
    "loadingShort": "Загрузка...",
    "notAvailable": "Н/Д",
    "now": "Now",
    "pause": "Pause",
    "resume": "Resume",
    "retry": "Повторить",
    "save": "Save",
    "saving": "Saving...",
    "view": "View",
    "buttons": {
      "save": "Сохранить",
      "cancel": "Отмена",
      "retry": "Повторить",
      "delete": "Удалить"
    },
    "navigation": {
      "tabs": {
        "home": {
          "label": "Главная"
        },
        "transactions": {
          "label": "Операции",
          "shortLabel": "Операции"
        },
        "analytics": {
          "label": "Аналитика",
          "shortLabel": "Аналитика"
        },
        "groups": {
          "label": "Группы",
          "shortLabel": "Группы"
        },
        "add": {
          "label": "Добавить"
        },
        "profile": {
          "label": "Профиль",
          "shortLabel": "Профиль"
        }
      },
      "stacks": {
        "dashboard": {
          "header": {
            "title": "Панель"
          }
        },
        "analytics": {
          "header": {
            "title": "Аналитика"
          }
        },
        "aiAdvisor": {
          "header": {
            "title": "AI Советник"
          }
        },
        "weeklyReport": {
          "header": {
            "title": "Недельный отчёт"
          }
        },
        "budgets": {
          "header": {
            "title": "Бюджеты"
          }
        },
        "groups": {
          "header": {
            "title": "Группы расходов"
          }
        },
        "createGroup": {
          "header": {
            "title": "Создать группу"
          }
        },
        "groupDetail": {
          "header": {
            "title": "Детали группы"
          }
        },
        "addGroupExpense": {
          "header": {
            "title": "Добавить расход группы"
          }
        },
        "settleUp": {
          "header": {
            "title": "Закрыть баланс"
          }
        },
        "transfer": {
          "header": {
            "title": "Перевод"
          }
        },
        "recurring": {
          "header": {
            "title": "Регулярные"
          }
        },
        "scanReceipt": {
          "header": {
            "title": "Скан чека"
          }
        },
        "camera": {
          "header": {
            "title": "Камера"
          }
        },
        "reviewScan": {
          "header": {
            "title": "Проверка скана"
          }
        },
        "profile": {
          "header": {
            "title": "Профиль"
          }
        },
        "editProfile": {
          "header": {
            "title": "Редактировать профиль"
          }
        },
        "settings": {
          "header": {
            "title": "Настройки"
          }
        },
        "security": {
          "header": {
            "title": "Безопасность"
          }
        },
        "about": {
          "header": {
            "title": "О приложении"
          }
        },
        "accounts": {
          "header": {
            "title": "Счета"
          }
        }
      },
      "preview": {
        "screen": {
          "header": {
            "title": "Предпросмотр экрана",
            "suffix": "Предпросмотр"
          }
        }
      }
    }
  },
  "dashboard": {
    "accountFallback": "Счёт",
    "accountTypes": {
      "bank": "Банк",
      "cash": "Наличные",
      "credit": "Кредит"
    },
    "accounts": "Счета",
    "addExpense": "Добавить расход",
    "addIncome": "Добавить доход",
    "aiAction": "Получить совет",
    "aiActive": "AI АКТИВЕН",
    "aiAdvisor": "AI Советник",
    "aiAnalysisTitle": "AI Анализ",
    "currentBalance": "Текущий баланс",
    "expense": "Расход",
    "greeting": "Добро пожаловать,",
    "income": "Доход",
    "insight": {
      "noSavingsHighlight": "Ваш уровень сбережений",
      "noSavingsMessage": "в этом месяце. Давайте улучшим его с умными подсказками.",
      "savingsMessage": "больше обычного.",
      "thisMonth": "В этом месяце вы сэкономили"
    },
    "premiumSection": "Премиум",
    "quickActions": "Быстрые действия",
    "recentTransactions": "Последние операции",
    "scanReceipt": "Скан чека",
    "state": {
      "errorTitle": "Панель недоступна",
      "loading": "Загрузка панели...",
      "noAccounts": "Счета не найдены.",
      "noData": "Нет данных для панели.",
      "noTransactions": "Пока нет операций."
    },
    "time": {
      "dayWithTime": "{{day}} • {{time}}",
      "today": "Сегодня, {{time}}",
      "yesterday": "Вчера, {{time}}"
    },
    "transaction": {
      "expenseTitle": "Расход",
      "incomeTitle": "Доход",
      "transferContext": "Перевод",
      "transferTitle": "Перевод"
    },
    "trend": {
      "decrease": "-{{percent}}% к прошлому месяцу",
      "increase": "+{{percent}}% к прошлому месяцу",
      "stable": "По сравнению с прошлым месяцем стабильно"
    },
    "viewAll": "Смотреть все",
    "weeklyReport": "Недельный отчёт"
  },
  "debug": {
    "input": {
      "firstPlaceholder": "First input",
      "goLogin": "Go to Login",
      "goRegister": "Go to Register",
      "secondPlaceholder": "Second input",
      "subtitle": "This screen uses plain TextInput only. Check focus/blur logs in Metro console.",
      "title": "Debug Input Isolation"
    }
  },
  "errors": {
    "account": {
      "createFailedTitle": "Create account failed",
      "updateFailedTitle": "Update account failed"
    },
    "auth": {
      "logoutFailedTitle": "Logout failed",
      "sessionNotAvailable": "Session not available"
    },
    "budget": {
      "createFailedTitle": "Create budget failed",
      "deleteFailedTitle": "Delete budget failed",
      "updateFailedTitle": "Update budget failed"
    },
    "recurring": {
      "createFailedTitle": "Create recurring failed",
      "deleteFailedTitle": "Delete recurring failed",
      "updateFailedTitle": "Update recurring failed"
    },
    "transaction": {
      "createFailedTitle": "Create transaction failed"
    },
    "transfer": {
      "createFailedTitle": "Transfer failed"
    }
  },
  "groups": {
    "create": {
      "actions": {
        "create": "Create Group",
        "creating": "Creating..."
      },
      "errors": {
        "createFailedTitle": "Create group failed"
      },
      "fields": {
        "membersLabel": "Members (comma separated emails)",
        "membersPlaceholder": "alice@mail.com, bob@mail.com",
        "nameLabel": "Group name",
        "namePlaceholder": "Weekend trip"
      },
      "previewCount": "{{count}} members will be added",
      "subtitle": "Set up a shared expense group",
      "title": "Create Group",
      "validation": {
        "nameRequired": "Group name is required"
      }
    },
    "list": {
      "createButton": "Create Group",
      "empty": "No groups yet. Create one to start splitting.",
      "errorTitle": "Could not load groups",
      "loading": "Loading groups...",
      "memberCount": "{{count}} members",
      "subtitle": "Track shared expenses and balances",
      "title": "Groups"
    },
    "settle": {
      "actions": {
        "markSettled": "Mark Settled",
        "settling": "Settling..."
      },
      "errorTitle": "Settle up failed",
      "loadErrorTitle": "Could not load group",
      "loading": "Loading group data...",
      "openAmount": "Open amount",
      "openExpenses": "Open expenses",
      "subtitle": "Mark all open group expenses as settled",
      "successMessage": "Group expenses were marked as settled.",
      "successTitle": "Settled",
      "title": "Settle Up"
    }
  },
  "navigation": {
    "stack": {
      "about": "О приложении",
      "accounts": "Счета",
      "addGroupExpense": "Добавить расход группы",
      "aiAdvisor": "AI Советник",
      "analytics": "Аналитика",
      "budgets": "Бюджеты",
      "camera": "Камера",
      "createGroup": "Создать группу",
      "dashboard": "Панель",
      "editProfile": "Редактировать профиль",
      "groupDetail": "Детали группы",
      "profile": "Профиль",
      "recurring": "Регулярные",
      "reviewScan": "Проверка скана",
      "scanReceipt": "Скан чека",
      "security": "Безопасность",
      "settings": "Настройки",
      "settleUp": "Закрыть баланс",
      "splitGroups": "Группы расходов",
      "transfer": "Перевод",
      "weeklyReport": "Недельный отчёт"
    },
    "tabs": {
      "add": "Добавить",
      "analytics": "Аналитика",
      "analyticsShort": "Аналитика",
      "groups": "Группы",
      "groupsShort": "Группы",
      "home": "Главная",
      "profile": "Профиль",
      "profileShort": "Профиль",
      "transactions": "Операции",
      "transactionsShort": "Операции"
    }
  },
  "onboarding": {
    "getStarted": "Get started",
    "next": "Next",
    "skip": "Skip",
    "step1": {
      "subtitle": "Keep every expense, income, and transfer in one clear timeline built for daily finance habits.",
      "title": "Track everything"
    },
    "step2": {
      "subtitle": "See category breakdowns, monthly trends, and budget usage so you always know where money goes.",
      "title": "Understand spending"
    },
    "step3": {
      "subtitle": "Create your account or sign in, then personalize accounts, categories, and budgets in minutes.",
      "titleGate": "Ready to begin?",
      "titlePreview": "You are all set"
    },
    "stepLabel": "Step {{current}}/{{total}}"
  },
  "profile": {
    "about": {
      "appNameLabel": "App Name",
      "buildLabel": "Build",
      "buildValue": "Development",
      "noteOne": "FinSight helps track accounts, transactions, analytics, and budgets using a single base currency.",
      "noteTwo": "Authentication includes access and refresh tokens with guarded navigation.",
      "notesTitle": "Notes",
      "subtitle": "Product and build information",
      "title": "About FinSight",
      "versionLabel": "Version",
      "versionValue": "1.0.0"
    },
    "accountSettings": "АККАУНТ И НАСТРОЙКИ",
    "accounts": "Счета",
    "baseCurrency": "Базовая валюта",
    "defaultUserName": "Пользователь FinSight",
    "edit": {
      "baseCurrencyLabel": "Base Currency",
      "emailLabel": "Email",
      "fullNameLabel": "Full Name",
      "fullNamePlaceholder": "Your full name",
      "helper": "Profile update endpoint is not available yet. UI is ready for PATCH /me integration.",
      "photoSubtitle": "Tap to change (UI only)",
      "photoTitle": "Profile Photo",
      "save": "Save Changes",
      "updateNotAvailableCode": "PROFILE_UPDATE_NOT_AVAILABLE"
    },
    "lastSync": "Последняя синхр.",
    "logOut": "Выйти",
    "loggingOut": "Выход...",
    "premiumMember": "ПРЕМИУМ",
    "rows": {
      "about": "О FinSight",
      "aboutSubtitle": "Версия и правовая информация",
      "aiAdvisor": "AI Советник",
      "aiAdvisorSubtitle": "Открыть персональные советы",
      "appSettings": "Настройки",
      "appSettingsSubtitle": "Тема и параметры приложения",
      "myAccounts": "Мои счета",
      "myAccountsSubtitle": "Просмотр и управление счетами",
      "personalInfo": "Личные данные",
      "personalInfoSubtitle": "Имя, почта и данные профиля",
      "security": "Безопасность",
      "securitySubtitle": "Пароль и защита сессии",
      "weeklyReport": "Недельный отчёт",
      "weeklyReportSubtitle": "Счёт и прогноз на неделю"
    },
    "security": {
      "delete": {
        "cta": "Delete Account and All Data",
        "hint": "This action is permanent and cannot be undone.",
        "notAvailable": "This action is not available yet.",
        "title": "Delete Account"
      },
      "items": {
        "accountActivity": {
          "subtitle": "Review recent devices",
          "title": "Account Activity"
        },
        "biometric": {
          "subtitle": "Use Face ID or Fingerprint",
          "title": "Biometric Login"
        },
        "downloadData": {
          "subtitle": "Request export package",
          "title": "Download Personal Data"
        },
        "privacyPolicy": {
          "subtitle": "How FinSight protects data",
          "title": "Privacy Policy"
        },
        "thirdParty": {
          "subtitle": "Manage partner data access",
          "title": "Third-party Sharing"
        },
        "twoFactor": {
          "subtitle": "Extra verification for sign in",
          "title": "Two-Factor Authentication"
        }
      },
      "scoreSubtitle": "2 of 3 recommended controls are active.",
      "scoreTitle": "Security Score: Strong",
      "sections": {
        "accessControl": "ACCESS CONTROL",
        "dangerZone": "DANGER ZONE",
        "dataPrivacy": "DATA & PRIVACY"
      }
    },
    "settings": {
      "items": {
        "biometric": {
          "subtitle": "Use Face ID / Fingerprint",
          "title": "Biometric Login"
        },
        "helpCenter": {
          "subtitle": "Guides and support",
          "title": "Help Center"
        },
        "howItWorks": {
          "subtitle": "View onboarding again",
          "title": "How it works"
        },
        "language": {
          "subtitle": "Choose app language",
          "title": "Language"
        },
        "notifications": {
          "subtitle": "Receive important updates",
          "title": "Notifications"
        },
        "security": {
          "subtitle": "Advanced security settings",
          "title": "Security"
        },
        "theme": {
          "subtitle": "System, light, or dark",
          "title": "Theme"
        },
        "version": {
          "subtitle": "FinSight 1.0.0",
          "title": "Version"
        }
      },
      "plan": "Premium Plan",
      "sections": {
        "application": "Application",
        "privacy": "Privacy",
        "support": "Support"
      },
      "userTitle": "Demo User"
    },
    "support": "ПОДДЕРЖКА",
    "useDifferentAccount": "Использовать другой аккаунт"
  },
  "recurring": {
    "actions": {
      "create": "Create Rule"
    },
    "cadence": {
      "monthly": "MONTHLY",
      "weekly": "WEEKLY"
    },
    "delete": {
      "message": "Delete this recurring rule?",
      "title": "Delete recurring rule"
    },
    "fields": {
      "account": "Account",
      "amount": "Amount",
      "amountPlaceholder": "0.00",
      "cadence": "Cadence",
      "categoryWithType": "Category ({{type}})",
      "dayOfMonth": "Day of month (1-28)",
      "dayOfWeek": "Day of week (0=Sun ... 6=Sat)",
      "dayPlaceholder": "1",
      "description": "Description",
      "descriptionPlaceholder": "Optional note",
      "fromAccount": "From account",
      "kind": "Kind",
      "startAt": "Start At (ISO)",
      "startAtPlaceholder": "2026-02-17T10:30:00.000Z",
      "toAccount": "To account",
      "type": "Type"
    },
    "kind": {
      "normal": "NORMAL",
      "transfer": "TRANSFER"
    },
    "rule": {
      "account": "Account: {{account}}",
      "amount": "Amount: {{amount}}",
      "cadence": "Cadence: {{cadence}}",
      "category": "Category: {{category}}",
      "from": "From: {{account}}",
      "nextRun": "Next run: {{date}}",
      "normal": "Normal rule",
      "note": "Note: {{note}}",
      "to": "To: {{account}}",
      "transfer": "Transfer rule",
      "type": "Type: {{type}}"
    },
    "sections": {
      "existing": "Existing Rules",
      "totalRules": "{{count}} rules"
    },
    "state": {
      "empty": "No recurring rules yet.",
      "loading": "Loading recurring data..."
    },
    "status": {
      "active": "ACTIVE",
      "paused": "PAUSED"
    },
    "subtitle": "Create scheduler-ready rules",
    "successMessage": "The rule is now active.",
    "successTitle": "Recurring rule created",
    "title": "Recurring Rules"
  },
  "scan": {
    "camera": {
      "capture": "Capture",
      "permission": {
        "allow": "Allow camera",
        "subtitle": "Allow camera permission to scan receipts.",
        "title": "Camera access needed"
      },
      "state": {
        "preparing": "Preparing camera..."
      }
    },
    "home": {
      "back": "Back to transactions",
      "cta": "Scan receipt",
      "steps": {
        "capture": "Capture receipt image",
        "create": "Create transaction with prefill",
        "review": "Review extracted fields"
      },
      "subtitle": "Capture a bill photo and prefill transaction details in seconds.",
      "title": "Scan Receipt"
    },
    "review": {
      "createTransaction": "Create transaction",
      "defaults": {
        "description": "Receipt transaction"
      },
      "errors": {
        "invalidAmountMessage": "Please enter a positive amount.",
        "invalidAmountTitle": "Invalid amount",
        "invalidDateMessage": "Please enter a valid date (YYYY-MM-DD).",
        "invalidDateTitle": "Invalid date",
        "navigationMessage": "Could not open Add Transaction screen.",
        "navigationTitle": "Navigation error"
      },
      "fields": {
        "amount": "Amount",
        "amountPlaceholder": "0.00",
        "date": "Date",
        "datePlaceholder": "YYYY-MM-DD",
        "merchant": "Merchant",
        "merchantPlaceholder": "Merchant name"
      },
      "formTitle": "Extracted Fields (Mock)",
      "previewTitle": "Receipt Preview",
      "retake": "Retake photo"
    }
  },
  "split": {
    "addExpense": {
      "actions": {
        "submit": "Сохранить расход",
        "submitting": "Сохранение..."
      },
      "categoryOptions": {
        "bills": "Счета",
        "food": "Еда",
        "other": "Другое",
        "rent": "Аренда",
        "shopping": "Покупки",
        "transport": "Транспорт"
      },
      "equalShare": "{{amount}}",
      "errors": {
        "createFailedTitle": "Не удалось создать расход",
        "invalidAmountMessage": "Введите положительную сумму.",
        "invalidAmountTitle": "Некорректная сумма",
        "invalidCustomSplitMessage": "Введите корректные неотрицательные суммы для выбранных участников.",
        "invalidCustomSplitTitle": "Некорректные пользовательские доли",
        "membersRequiredMessage": "Выберите хотя бы одного участника.",
        "membersRequiredTitle": "Требуются участники",
        "paidByRequiredMessage": "Выберите, кто оплатил расход.",
        "paidByRequiredTitle": "Требуется плательщик",
        "requiredTitleMessage": "Введите название расхода.",
        "requiredTitleTitle": "Требуется название",
        "splitMismatchMessage": "Сумма {{amount}} не совпадает с суммой долей {{split}}.",
        "splitMismatchTitle": "Сумма долей не совпадает"
      },
      "fields": {
        "amountLabel": "Сумма",
        "amountPlaceholder": "0.00",
        "categoryLabel": "Категория",
        "dateLabel": "Дата",
        "datePlaceholder": "ГГГГ-ММ-ДД",
        "membersLabel": "Участники",
        "paidByLabel": "Оплатил",
        "paidByPlaceholder": "Выберите участника",
        "splitForMemberLabel": "Доля: {{name}}",
        "splitModeLabel": "Режим деления",
        "titleLabel": "Название",
        "titlePlaceholder": "Ужин"
      },
      "loadErrorTitle": "Не удалось загрузить группу",
      "loading": "Загрузка участников группы...",
      "memberSelectedCount": "Выбрано участников: {{count}}",
      "retry": "Повторить",
      "sections": {
        "customPreview": "Пользовательские доли",
        "equalPreview": "Предпросмотр равного деления"
      },
      "splitModes": {
        "custom": "Своя сумма",
        "equal": "Поровну"
      },
      "subtitle": "{{group}}",
      "title": "Добавить групповой расход"
    },
    "common": {
      "unknownMember": "Неизвестный участник"
    },
    "groupDetail": {
      "actions": {
        "addExpense": "Добавить расход",
        "settleUp": "Закрыть долг"
      },
      "balanceState": {
        "creditor": "Вы кредитор",
        "debtor": "Вы должник",
        "settled": "Баланс нулевой"
      },
      "expenseSubtitle": "{{payer}} • {{date}}",
      "indicator": {
        "noShare": "Без доли",
        "settled": "Закрыто",
        "unknownShare": "Доля недоступна",
        "youGet": "Вам должны {{amount}}",
        "youOwe": "Вы должны {{amount}}"
      },
      "loadErrorTitle": "Не удалось загрузить детали группы",
      "loading": "Загрузка деталей группы...",
      "member": {
        "balanced": "Баланс",
        "creditor": "Кредитор",
        "debtor": "Должник"
      },
      "membersTitle": "Участники",
      "noExpenses": "Пока нет групповых расходов.",
      "recentExpenses": "Последние расходы",
      "retry": "Повторить",
      "summarySubtitle": "Обзор совместных расходов",
      "summaryTitle": "Сводка группы",
      "totalSpending": "Общие расходы",
      "yourBalance": "Ваш баланс"
    }
  },
  "stitch": {
    "hub": {
      "codeHtml": "code.html",
      "dark": "dark",
      "noApi": "No API",
      "pngOnly": "png only",
      "staticPlaceholders": "Static placeholders",
      "totalScreens": "{{count}} Stitch screens"
    },
    "preview": {
      "analytics": {
        "food": "Food",
        "highlights": "Highlights",
        "savings": "Savings",
        "spendingTrend": "Spending Trend",
        "weeklyBars": "Weekly bars"
      },
      "auth": {
        "authenticationForm": "Authentication Form",
        "onboardingLoginPlaceholder": "Onboarding / login placeholder",
        "phoneOtp": "Phone / OTP"
      },
      "chips": {
        "codeHtmlUsed": "code.html hierarchy used",
        "darkVariant": "Dark variant",
        "lightVariant": "Light variant",
        "pngPlaceholder": "png-driven placeholder"
      },
      "dashboard": {
        "accountSnapshot": "Account Snapshot",
        "categoryPulse": "Category Pulse",
        "currentBalance": "Current Balance",
        "monthlyIncome": "Monthly Income",
        "overviewCards": "Overview cards",
        "recentActivity": "Recent Activity",
        "topCategories": "Top categories",
        "updated1mAgo": "Updated 1m ago"
      },
      "errors": {
        "notFoundBody": "The requested Stitch screen key does not exist in the inventory.",
        "notFoundTitle": "Screen not found"
      },
      "other": {
        "budgetTips": "Budget Tips",
        "contentUtility": "Content / Utility",
        "debtGuide": "Debt Guide",
        "faq": "FAQ",
        "helpCenterDescription": "Category cards, article previews, and quick links are represented here as static placeholders.",
        "helpCenterDetailPages": "Help center + detail pages",
        "helpCenterTitle": "FinSight Help Center"
      },
      "profile": {
        "sampleEmail": "user@finsight.app",
        "summary": "Profile Summary"
      },
      "scan": {
        "alignReceipt": "Align receipt in frame",
        "cameraFramePlaceholder": "Camera frame placeholder",
        "captureReceipt": "Capture Receipt",
        "receiptScan": "Receipt Scan"
      },
      "split": {
        "accommodation": "Accommodation",
        "aylinOwesYou": "Aylin owes you",
        "carRental": "Car rental",
        "expenseSplitScenario": "Expense split scenario",
        "groupOverview": "Group Overview",
        "memberAylin": "Aylin",
        "memberDeniz": "Deniz",
        "memberMert": "Mert",
        "memberYou": "You",
        "settleGroupExpense": "Settle Group Expense",
        "weekendTrip": "Weekend Trip",
        "youOweMert": "You owe Mert"
      },
      "transactions": {
        "addNew": "Add New Transaction",
        "feed": "Transaction Feed",
        "filtersSubtitle": "List + quick filters"
      }
    }
  },
  "transactionDetail": {
    "actions": {
      "delete": "Delete Transaction",
      "downloadReceipt": "Download Receipt",
      "splitExpense": "Split Expense"
    },
    "fields": {
      "account": "Account",
      "category": "Category",
      "dateTime": "Date & Time",
      "noCategory": "No category"
    },
    "location": {
      "placeholder": "Barbaros Mah. No:3, Istanbul"
    },
    "notes": {
      "empty": "No description was added for this transaction.",
      "title": "My Notes"
    },
    "receipt": {
      "title": "Digital Receipt"
    },
    "state": {
      "loadErrorTitle": "Could not load transaction details",
      "loading": "Loading transaction details..."
    },
    "status": {
      "completed": "Completed"
    },
    "title": "Transaction Detail"
  },
  "transactions": {
    "accountFallback": "Account",
    "actions": {
      "loadMore": "Load more",
      "search": "Search"
    },
    "create": {
      "fields": {
        "account": "Account",
        "amount": "Amount",
        "amountPlaceholder": "0.00",
        "category": "Category",
        "currency": "Currency",
        "description": "Description",
        "descriptionPlaceholder": "Optional note",
        "occurredAt": "Date & Time (ISO)",
        "occurredAtPlaceholder": "2026-02-17T10:30:00.000Z"
      },
      "sections": {
        "details": "Transaction Details",
        "step": "Step 1 of 1"
      },
      "selectAccountFirst": "Select account first",
      "state": {
        "loadErrorTitle": "Could not load transaction form",
        "loading": "Loading add transaction form..."
      },
      "submit": "Save Transaction",
      "subtitle": "Create a new income or expense record.",
      "successMessage": "The transaction was saved successfully.",
      "successTitle": "Transaction created",
      "title": "Add Transaction"
    },
    "filters": {
      "all": "All"
    },
    "group": {
      "other": "OTHER",
      "today": "TODAY",
      "yesterday": "YESTERDAY"
    },
    "quickActions": {
      "scanSubtitle": "Receipt OCR flow",
      "scanTitle": "Scan",
      "splitSubtitle": "Groups & settle up",
      "splitTitle": "Split"
    },
    "row": {
      "expenseTitle": "Expense",
      "incomeTitle": "Income",
      "transferBadge": "TRANSFER",
      "transferHint": "Transfer • {{time}}",
      "transferTitle": "Account Transfer",
      "typeHint": "{{type}} • {{time}}"
    },
    "searchPlaceholder": "Search transaction or store...",
    "state": {
      "empty": "No transactions match these filters.",
      "loadErrorTitle": "Could not load transactions",
      "loadingMore": "Loading more..."
    },
    "summary": {
      "totalExpense": "TOTAL EXPENSE",
      "totalIncome": "TOTAL INCOME"
    },
    "title": "Transaction History"
  },
  "transfers": {
    "form": {
      "amount": "Amount",
      "amountPlaceholder": "0.00",
      "description": "Description",
      "descriptionPlaceholder": "Optional note",
      "fromAccount": "From account",
      "occurredAt": "Occurred At (ISO)",
      "occurredAtPlaceholder": "2026-02-17T10:30:00.000Z",
      "submit": "Create Transfer",
      "subtitle": "Creates paired in/out transfer transactions",
      "title": "Transfer Funds",
      "toAccount": "To account"
    },
    "state": {
      "loadingAccounts": "Loading accounts...",
      "needTwoAccounts": "Create at least two accounts before making a transfer."
    },
    "successMessage": "Funds were moved successfully.",
    "successTitle": "Transfer created",
    "title": "Transfer"
  },
  "weeklyReport": {
    "highlights": "Ключевые моменты",
    "nextWeekForecast": "Прогноз на следующую неделю",
    "noHighlights": "На этой неделе нет ключевых моментов.",
    "noRisks": "Риски не обнаружены.",
    "riskFlags": "Риски",
    "scoreOutOf": "/100",
    "state": {
      "errorTitle": "Недельный отчёт недоступен",
      "noData": "Нет данных недельного отчёта."
    },
    "subtitle": "Сводка финансового здоровья и прогноз на следующую неделю.",
    "title": "Недельный отчёт"
  },
  "settings": {
    "general": {
      "title": "Настройки"
    },
    "language": {
      "label": "Язык"
    },
    "theme": {
      "label": "Тема"
    },
    "notifications": {
      "label": "Уведомления"
    }
  }
}

===== FILE: apps/mobile/src/shared/i18n/locales/tr.json =====
{
  "accounts": {
    "baseCurrency": {
      "empty": "No base currency yet. Pick one for your first account.",
      "value": "Base currency: {{currency}}"
    },
    "form": {
      "create": "Create Account",
      "creating": "Creating...",
      "currencyLabel": "Currency",
      "currencyPlaceholder": "USD",
      "nameLabel": "Account name",
      "namePlaceholder": "e.g. Main Bank",
      "typeLabel": "Type"
    },
    "sections": {
      "baseCurrency": {
        "subtitle": "Locked for all accounts after first setup",
        "title": "Base Currency"
      },
      "create": {
        "title": "Create Account"
      },
      "list": {
        "title": "Your Accounts",
        "total": "{{count}} total"
      },
      "session": {
        "title": "Account Session"
      }
    },
    "session": {
      "signedIn": "Signed in"
    },
    "state": {
      "empty": "No accounts created yet.",
      "loadErrorTitle": "Could not load accounts",
      "loading": "Loading accounts..."
    }
  },
  "advisor": {
    "advice": "Öneriler",
    "expense": "Gider",
    "income": "Gelir",
    "monthlySnapshot": "Aylık Özet",
    "net": "Net",
    "nextActions": "Sonraki Adımlar",
    "noActions": "Şu an aksiyon maddesi yok.",
    "noAdvice": "Bu ay için henüz öneri yok.",
    "severity": {
      "info": "Bilgi",
      "success": "İyi",
      "warning": "Uyarı"
    },
    "state": {
      "errorTitle": "Danışman şu an kullanılamıyor",
      "noData": "Danışman verisi bulunamadı."
    },
    "subtitle": "Aylık hareketlerine göre kişiselleştirilmiş öneriler.",
    "title": "AI Finans Danışmanı"
  },
  "aiAdvisor": {
    "advice": "Öneriler",
    "expense": "Gider",
    "income": "Gelir",
    "monthlySnapshot": "Aylık Özet",
    "net": "Net",
    "nextActions": "Sonraki Adımlar",
    "noActions": "Şu an aksiyon maddesi yok.",
    "noAdvice": "Bu ay için henüz öneri yok.",
    "severity": {
      "info": "Bilgi",
      "success": "İyi",
      "warning": "Uyarı"
    },
    "state": {
      "errorTitle": "Danışman şu an kullanılamıyor",
      "noData": "Danışman verisi bulunamadı."
    },
    "subtitle": "Aylık hareketlerine göre kişiselleştirilmiş öneriler.",
    "title": "AI Finans Danışmanı"
  },
  "analytics": {
    "aiAdvisor": "AI Danışman",
    "aiAdvisorCta": "AI Danışmanı Aç",
    "aiAdvisorSubtitle": "Kişisel aksiyonlarını incele.",
    "dailyTrends": "Günlük Trend",
    "days": {
      "fri": "Cum",
      "mon": "Pzt",
      "sat": "Cts",
      "sun": "Paz",
      "thu": "Per",
      "tue": "Sal",
      "wed": "Çar"
    },
    "expense": "Gider",
    "fromLastMonth": "Geçen aya göre %{{percent}}",
    "income": "Gelir",
    "last7Days": "Son 7 Gün",
    "loadingCategories": "Kategoriler yükleniyor...",
    "mainCategory": "Ana Kategori",
    "noCategories": "Bu dönem için kategori verisi yok.",
    "noCategory": "Kategorisiz",
    "percentOfTotal": "Toplamın %{{percent}}",
    "premiumInsights": "Premium İçgörüler",
    "range": {
      "monthly": "Aylık",
      "weekly": "Haftalık",
      "yearly": "Yıllık"
    },
    "refreshingTrend": "Trend güncelleniyor...",
    "state": {
      "errorTitle": "Analiz yüklenemedi",
      "noData": "Analiz verisi bulunamadı."
    },
    "title": "Harcama Analizi",
    "topCategories": "Öne Çıkan Kategoriler",
    "totalSpending": "Toplam Harcama",
    "transactionsCount": "{{count}} işlem",
    "weeklyReport": "Haftalık Rapor",
    "weeklyReportSubtitle": "Haftalık skorunu kontrol et."
  },
  "app": {
    "state": {
      "preparing": "FinSight hazırlanıyor...",
      "restoring": "Oturum geri yükleniyor..."
    }
  },
  "auth": {
    "brandTitle": "Smart Finance AI",
    "common": {
      "apple": "Apple",
      "google": "Google",
      "or": "OR",
      "orContinueWith": "OR CONTINUE WITH"
    },
    "forgot": {
      "fields": {
        "emailLabel": "Email Address",
        "emailPlaceholder": "name@company.com"
      },
      "secureBadge": "SECURE FINANCIAL AI ENCRYPTION",
      "submit": "Send Reset Link",
      "subtitle": "Enter your email address to receive a password reset link. We'll help you get back into your financial dashboard.",
      "success": "If this email exists, reset instructions were sent.",
      "title": "Forgot Password"
    },
    "links": {
      "haveAccount": "Already have an account?",
      "joinNow": "Join Now",
      "noAccount": "Don't have an account?",
      "signIn": "Sign In"
    },
    "login": {
      "fallbackError": "Unable to sign in. Please try again.",
      "fields": {
        "emailLabel": "Email Address",
        "emailPlaceholder": "name@company.com",
        "passwordLabel": "Password",
        "passwordPlaceholder": "••••••••"
      },
      "forgot": "Forgot?",
      "hidePassword": "Hide password",
      "secureBadge": "SECURE ENCRYPTED LOGIN",
      "showPassword": "Show password",
      "submit": "Sign In to Account",
      "subtitle": "Please enter your details to sign in",
      "welcomeBack": "Welcome Back"
    },
    "register": {
      "fallbackError": "Unable to create account.",
      "fields": {
        "emailLabel": "Email Address",
        "emailPlaceholder": "ornek@mail.com",
        "nameLabel": "Full Name",
        "namePlaceholder": "Enter your full name",
        "passwordLabel": "Password"
      },
      "submit": "Create Account",
      "subtitle": "Start managing your financial future with AI",
      "title": "Create Account"
    },
    "validation": {
      "emailInvalid": "Enter a valid email address.",
      "emailRequired": "Email is required.",
      "loginInvalidInput": "Please enter a valid email and password.",
      "nameRequired": "Name is required.",
      "passwordMin": "Password must be at least 8 characters.",
      "passwordRequired": "Password is required.",
      "registerInvalidInput": "Please check your registration details."
    }
  },
  "budgets": {
    "composer": {
      "amountPlaceholder": "0.00",
      "category": "Category",
      "create": "Create Budget",
      "creating": "Creating...",
      "limitAmount": "Limit Amount",
      "noCategories": "All expense categories already have budgets for this month.",
      "title": "Add Budget"
    },
    "delete": {
      "message": "Delete {{category}} budget for {{month}}?",
      "title": "Delete budget"
    },
    "inline": {
      "saveLimit": "Save Limit",
      "updateLimit": "Update limit"
    },
    "overview": {
      "aiHintPrefix": "AI suggests you're on track to save",
      "aiHintSuffix": "this month.",
      "leftLabel": "{{remaining}} left",
      "spentLabel": "{{spent}} spent ({{percent}}%)",
      "totalMonthlyBudget": "TOTAL MONTHLY BUDGET"
    },
    "row": {
      "left": "{{remaining}} left",
      "over": "OVER",
      "spentOf": "Spent {{spent}} of {{limit}}"
    },
    "sections": {
      "spendingCategories": "Spending Categories",
      "viewHistory": "View History"
    },
    "state": {
      "empty": "No budgets set for this month yet.",
      "unavailableTitle": "Budgets unavailable",
      "updating": "Updating budgets..."
    },
    "title": "Budget Planning"
  },
  "common": {
    "appInitials": "FS",
    "appName": "FinSight",
    "cancel": "Cancel",
    "close": "Close",
    "continue": "Continue",
    "delete": "Delete",
    "edit": "Edit",
    "goBack": "Go back",
    "loadingShort": "Yükleniyor...",
    "notAvailable": "Yok",
    "now": "Now",
    "pause": "Pause",
    "resume": "Resume",
    "retry": "Tekrar Dene",
    "save": "Save",
    "saving": "Saving...",
    "view": "View",
    "buttons": {
      "save": "Kaydet",
      "cancel": "İptal",
      "retry": "Tekrar Dene",
      "delete": "Sil"
    },
    "navigation": {
      "tabs": {
        "home": {
          "label": "Panel"
        },
        "transactions": {
          "label": "İşlemler",
          "shortLabel": "İşlemler"
        },
        "analytics": {
          "label": "Analiz",
          "shortLabel": "Analiz"
        },
        "groups": {
          "label": "Gruplar",
          "shortLabel": "Gruplar"
        },
        "add": {
          "label": "Ekle"
        },
        "profile": {
          "label": "Profil",
          "shortLabel": "Profil"
        }
      },
      "stacks": {
        "dashboard": {
          "header": {
            "title": "Panel"
          }
        },
        "analytics": {
          "header": {
            "title": "Analiz"
          }
        },
        "aiAdvisor": {
          "header": {
            "title": "AI Danışman"
          }
        },
        "weeklyReport": {
          "header": {
            "title": "Haftalık Rapor"
          }
        },
        "budgets": {
          "header": {
            "title": "Bütçeler"
          }
        },
        "groups": {
          "header": {
            "title": "Paylaşım Grupları"
          }
        },
        "createGroup": {
          "header": {
            "title": "Grup Oluştur"
          }
        },
        "groupDetail": {
          "header": {
            "title": "Grup Detayı"
          }
        },
        "addGroupExpense": {
          "header": {
            "title": "Grup Harcaması Ekle"
          }
        },
        "settleUp": {
          "header": {
            "title": "Hesap Kapat"
          }
        },
        "transfer": {
          "header": {
            "title": "Transfer"
          }
        },
        "recurring": {
          "header": {
            "title": "Tekrarlayan"
          }
        },
        "scanReceipt": {
          "header": {
            "title": "Fiş Tara"
          }
        },
        "camera": {
          "header": {
            "title": "Kamera"
          }
        },
        "reviewScan": {
          "header": {
            "title": "Taramayı İncele"
          }
        },
        "profile": {
          "header": {
            "title": "Profil"
          }
        },
        "editProfile": {
          "header": {
            "title": "Profili Düzenle"
          }
        },
        "settings": {
          "header": {
            "title": "Ayarlar"
          }
        },
        "security": {
          "header": {
            "title": "Güvenlik"
          }
        },
        "about": {
          "header": {
            "title": "Hakkında"
          }
        },
        "accounts": {
          "header": {
            "title": "Hesaplar"
          }
        }
      },
      "preview": {
        "screen": {
          "header": {
            "title": "Ekran Önizleme",
            "suffix": "Önizleme"
          }
        }
      }
    }
  },
  "dashboard": {
    "accountFallback": "Hesap",
    "accountTypes": {
      "bank": "Banka",
      "cash": "Nakit",
      "credit": "Kredi"
    },
    "accounts": "Hesaplar",
    "addExpense": "Gider Ekle",
    "addIncome": "Gelir Ekle",
    "aiAction": "İpucu Al",
    "aiActive": "AI AKTİF",
    "aiAdvisor": "AI Danışman",
    "aiAnalysisTitle": "AI Analizi",
    "currentBalance": "Mevcut Bakiye",
    "expense": "Gider",
    "greeting": "Hoş geldin,",
    "income": "Gelir",
    "insight": {
      "noSavingsHighlight": "Tasarruf oranınız",
      "noSavingsMessage": "bu ay. Akıllı önerilerle artırabiliriz.",
      "savingsMessage": "daha fazla tasarruf ettiniz.",
      "thisMonth": "Bu ay"
    },
    "premiumSection": "Premium",
    "quickActions": "Hızlı İşlemler",
    "recentTransactions": "Son İşlemler",
    "scanReceipt": "Fiş Tara",
    "state": {
      "errorTitle": "Panel yüklenemedi",
      "loading": "Panel yükleniyor...",
      "noAccounts": "Hesap bulunamadı.",
      "noData": "Panel verisi bulunamadı.",
      "noTransactions": "Henüz işlem bulunmuyor."
    },
    "time": {
      "dayWithTime": "{{day}} • {{time}}",
      "today": "Bugün, {{time}}",
      "yesterday": "Dün, {{time}}"
    },
    "transaction": {
      "expenseTitle": "Gider",
      "incomeTitle": "Gelir",
      "transferContext": "Transfer",
      "transferTitle": "Transfer"
    },
    "trend": {
      "decrease": "Geçen aya göre -%{{percent}}",
      "increase": "Geçen aya göre +%{{percent}}",
      "stable": "Geçen aya göre sabit"
    },
    "viewAll": "Tümünü Gör",
    "weeklyReport": "Haftalık Rapor"
  },
  "debug": {
    "input": {
      "firstPlaceholder": "First input",
      "goLogin": "Go to Login",
      "goRegister": "Go to Register",
      "secondPlaceholder": "Second input",
      "subtitle": "This screen uses plain TextInput only. Check focus/blur logs in Metro console.",
      "title": "Debug Input Isolation"
    }
  },
  "errors": {
    "account": {
      "createFailedTitle": "Create account failed",
      "updateFailedTitle": "Update account failed"
    },
    "auth": {
      "logoutFailedTitle": "Logout failed",
      "sessionNotAvailable": "Session not available"
    },
    "budget": {
      "createFailedTitle": "Create budget failed",
      "deleteFailedTitle": "Delete budget failed",
      "updateFailedTitle": "Update budget failed"
    },
    "recurring": {
      "createFailedTitle": "Create recurring failed",
      "deleteFailedTitle": "Delete recurring failed",
      "updateFailedTitle": "Update recurring failed"
    },
    "transaction": {
      "createFailedTitle": "Create transaction failed"
    },
    "transfer": {
      "createFailedTitle": "Transfer failed"
    }
  },
  "groups": {
    "create": {
      "actions": {
        "create": "Create Group",
        "creating": "Creating..."
      },
      "errors": {
        "createFailedTitle": "Create group failed"
      },
      "fields": {
        "membersLabel": "Members (comma separated emails)",
        "membersPlaceholder": "alice@mail.com, bob@mail.com",
        "nameLabel": "Group name",
        "namePlaceholder": "Weekend trip"
      },
      "previewCount": "{{count}} members will be added",
      "subtitle": "Set up a shared expense group",
      "title": "Create Group",
      "validation": {
        "nameRequired": "Group name is required"
      }
    },
    "list": {
      "createButton": "Create Group",
      "empty": "No groups yet. Create one to start splitting.",
      "errorTitle": "Could not load groups",
      "loading": "Loading groups...",
      "memberCount": "{{count}} members",
      "subtitle": "Track shared expenses and balances",
      "title": "Groups"
    },
    "settle": {
      "actions": {
        "markSettled": "Mark Settled",
        "settling": "Settling..."
      },
      "errorTitle": "Settle up failed",
      "loadErrorTitle": "Could not load group",
      "loading": "Loading group data...",
      "openAmount": "Open amount",
      "openExpenses": "Open expenses",
      "subtitle": "Mark all open group expenses as settled",
      "successMessage": "Group expenses were marked as settled.",
      "successTitle": "Settled",
      "title": "Settle Up"
    }
  },
  "navigation": {
    "stack": {
      "about": "Hakkında",
      "accounts": "Hesaplar",
      "addGroupExpense": "Grup Harcaması Ekle",
      "aiAdvisor": "AI Danışman",
      "analytics": "Analiz",
      "budgets": "Bütçeler",
      "camera": "Kamera",
      "createGroup": "Grup Oluştur",
      "dashboard": "Panel",
      "editProfile": "Profili Düzenle",
      "groupDetail": "Grup Detayı",
      "profile": "Profil",
      "recurring": "Tekrarlayan",
      "reviewScan": "Taramayı İncele",
      "scanReceipt": "Fiş Tara",
      "security": "Güvenlik",
      "settings": "Ayarlar",
      "settleUp": "Hesap Kapat",
      "splitGroups": "Paylaşım Grupları",
      "transfer": "Transfer",
      "weeklyReport": "Haftalık Rapor"
    },
    "tabs": {
      "add": "Ekle",
      "analytics": "Analiz",
      "analyticsShort": "Analiz",
      "groups": "Gruplar",
      "groupsShort": "Gruplar",
      "home": "Panel",
      "profile": "Profil",
      "profileShort": "Profil",
      "transactions": "İşlemler",
      "transactionsShort": "İşlemler"
    }
  },
  "onboarding": {
    "getStarted": "Get started",
    "next": "Next",
    "skip": "Skip",
    "step1": {
      "subtitle": "Keep every expense, income, and transfer in one clear timeline built for daily finance habits.",
      "title": "Track everything"
    },
    "step2": {
      "subtitle": "See category breakdowns, monthly trends, and budget usage so you always know where money goes.",
      "title": "Understand spending"
    },
    "step3": {
      "subtitle": "Create your account or sign in, then personalize accounts, categories, and budgets in minutes.",
      "titleGate": "Ready to begin?",
      "titlePreview": "You are all set"
    },
    "stepLabel": "Step {{current}}/{{total}}"
  },
  "profile": {
    "about": {
      "appNameLabel": "App Name",
      "buildLabel": "Build",
      "buildValue": "Development",
      "noteOne": "FinSight helps track accounts, transactions, analytics, and budgets using a single base currency.",
      "noteTwo": "Authentication includes access and refresh tokens with guarded navigation.",
      "notesTitle": "Notes",
      "subtitle": "Product and build information",
      "title": "About FinSight",
      "versionLabel": "Version",
      "versionValue": "1.0.0"
    },
    "accountSettings": "HESAP VE AYARLAR",
    "accounts": "Hesap",
    "baseCurrency": "Baz Para Birimi",
    "defaultUserName": "FinSight Kullanıcısı",
    "edit": {
      "baseCurrencyLabel": "Base Currency",
      "emailLabel": "Email",
      "fullNameLabel": "Full Name",
      "fullNamePlaceholder": "Your full name",
      "helper": "Profile update endpoint is not available yet. UI is ready for PATCH /me integration.",
      "photoSubtitle": "Tap to change (UI only)",
      "photoTitle": "Profile Photo",
      "save": "Save Changes",
      "updateNotAvailableCode": "PROFILE_UPDATE_NOT_AVAILABLE"
    },
    "lastSync": "Son Senkron",
    "logOut": "Çıkış Yap",
    "loggingOut": "Çıkış yapılıyor...",
    "premiumMember": "PREMIUM ÜYE",
    "rows": {
      "about": "FinSight Hakkında",
      "aboutSubtitle": "Sürüm ve yasal bilgiler",
      "aiAdvisor": "AI Danışman",
      "aiAdvisorSubtitle": "Kişisel finans önerilerini aç",
      "appSettings": "Ayarlar",
      "appSettingsSubtitle": "Tema ve uygulama tercihleri",
      "myAccounts": "Hesaplarım",
      "myAccountsSubtitle": "Hesaplarını görüntüle ve yönet",
      "personalInfo": "Kişisel bilgiler",
      "personalInfoSubtitle": "Ad, e-posta ve profil bilgileri",
      "security": "Güvenlik",
      "securitySubtitle": "Şifre ve oturum koruması",
      "weeklyReport": "Haftalık Rapor",
      "weeklyReportSubtitle": "Skor ve haftalık görünüm"
    },
    "security": {
      "delete": {
        "cta": "Delete Account and All Data",
        "hint": "This action is permanent and cannot be undone.",
        "notAvailable": "This action is not available yet.",
        "title": "Delete Account"
      },
      "items": {
        "accountActivity": {
          "subtitle": "Review recent devices",
          "title": "Account Activity"
        },
        "biometric": {
          "subtitle": "Use Face ID or Fingerprint",
          "title": "Biometric Login"
        },
        "downloadData": {
          "subtitle": "Request export package",
          "title": "Download Personal Data"
        },
        "privacyPolicy": {
          "subtitle": "How FinSight protects data",
          "title": "Privacy Policy"
        },
        "thirdParty": {
          "subtitle": "Manage partner data access",
          "title": "Third-party Sharing"
        },
        "twoFactor": {
          "subtitle": "Extra verification for sign in",
          "title": "Two-Factor Authentication"
        }
      },
      "scoreSubtitle": "2 of 3 recommended controls are active.",
      "scoreTitle": "Security Score: Strong",
      "sections": {
        "accessControl": "ACCESS CONTROL",
        "dangerZone": "DANGER ZONE",
        "dataPrivacy": "DATA & PRIVACY"
      }
    },
    "settings": {
      "items": {
        "biometric": {
          "subtitle": "Use Face ID / Fingerprint",
          "title": "Biometric Login"
        },
        "helpCenter": {
          "subtitle": "Guides and support",
          "title": "Help Center"
        },
        "howItWorks": {
          "subtitle": "View onboarding again",
          "title": "How it works"
        },
        "language": {
          "subtitle": "Choose app language",
          "title": "Language"
        },
        "notifications": {
          "subtitle": "Receive important updates",
          "title": "Notifications"
        },
        "security": {
          "subtitle": "Advanced security settings",
          "title": "Security"
        },
        "theme": {
          "subtitle": "System, light, or dark",
          "title": "Theme"
        },
        "version": {
          "subtitle": "FinSight 1.0.0",
          "title": "Version"
        }
      },
      "plan": "Premium Plan",
      "sections": {
        "application": "Application",
        "privacy": "Privacy",
        "support": "Support"
      },
      "userTitle": "Demo User"
    },
    "support": "DESTEK",
    "useDifferentAccount": "Farklı hesap kullan"
  },
  "recurring": {
    "actions": {
      "create": "Create Rule"
    },
    "cadence": {
      "monthly": "MONTHLY",
      "weekly": "WEEKLY"
    },
    "delete": {
      "message": "Delete this recurring rule?",
      "title": "Delete recurring rule"
    },
    "fields": {
      "account": "Account",
      "amount": "Amount",
      "amountPlaceholder": "0.00",
      "cadence": "Cadence",
      "categoryWithType": "Category ({{type}})",
      "dayOfMonth": "Day of month (1-28)",
      "dayOfWeek": "Day of week (0=Sun ... 6=Sat)",
      "dayPlaceholder": "1",
      "description": "Description",
      "descriptionPlaceholder": "Optional note",
      "fromAccount": "From account",
      "kind": "Kind",
      "startAt": "Start At (ISO)",
      "startAtPlaceholder": "2026-02-17T10:30:00.000Z",
      "toAccount": "To account",
      "type": "Type"
    },
    "kind": {
      "normal": "NORMAL",
      "transfer": "TRANSFER"
    },
    "rule": {
      "account": "Account: {{account}}",
      "amount": "Amount: {{amount}}",
      "cadence": "Cadence: {{cadence}}",
      "category": "Category: {{category}}",
      "from": "From: {{account}}",
      "nextRun": "Next run: {{date}}",
      "normal": "Normal rule",
      "note": "Note: {{note}}",
      "to": "To: {{account}}",
      "transfer": "Transfer rule",
      "type": "Type: {{type}}"
    },
    "sections": {
      "existing": "Existing Rules",
      "totalRules": "{{count}} rules"
    },
    "state": {
      "empty": "No recurring rules yet.",
      "loading": "Loading recurring data..."
    },
    "status": {
      "active": "ACTIVE",
      "paused": "PAUSED"
    },
    "subtitle": "Create scheduler-ready rules",
    "successMessage": "The rule is now active.",
    "successTitle": "Recurring rule created",
    "title": "Recurring Rules"
  },
  "scan": {
    "camera": {
      "capture": "Capture",
      "permission": {
        "allow": "Allow camera",
        "subtitle": "Allow camera permission to scan receipts.",
        "title": "Camera access needed"
      },
      "state": {
        "preparing": "Preparing camera..."
      }
    },
    "home": {
      "back": "Back to transactions",
      "cta": "Scan receipt",
      "steps": {
        "capture": "Capture receipt image",
        "create": "Create transaction with prefill",
        "review": "Review extracted fields"
      },
      "subtitle": "Capture a bill photo and prefill transaction details in seconds.",
      "title": "Scan Receipt"
    },
    "review": {
      "createTransaction": "Create transaction",
      "defaults": {
        "description": "Receipt transaction"
      },
      "errors": {
        "invalidAmountMessage": "Please enter a positive amount.",
        "invalidAmountTitle": "Invalid amount",
        "invalidDateMessage": "Please enter a valid date (YYYY-MM-DD).",
        "invalidDateTitle": "Invalid date",
        "navigationMessage": "Could not open Add Transaction screen.",
        "navigationTitle": "Navigation error"
      },
      "fields": {
        "amount": "Amount",
        "amountPlaceholder": "0.00",
        "date": "Date",
        "datePlaceholder": "YYYY-MM-DD",
        "merchant": "Merchant",
        "merchantPlaceholder": "Merchant name"
      },
      "formTitle": "Extracted Fields (Mock)",
      "previewTitle": "Receipt Preview",
      "retake": "Retake photo"
    }
  },
  "split": {
    "addExpense": {
      "actions": {
        "submit": "Harcamayı Kaydet",
        "submitting": "Kaydediliyor..."
      },
      "categoryOptions": {
        "bills": "Faturalar",
        "food": "Yemek",
        "other": "Diğer",
        "rent": "Kira",
        "shopping": "Alışveriş",
        "transport": "Ulaşım"
      },
      "equalShare": "{{amount}}",
      "errors": {
        "createFailedTitle": "Harcama oluşturulamadı",
        "invalidAmountMessage": "Lütfen pozitif bir tutar girin.",
        "invalidAmountTitle": "Geçersiz tutar",
        "invalidCustomSplitMessage": "Her seçili üye için geçerli ve negatif olmayan tutar girin.",
        "invalidCustomSplitTitle": "Özel bölüşüm geçersiz",
        "membersRequiredMessage": "En az bir üye seçin.",
        "membersRequiredTitle": "Üye gerekli",
        "paidByRequiredMessage": "Lütfen ödeyen kişiyi seçin.",
        "paidByRequiredTitle": "Ödeyen gerekli",
        "requiredTitleMessage": "Lütfen harcama başlığı girin.",
        "requiredTitleTitle": "Başlık gerekli",
        "splitMismatchMessage": "Tutar {{amount}}, bölüşüm toplamı {{split}} ile uyuşmuyor.",
        "splitMismatchTitle": "Bölüşüm toplamı uyuşmuyor"
      },
      "fields": {
        "amountLabel": "Tutar",
        "amountPlaceholder": "0,00",
        "categoryLabel": "Kategori",
        "dateLabel": "Tarih",
        "datePlaceholder": "YYYY-AA-GG",
        "membersLabel": "Üyeler",
        "paidByLabel": "Ödeyen",
        "paidByPlaceholder": "Üye seçin",
        "splitForMemberLabel": "Pay: {{name}}",
        "splitModeLabel": "Bölüşüm modu",
        "titleLabel": "Başlık",
        "titlePlaceholder": "Akşam yemeği"
      },
      "loadErrorTitle": "Grup yüklenemedi",
      "loading": "Grup üyeleri yükleniyor...",
      "memberSelectedCount": "{{count}} üye seçildi",
      "retry": "Tekrar Dene",
      "sections": {
        "customPreview": "Özel bölüşüm tutarları",
        "equalPreview": "Eşit bölüşüm önizleme"
      },
      "splitModes": {
        "custom": "Özel",
        "equal": "Eşit"
      },
      "subtitle": "{{group}}",
      "title": "Grup Harcaması Ekle"
    },
    "common": {
      "unknownMember": "Bilinmeyen üye"
    },
    "groupDetail": {
      "actions": {
        "addExpense": "Harcama Ekle",
        "settleUp": "Hesap Kapat"
      },
      "balanceState": {
        "creditor": "Alacaklısın",
        "debtor": "Borçlusun",
        "settled": "Dengede"
      },
      "expenseSubtitle": "{{payer}} • {{date}}",
      "indicator": {
        "noShare": "Pay yok",
        "settled": "Kapandı",
        "unknownShare": "Pay bilgisi yok",
        "youGet": "{{amount}} alacak",
        "youOwe": "{{amount}} borç"
      },
      "loadErrorTitle": "Grup detayları yüklenemedi",
      "loading": "Grup detayları yükleniyor...",
      "member": {
        "balanced": "Dengede",
        "creditor": "Alacaklı",
        "debtor": "Borçlu"
      },
      "membersTitle": "Üyeler",
      "noExpenses": "Henüz grup harcaması yok.",
      "recentExpenses": "Son Harcamalar",
      "retry": "Tekrar Dene",
      "summarySubtitle": "Paylaşılan harcamaların görünümü",
      "summaryTitle": "Grup Özeti",
      "totalSpending": "Toplam harcama",
      "yourBalance": "Bakiyen"
    }
  },
  "stitch": {
    "hub": {
      "codeHtml": "code.html",
      "dark": "dark",
      "noApi": "No API",
      "pngOnly": "png only",
      "staticPlaceholders": "Static placeholders",
      "totalScreens": "{{count}} Stitch screens"
    },
    "preview": {
      "analytics": {
        "food": "Food",
        "highlights": "Highlights",
        "savings": "Savings",
        "spendingTrend": "Spending Trend",
        "weeklyBars": "Weekly bars"
      },
      "auth": {
        "authenticationForm": "Authentication Form",
        "onboardingLoginPlaceholder": "Onboarding / login placeholder",
        "phoneOtp": "Phone / OTP"
      },
      "chips": {
        "codeHtmlUsed": "code.html hierarchy used",
        "darkVariant": "Dark variant",
        "lightVariant": "Light variant",
        "pngPlaceholder": "png-driven placeholder"
      },
      "dashboard": {
        "accountSnapshot": "Account Snapshot",
        "categoryPulse": "Category Pulse",
        "currentBalance": "Current Balance",
        "monthlyIncome": "Monthly Income",
        "overviewCards": "Overview cards",
        "recentActivity": "Recent Activity",
        "topCategories": "Top categories",
        "updated1mAgo": "Updated 1m ago"
      },
      "errors": {
        "notFoundBody": "The requested Stitch screen key does not exist in the inventory.",
        "notFoundTitle": "Screen not found"
      },
      "other": {
        "budgetTips": "Budget Tips",
        "contentUtility": "Content / Utility",
        "debtGuide": "Debt Guide",
        "faq": "FAQ",
        "helpCenterDescription": "Category cards, article previews, and quick links are represented here as static placeholders.",
        "helpCenterDetailPages": "Help center + detail pages",
        "helpCenterTitle": "FinSight Help Center"
      },
      "profile": {
        "sampleEmail": "user@finsight.app",
        "summary": "Profile Summary"
      },
      "scan": {
        "alignReceipt": "Align receipt in frame",
        "cameraFramePlaceholder": "Camera frame placeholder",
        "captureReceipt": "Capture Receipt",
        "receiptScan": "Receipt Scan"
      },
      "split": {
        "accommodation": "Accommodation",
        "aylinOwesYou": "Aylin owes you",
        "carRental": "Car rental",
        "expenseSplitScenario": "Expense split scenario",
        "groupOverview": "Group Overview",
        "memberAylin": "Aylin",
        "memberDeniz": "Deniz",
        "memberMert": "Mert",
        "memberYou": "You",
        "settleGroupExpense": "Settle Group Expense",
        "weekendTrip": "Weekend Trip",
        "youOweMert": "You owe Mert"
      },
      "transactions": {
        "addNew": "Add New Transaction",
        "feed": "Transaction Feed",
        "filtersSubtitle": "List + quick filters"
      }
    }
  },
  "transactionDetail": {
    "actions": {
      "delete": "Delete Transaction",
      "downloadReceipt": "Download Receipt",
      "splitExpense": "Split Expense"
    },
    "fields": {
      "account": "Account",
      "category": "Category",
      "dateTime": "Date & Time",
      "noCategory": "No category"
    },
    "location": {
      "placeholder": "Barbaros Mah. No:3, Istanbul"
    },
    "notes": {
      "empty": "No description was added for this transaction.",
      "title": "My Notes"
    },
    "receipt": {
      "title": "Digital Receipt"
    },
    "state": {
      "loadErrorTitle": "Could not load transaction details",
      "loading": "Loading transaction details..."
    },
    "status": {
      "completed": "Completed"
    },
    "title": "Transaction Detail"
  },
  "transactions": {
    "accountFallback": "Account",
    "actions": {
      "loadMore": "Load more",
      "search": "Search"
    },
    "create": {
      "fields": {
        "account": "Account",
        "amount": "Amount",
        "amountPlaceholder": "0.00",
        "category": "Category",
        "currency": "Currency",
        "description": "Description",
        "descriptionPlaceholder": "Optional note",
        "occurredAt": "Date & Time (ISO)",
        "occurredAtPlaceholder": "2026-02-17T10:30:00.000Z"
      },
      "sections": {
        "details": "Transaction Details",
        "step": "Step 1 of 1"
      },
      "selectAccountFirst": "Select account first",
      "state": {
        "loadErrorTitle": "Could not load transaction form",
        "loading": "Loading add transaction form..."
      },
      "submit": "Save Transaction",
      "subtitle": "Create a new income or expense record.",
      "successMessage": "The transaction was saved successfully.",
      "successTitle": "Transaction created",
      "title": "Add Transaction"
    },
    "filters": {
      "all": "All"
    },
    "group": {
      "other": "OTHER",
      "today": "TODAY",
      "yesterday": "YESTERDAY"
    },
    "quickActions": {
      "scanSubtitle": "Receipt OCR flow",
      "scanTitle": "Scan",
      "splitSubtitle": "Groups & settle up",
      "splitTitle": "Split"
    },
    "row": {
      "expenseTitle": "Expense",
      "incomeTitle": "Income",
      "transferBadge": "TRANSFER",
      "transferHint": "Transfer • {{time}}",
      "transferTitle": "Account Transfer",
      "typeHint": "{{type}} • {{time}}"
    },
    "searchPlaceholder": "Search transaction or store...",
    "state": {
      "empty": "No transactions match these filters.",
      "loadErrorTitle": "Could not load transactions",
      "loadingMore": "Loading more..."
    },
    "summary": {
      "totalExpense": "TOTAL EXPENSE",
      "totalIncome": "TOTAL INCOME"
    },
    "title": "Transaction History"
  },
  "transfers": {
    "form": {
      "amount": "Amount",
      "amountPlaceholder": "0.00",
      "description": "Description",
      "descriptionPlaceholder": "Optional note",
      "fromAccount": "From account",
      "occurredAt": "Occurred At (ISO)",
      "occurredAtPlaceholder": "2026-02-17T10:30:00.000Z",
      "submit": "Create Transfer",
      "subtitle": "Creates paired in/out transfer transactions",
      "title": "Transfer Funds",
      "toAccount": "To account"
    },
    "state": {
      "loadingAccounts": "Loading accounts...",
      "needTwoAccounts": "Create at least two accounts before making a transfer."
    },
    "successMessage": "Funds were moved successfully.",
    "successTitle": "Transfer created",
    "title": "Transfer"
  },
  "weeklyReport": {
    "highlights": "Öne Çıkanlar",
    "nextWeekForecast": "Gelecek Hafta Tahmini",
    "noHighlights": "Bu hafta öne çıkan bir veri yok.",
    "noRisks": "Risk tespit edilmedi.",
    "riskFlags": "Riskler",
    "scoreOutOf": "/100",
    "state": {
      "errorTitle": "Haftalık rapor yüklenemedi",
      "noData": "Haftalık rapor bulunamadı."
    },
    "subtitle": "Finansal sağlık özeti ve gelecek hafta görünümü.",
    "title": "Haftalık Rapor"
  },
  "settings": {
    "general": {
      "title": "Ayarlar"
    },
    "language": {
      "label": "Dil"
    },
    "theme": {
      "label": "Tema"
    },
    "notifications": {
      "label": "Bildirimler"
    }
  }
}

===== FILE: apps/mobile/src/shared/i18n/t.ts =====
import { useCallback } from 'react';

import en from './locales/en.json';
import { useI18n } from './index';

type NestedTranslationKey<T> = {
  [K in Extract<keyof T, string>]:
    T[K] extends string
      ? K
      : T[K] extends Record<string, unknown>
        ? `${K}.${NestedTranslationKey<T[K]>}`
        : never;
}[Extract<keyof T, string>];

export type TranslationKey = NestedTranslationKey<typeof en>;
export type TranslationParams = Record<string, string | number>;

export function useT() {
  const { t } = useI18n();

  return useCallback(
    (key: TranslationKey | string, params?: TranslationParams) => t(key, params),
    [t],
  );
}

===== FILE: apps/mobile/src/shared/theme/ThemeProvider.tsx =====
import {
  createContext,
  useCallback,
  useContext,
  useMemo,
  useState,
  type ReactNode,
} from 'react';
import { useColorScheme } from 'react-native';

import { darkTheme } from './themes/dark';
import { lightTheme } from './themes/light';
import type { AppTheme, ThemeMode, ThemePreference } from './types';

interface ThemeContextValue {
  preference: ThemePreference;
  mode: ThemeMode;
  theme: AppTheme;
  setPreference: (preference: ThemePreference) => void;
  setMode: (mode: ThemeMode) => void;
  toggleMode: () => void;
}

interface ThemeProviderProps {
  children: ReactNode;
  mode?: ThemeMode;
  initialPreference?: ThemePreference;
}

const ThemeContext = createContext<ThemeContextValue | null>(null);

function resolveTheme(mode: ThemeMode): AppTheme {
  return mode === 'dark' ? darkTheme : lightTheme;
}

export function ThemeProvider({
  children,
  mode,
  initialPreference = 'light',
}: ThemeProviderProps) {
  const [preference, setInternalPreference] = useState<ThemePreference>(initialPreference);
  const systemMode = useColorScheme() === 'dark' ? 'dark' : 'light';
  const effectiveMode = mode ?? (preference === 'system' ? systemMode : preference);

  const setPreference = useCallback((nextPreference: ThemePreference) => {
    if (mode === undefined) {
      setInternalPreference(nextPreference);
    }
  }, [mode]);

  const setMode = useCallback(
    (nextMode: ThemeMode) => {
      setPreference(nextMode);
    },
    [setPreference],
  );

  const toggleMode = useCallback(() => {
    setMode(effectiveMode === 'light' ? 'dark' : 'light');
  }, [effectiveMode, setMode]);

  const value = useMemo<ThemeContextValue>(
    () => ({
      preference: mode ? mode : preference,
      mode: effectiveMode,
      theme: resolveTheme(effectiveMode),
      setPreference,
      setMode,
      toggleMode,
    }),
    [effectiveMode, mode, preference, setMode, setPreference, toggleMode],
  );

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
}

export function useTheme(): ThemeContextValue {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used inside ThemeProvider');
  }

  return context;
}

===== FILE: apps/mobile/src/shared/theme/colors.ts =====
export const colors = {
  primary: '#2F6BFF',
  primaryMuted: '#EAF0FF',
  income: '#17B26A',
  expense: '#F04438',
  background: '#F3F6FC',
  surface: '#FFFFFF',
  border: '#D8E0EE',
  text: '#0F172A',
  textMuted: '#64748B',
  chartA: '#2F6BFF',
  chartB: '#17B26A',
  chartC: '#F79009',
  chartD: '#F04438',
  dark: {
    background: '#0B1221',
    surface: '#121B2E',
    border: '#23314D',
    text: '#E2E8F0',
    textMuted: '#9AA9C0',
  },
} as const;

export const shadows = {
  card: {
    shadowColor: '#0A1F44',
    shadowOpacity: 0.12,
    shadowRadius: 10,
    shadowOffset: { width: 0, height: 5 },
    elevation: 4,
  },
} as const;

===== FILE: apps/mobile/src/shared/theme/index.ts =====
export { colors, shadows } from './colors';
export { spacing } from './spacing';
export { typography } from './typography';
export { radius } from './radius';
export { ThemeProvider, useTheme } from './ThemeProvider';
export { lightTheme } from './themes/light';
export { darkTheme } from './themes/dark';
export type { AppTheme, ThemeColors, ThemeMode, ThemePreference } from './types';

===== FILE: apps/mobile/src/shared/theme/radius.ts =====
export const radius = {
  sm: 8,
  md: 12,
  lg: 16,
  xl: 22,
  full: 999,
} as const;

===== FILE: apps/mobile/src/shared/theme/spacing.ts =====
export const spacing = {
  xxs: 4,
  xs: 8,
  sm: 12,
  md: 16,
  lg: 20,
  xl: 24,
  xxl: 32,
} as const;

===== FILE: apps/mobile/src/shared/theme/themes/dark.ts =====
import { colors, shadows } from '../colors';
import type { AppTheme } from '../types';

export const darkTheme: AppTheme = {
  mode: 'dark',
  colors: {
    primary: colors.primary,
    primaryMuted: '#173065',
    income: colors.income,
    expense: colors.expense,
    background: '#06070B',
    surface: '#121317',
    border: 'rgba(255, 255, 255, 0.08)',
    text: '#F8FAFF',
    textMuted: '#94A0B6',
    cardBackground: 'rgba(18, 19, 23, 0.92)',
    cardBorder: 'rgba(255, 255, 255, 0.08)',
    buttonPrimaryBackground: colors.primary,
    buttonPrimaryText: '#FFFFFF',
    inputBackground: '#0D0F14',
    inputBorder: 'rgba(255,255,255,0.06)',
    inputBorderFocused: colors.primary,
    inputBorderError: colors.expense,
    inputText: '#F8FAFF',
    inputPlaceholder: '#5B6478',
    inputIcon: '#7B8498',
    label: '#E5EBF7',
    labelMuted: '#9EA7BC',
    authGlowTop: 'rgba(47, 107, 255, 0.18)',
    authGlowBottom: 'rgba(47, 107, 255, 0.12)',
  },
  shadows: {
    card: {
      ...shadows.card,
      shadowColor: '#000000',
      shadowOpacity: 0.35,
      shadowRadius: 24,
      shadowOffset: { width: 0, height: 16 },
      elevation: 12,
    },
  },
};

===== FILE: apps/mobile/src/shared/theme/themes/light.ts =====
import { colors, shadows } from '../colors';
import type { AppTheme } from '../types';

export const lightTheme: AppTheme = {
  mode: 'light',
  colors: {
    primary: colors.primary,
    primaryMuted: colors.primaryMuted,
    income: colors.income,
    expense: colors.expense,
    background: colors.background,
    surface: colors.surface,
    border: colors.border,
    text: colors.text,
    textMuted: colors.textMuted,
    cardBackground: colors.surface,
    cardBorder: colors.border,
    buttonPrimaryBackground: colors.primary,
    buttonPrimaryText: '#FFFFFF',
    inputBackground: colors.surface,
    inputBorder: colors.border,
    inputBorderFocused: colors.primary,
    inputBorderError: colors.expense,
    inputText: colors.text,
    inputPlaceholder: colors.textMuted,
    inputIcon: colors.textMuted,
    label: colors.text,
    labelMuted: colors.textMuted,
    authGlowTop: 'rgba(47, 107, 255, 0.18)',
    authGlowBottom: 'rgba(47, 107, 255, 0.12)',
  },
  shadows,
};

===== FILE: apps/mobile/src/shared/theme/types.ts =====
export type ThemeMode = 'light' | 'dark';
export type ThemePreference = 'system' | ThemeMode;

export interface ThemeColors {
  primary: string;
  primaryMuted: string;
  income: string;
  expense: string;
  background: string;
  surface: string;
  border: string;
  text: string;
  textMuted: string;
  cardBackground: string;
  cardBorder: string;
  buttonPrimaryBackground: string;
  buttonPrimaryText: string;
  inputBackground: string;
  inputBorder: string;
  inputBorderFocused: string;
  inputBorderError: string;
  inputText: string;
  inputPlaceholder: string;
  inputIcon: string;
  label: string;
  labelMuted: string;
  authGlowTop: string;
  authGlowBottom: string;
}

export interface AppTheme {
  mode: ThemeMode;
  colors: ThemeColors;
  shadows: {
    card: {
      shadowColor: string;
      shadowOpacity: number;
      shadowRadius: number;
      shadowOffset: { width: number; height: number };
      elevation: number;
    };
  };
}

===== FILE: apps/mobile/src/shared/theme/typography.ts =====
import type { TextStyle } from 'react-native';

export const typography: Record<string, TextStyle> = {
  title: {
    fontSize: 28,
    lineHeight: 34,
    fontWeight: '700',
  },
  heading: {
    fontSize: 20,
    lineHeight: 26,
    fontWeight: '700',
  },
  subheading: {
    fontSize: 16,
    lineHeight: 22,
    fontWeight: '600',
  },
  body: {
    fontSize: 15,
    lineHeight: 22,
    fontWeight: '400',
  },
  caption: {
    fontSize: 12,
    lineHeight: 16,
    fontWeight: '500',
  },
  amount: {
    fontSize: 24,
    lineHeight: 30,
    fontWeight: '700',
  },
};

===== FILE: apps/mobile/src/shared/ui/AppIcon.tsx =====
import { Ionicons } from '@expo/vector-icons';
import type { ComponentProps } from 'react';

import { useTheme } from '@shared/theme';

export type AppIconName = ComponentProps<typeof Ionicons>['name'];

type AppIconTone = 'primary' | 'muted' | 'text' | 'income' | 'expense' | 'inverse';
type AppIconSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl' | number;

interface AppIconProps {
  name: AppIconName;
  size?: AppIconSize;
  tone?: AppIconTone;
  color?: string;
}

const SIZE_MAP: Record<Exclude<AppIconSize, number>, number> = {
  xs: 12,
  sm: 16,
  md: 20,
  lg: 24,
  xl: 28,
};

export function AppIcon({ name, size = 'md', tone = 'muted', color }: AppIconProps) {
  const { theme } = useTheme();

  const resolvedSize = typeof size === 'number' ? size : SIZE_MAP[size];
  const resolvedColor =
    color ??
    {
      primary: theme.colors.primary,
      muted: theme.colors.textMuted,
      text: theme.colors.text,
      income: theme.colors.income,
      expense: theme.colors.expense,
      inverse: theme.colors.buttonPrimaryText,
    }[tone];

  return <Ionicons name={name} size={resolvedSize} color={resolvedColor} />;
}

===== FILE: apps/mobile/src/shared/ui/Card.tsx =====
import type { ReactNode } from 'react';
import { StyleSheet, View, type StyleProp, type ViewStyle } from 'react-native';

import { darkTheme, radius, spacing, useTheme } from '@shared/theme';

interface CardProps {
  children: ReactNode;
  dark?: boolean;
  style?: StyleProp<ViewStyle>;
}

export function Card({ children, dark = false, style }: CardProps) {
  const { theme } = useTheme();
  const activeTheme = dark ? darkTheme : theme;

  return (
    <View
      style={[
        styles.card,
        {
          backgroundColor: activeTheme.colors.cardBackground,
          borderColor: activeTheme.colors.cardBorder,
          shadowColor: activeTheme.shadows.card.shadowColor,
          shadowOpacity: activeTheme.shadows.card.shadowOpacity,
          shadowRadius: activeTheme.shadows.card.shadowRadius,
          shadowOffset: activeTheme.shadows.card.shadowOffset,
          elevation: activeTheme.shadows.card.elevation,
        },
        style,
      ]}
    >
      {children}
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    borderWidth: 1,
    borderRadius: radius.lg,
    padding: spacing.md,
  },
});

===== FILE: apps/mobile/src/shared/ui/CategoryRow.tsx =====
import { StyleSheet, Text, View } from 'react-native';

import { darkTheme, spacing, typography, useTheme, type AppTheme } from '@shared/theme';

import { Card } from './Card';

interface CategoryRowProps {
  title: string;
  subtitle: string;
  amount: string;
  amountTone?: 'income' | 'expense' | 'neutral';
  dark?: boolean;
}

export function CategoryRow({
  title,
  subtitle,
  amount,
  amountTone = 'neutral',
  dark = false,
}: CategoryRowProps) {
  const { theme } = useTheme();
  const activeTheme = dark ? darkTheme : theme;

  return (
    <Card dark={dark} style={styles.card}>
      <View style={styles.left}>
        <Text style={[styles.title, { color: activeTheme.colors.text }]}>{title}</Text>
        <Text style={[styles.subtitle, { color: activeTheme.colors.textMuted }]}>{subtitle}</Text>
      </View>
      <Text style={[styles.amount, { color: amountColor(amountTone, activeTheme) }]}>{amount}</Text>
    </Card>
  );
}

function amountColor(tone: 'income' | 'expense' | 'neutral', theme: AppTheme): string {
  if (tone === 'income') {
    return theme.colors.income;
  }

  if (tone === 'expense') {
    return theme.colors.expense;
  }

  return theme.colors.text;
}

const styles = StyleSheet.create({
  card: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    gap: spacing.md,
  },
  left: {
    flex: 1,
    gap: spacing.xxs,
  },
  title: {
    ...typography.subheading,
  },
  subtitle: {
    ...typography.caption,
  },
  amount: {
    ...typography.subheading,
  },
});

===== FILE: apps/mobile/src/shared/ui/Chip.tsx =====
import { StyleSheet, Text, View } from 'react-native';

import { darkTheme, radius, spacing, typography, useTheme, type AppTheme } from '@shared/theme';

type ChipTone = 'default' | 'primary' | 'income' | 'expense';

interface ChipProps {
  label: string;
  tone?: ChipTone;
  dark?: boolean;
}

export function Chip({ label, tone = 'default', dark = false }: ChipProps) {
  const { theme } = useTheme();
  const activeTheme = dark ? darkTheme : theme;
  const palette = getPalette(tone, activeTheme);

  return (
    <View style={[styles.chip, { backgroundColor: palette.bg, borderColor: palette.border }]}>
      <Text ellipsizeMode="tail" numberOfLines={1} style={[styles.label, { color: palette.text }]}>
        {label}
      </Text>
    </View>
  );
}

function getPalette(tone: ChipTone, theme: AppTheme) {
  if (tone === 'primary') {
    return {
      bg: theme.mode === 'dark' ? withAlpha(theme.colors.primary, 0.24) : theme.colors.primaryMuted,
      text: theme.colors.primary,
      border: theme.mode === 'dark' ? withAlpha(theme.colors.primary, 0.42) : withAlpha(theme.colors.primary, 0.22),
    };
  }

  if (tone === 'income') {
    return {
      bg: withAlpha(theme.colors.income, theme.mode === 'dark' ? 0.22 : 0.12),
      text: theme.colors.income,
      border: withAlpha(theme.colors.income, theme.mode === 'dark' ? 0.42 : 0.26),
    };
  }

  if (tone === 'expense') {
    return {
      bg: withAlpha(theme.colors.expense, theme.mode === 'dark' ? 0.2 : 0.12),
      text: theme.colors.expense,
      border: withAlpha(theme.colors.expense, theme.mode === 'dark' ? 0.4 : 0.24),
    };
  }

  return {
    bg: theme.mode === 'dark' ? withAlpha(theme.colors.text, 0.08) : withAlpha(theme.colors.textMuted, 0.12),
    text: theme.colors.textMuted,
    border: theme.colors.border,
  };
}

function withAlpha(hexColor: string, alpha: number): string {
  const color = hexColor.trim();
  const hex = color.startsWith('#') ? color.slice(1) : color;

  if (!/^[0-9a-fA-F]{6}$/.test(hex)) {
    return color;
  }

  const red = Number.parseInt(hex.slice(0, 2), 16);
  const green = Number.parseInt(hex.slice(2, 4), 16);
  const blue = Number.parseInt(hex.slice(4, 6), 16);
  return `rgba(${red}, ${green}, ${blue}, ${Math.max(0, Math.min(alpha, 1))})`;
}

const styles = StyleSheet.create({
  chip: {
    maxWidth: '100%',
    borderWidth: 1,
    borderRadius: radius.full,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xxs,
    alignSelf: 'flex-start',
  },
  label: {
    ...typography.caption,
    fontWeight: '600',
    maxWidth: 140,
  },
});

===== FILE: apps/mobile/src/shared/ui/ExpenseRow.tsx =====
import { Pressable, StyleSheet, Text, View } from 'react-native';

import type { AppIconName } from './AppIcon';
import { AppIcon } from './AppIcon';
import { radius, spacing, typography, useTheme } from '@shared/theme';

interface ExpenseRowProps {
  title: string;
  subtitle: string;
  amount: string;
  indicator: string;
  indicatorTone: 'positive' | 'negative' | 'neutral';
  iconName: AppIconName;
  iconTone?: 'primary' | 'muted' | 'text' | 'income' | 'expense' | 'inverse';
  onPress?: () => void;
}

function toneColor(
  tone: 'positive' | 'negative' | 'neutral',
  colors: {
    income: string;
    expense: string;
    textMuted: string;
  },
): string {
  if (tone === 'positive') {
    return colors.income;
  }
  if (tone === 'negative') {
    return colors.expense;
  }
  return colors.textMuted;
}

export function ExpenseRow({
  title,
  subtitle,
  amount,
  indicator,
  indicatorTone,
  iconName,
  iconTone = 'primary',
  onPress,
}: ExpenseRowProps) {
  const { theme, mode } = useTheme();
  const dark = mode === 'dark';

  const inner = (
    <View
      style={[
        styles.row,
        {
          backgroundColor: dark ? '#141E33' : '#FFFFFF',
          borderColor: dark ? 'rgba(255,255,255,0.10)' : '#E2E9F5',
        },
      ]}
    >
      <View style={styles.leftWrap}>
        <View
          style={[
            styles.iconWrap,
            {
              backgroundColor: dark ? 'rgba(47,107,255,0.20)' : '#ECF1FF',
            },
          ]}
        >
          <AppIcon name={iconName} size="sm" tone={iconTone} />
        </View>

        <View style={styles.metaWrap}>
          <Text numberOfLines={1} style={[styles.title, { color: theme.colors.text }]}>
            {title}
          </Text>
          <Text numberOfLines={1} style={[styles.subtitle, { color: theme.colors.textMuted }]}>
            {subtitle}
          </Text>
        </View>
      </View>

      <View style={styles.rightWrap}>
        <Text numberOfLines={1} style={[styles.amount, { color: theme.colors.text }]}>
          {amount}
        </Text>
        <Text
          numberOfLines={1}
          style={[
            styles.indicator,
            { color: toneColor(indicatorTone, theme.colors) },
          ]}
        >
          {indicator}
        </Text>
      </View>
    </View>
  );

  if (!onPress) {
    return inner;
  }

  return (
    <Pressable accessibilityRole="button" onPress={onPress} style={({ pressed }) => [pressed && styles.pressed]}>
      {inner}
    </Pressable>
  );
}

const styles = StyleSheet.create({
  row: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  pressed: {
    opacity: 0.86,
  },
  leftWrap: {
    alignItems: 'center',
    flex: 1,
    flexDirection: 'row',
    gap: spacing.xs,
    minWidth: 0,
  },
  iconWrap: {
    alignItems: 'center',
    borderRadius: radius.sm,
    height: 34,
    justifyContent: 'center',
    width: 34,
  },
  metaWrap: {
    flex: 1,
    gap: 2,
    minWidth: 0,
  },
  title: {
    ...typography.body,
    fontWeight: '700',
  },
  subtitle: {
    ...typography.caption,
    fontSize: 11,
  },
  rightWrap: {
    alignItems: 'flex-end',
    marginLeft: spacing.sm,
  },
  amount: {
    ...typography.subheading,
    fontSize: 15,
    fontWeight: '700',
  },
  indicator: {
    ...typography.caption,
    fontSize: 10,
    fontWeight: '700',
  },
});

===== FILE: apps/mobile/src/shared/ui/GradientCard.tsx =====
import type { ReactNode } from 'react';
import { StyleSheet, View, type StyleProp, type ViewStyle } from 'react-native';

import { radius, spacing, useTheme } from '@shared/theme';

interface GradientCardProps {
  children: ReactNode;
  style?: StyleProp<ViewStyle>;
}

export function GradientCard({ children, style }: GradientCardProps) {
  const { mode } = useTheme();
  const dark = mode === 'dark';

  return (
    <View
      style={[
        styles.card,
        {
          backgroundColor: dark ? '#1A2450' : '#2F6BFF',
          borderColor: dark ? 'rgba(163, 188, 255, 0.22)' : 'rgba(255, 255, 255, 0.22)',
        },
        style,
      ]}
    >
      <View
        pointerEvents="none"
        style={[
          styles.glowTop,
          {
            backgroundColor: dark ? 'rgba(119, 152, 255, 0.26)' : 'rgba(132, 186, 255, 0.32)',
          },
        ]}
      />
      <View
        pointerEvents="none"
        style={[
          styles.glowBottom,
          {
            backgroundColor: dark ? 'rgba(34, 92, 255, 0.33)' : 'rgba(21, 97, 255, 0.36)',
          },
        ]}
      />
      <View style={styles.content}>{children}</View>
    </View>
  );
}

const styles = StyleSheet.create({
  card: {
    borderRadius: radius.lg,
    borderWidth: 1,
    overflow: 'hidden',
    paddingHorizontal: spacing.md,
    paddingVertical: spacing.md,
    position: 'relative',
  },
  glowTop: {
    borderRadius: radius.full,
    height: 176,
    position: 'absolute',
    right: -52,
    top: -72,
    width: 176,
  },
  glowBottom: {
    borderRadius: radius.full,
    bottom: -92,
    height: 206,
    left: -82,
    position: 'absolute',
    width: 206,
  },
  content: {
    gap: spacing.sm,
  },
});

===== FILE: apps/mobile/src/shared/ui/MemberChip.tsx =====
import { Pressable, StyleSheet, Text, View } from 'react-native';

import { useI18n } from '@shared/i18n';
import { radius, spacing, typography, useTheme } from '@shared/theme';

interface MemberChipProps {
  name: string;
  balance?: number;
  currency?: string;
  selected?: boolean;
  onPress?: () => void;
  showBalance?: boolean;
}

function toInitials(name: string): string {
  const parts = name
    .trim()
    .split(/\s+/)
    .filter(Boolean);

  if (parts.length === 0) {
    return '?';
  }

  if (parts.length === 1) {
    return parts[0].slice(0, 2).toUpperCase();
  }

  return `${parts[0][0] ?? ''}${parts[1][0] ?? ''}`.toUpperCase();
}

function formatMoney(amount: number, currency: string, locale: string): string {
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

export function MemberChip({
  name,
  balance = 0,
  currency = 'TRY',
  selected = false,
  onPress,
  showBalance = false,
}: MemberChipProps) {
  const { theme, mode } = useTheme();
  const { locale, t } = useI18n();
  const dark = mode === 'dark';

  const subtitle = showBalance
    ? balance > 0
      ? t('split.groupDetail.member.creditor')
      : balance < 0
        ? t('split.groupDetail.member.debtor')
        : t('split.groupDetail.member.balanced')
    : null;

  const baseStyle = [
    styles.wrap,
    {
      backgroundColor: selected
        ? dark
          ? 'rgba(47,107,255,0.24)'
          : '#EAF0FF'
        : dark
          ? '#111A30'
          : '#FFFFFF',
      borderColor: selected
        ? theme.colors.primary
        : dark
          ? 'rgba(255,255,255,0.12)'
          : '#DFE7F4',
    },
  ];

  const content = (
    <>
      <View
        style={[
          styles.avatar,
          {
            backgroundColor: dark ? 'rgba(83,102,145,0.32)' : '#E9EEFA',
          },
        ]}
      >
        <Text style={[styles.avatarText, { color: theme.colors.text }]}>{toInitials(name)}</Text>
      </View>

      <View style={styles.textWrap}>
        <Text numberOfLines={1} style={[styles.name, { color: theme.colors.text }]}>
          {name}
        </Text>
        {showBalance ? (
          <Text
            numberOfLines={1}
            style={[
              styles.balance,
              {
                color: balance > 0 ? theme.colors.income : balance < 0 ? theme.colors.expense : theme.colors.textMuted,
              },
            ]}
          >
            {balance > 0 ? '+' : balance < 0 ? '-' : ''}
            {formatMoney(Math.abs(balance), currency, locale)}
          </Text>
        ) : null}
        {subtitle ? (
          <Text numberOfLines={1} style={[styles.subtitle, { color: theme.colors.textMuted }]}> 
            {subtitle}
          </Text>
        ) : null}
      </View>

      {selected ? (
        <View style={[styles.check, { backgroundColor: theme.colors.primary }]}> 
          <Text style={styles.checkText}>✓</Text>
        </View>
      ) : null}
    </>
  );

  if (!onPress) {
    return <View style={baseStyle}>{content}</View>;
  }

  return (
    <Pressable
      accessibilityRole="button"
      onPress={onPress}
      style={({ pressed }) => [baseStyle, pressed ? styles.pressed : null]}
    >
      {content}
    </Pressable>
  );
}

const styles = StyleSheet.create({
  wrap: {
    borderRadius: radius.md,
    borderWidth: 1,
    flexDirection: 'row',
    gap: spacing.xs,
    minWidth: 138,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
    position: 'relative',
  },
  pressed: {
    opacity: 0.86,
  },
  avatar: {
    alignItems: 'center',
    borderRadius: radius.full,
    height: 34,
    justifyContent: 'center',
    width: 34,
  },
  avatarText: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 0.3,
  },
  textWrap: {
    flex: 1,
    gap: 2,
    minWidth: 0,
  },
  name: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
  },
  balance: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
  },
  subtitle: {
    ...typography.caption,
    fontSize: 10,
  },
  check: {
    alignItems: 'center',
    borderRadius: radius.full,
    height: 16,
    justifyContent: 'center',
    position: 'absolute',
    right: 6,
    top: 6,
    width: 16,
  },
  checkText: {
    color: '#FFFFFF',
    fontSize: 10,
    fontWeight: '800',
    lineHeight: 12,
  },
});

===== FILE: apps/mobile/src/shared/ui/PrimaryButton.tsx =====
import { Pressable, StyleSheet, Text } from 'react-native';

import type { AppIconName } from './AppIcon';
import { AppIcon } from './AppIcon';
import { radius, spacing, typography, useTheme } from '@shared/theme';

interface PrimaryButtonProps {
  label: string;
  onPress?: () => void;
  disabled?: boolean;
  iconName?: AppIconName;
}

export function PrimaryButton({ label, onPress, disabled = false, iconName }: PrimaryButtonProps) {
  const { theme } = useTheme();

  return (
    <Pressable
      disabled={disabled}
      onPress={onPress}
      style={({ pressed }) => [
        styles.button,
        { backgroundColor: theme.colors.buttonPrimaryBackground },
        (pressed || disabled) && styles.pressed,
      ]}
    >
      {iconName ? <AppIcon name={iconName} size="sm" tone="inverse" /> : null}
      <Text numberOfLines={2} style={[styles.label, { color: theme.colors.buttonPrimaryText }]}>
        {label}
      </Text>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  button: {
    minHeight: 48,
    borderRadius: radius.md,
    justifyContent: 'center',
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
    paddingHorizontal: spacing.lg,
    paddingVertical: spacing.xs,
  },
  pressed: {
    opacity: 0.85,
  },
  label: {
    ...typography.subheading,
    flexShrink: 1,
    textAlign: 'center',
  },
});

===== FILE: apps/mobile/src/shared/ui/ScreenContainer.tsx =====
import type { ReactNode } from 'react';
import { ScrollView, StyleSheet, View, type StyleProp, type ViewStyle } from 'react-native';
import { SafeAreaView, type Edge } from 'react-native-safe-area-context';

import { darkTheme, spacing, useTheme } from '@shared/theme';

interface ScreenContainerProps {
  children: ReactNode;
  dark?: boolean;
  contentStyle?: StyleProp<ViewStyle>;
  scrollable?: boolean;
  safeAreaEdges?: Edge[];
  keyboardDismissMode?: 'none' | 'interactive' | 'on-drag';
  keyboardShouldPersistTaps?: 'always' | 'never' | 'handled';
  showsVerticalScrollIndicator?: boolean;
}

export function ScreenContainer({
  children,
  dark = false,
  contentStyle,
  scrollable = true,
  safeAreaEdges,
  keyboardDismissMode = 'on-drag',
  keyboardShouldPersistTaps = 'handled',
  showsVerticalScrollIndicator = false,
}: ScreenContainerProps) {
  const { theme } = useTheme();
  const activeTheme = dark ? darkTheme : theme;

  if (!scrollable) {
    return (
      <SafeAreaView
        edges={safeAreaEdges}
        style={[styles.safe, { backgroundColor: activeTheme.colors.background }]}
      >
        <View style={[styles.content, contentStyle]}>{children}</View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView
      edges={safeAreaEdges}
      style={[styles.safe, { backgroundColor: activeTheme.colors.background }]}
    >
      <ScrollView
        contentContainerStyle={[styles.content, contentStyle]}
        keyboardDismissMode={keyboardDismissMode}
        keyboardShouldPersistTaps={keyboardShouldPersistTaps}
        showsVerticalScrollIndicator={showsVerticalScrollIndicator}
      >
        {children}
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safe: {
    flex: 1,
  },
  content: {
    flexGrow: 1,
    paddingHorizontal: spacing.md,
    paddingBottom: spacing.xxl,
    paddingTop: spacing.md,
    gap: spacing.md,
  },
});

===== FILE: apps/mobile/src/shared/ui/Section.tsx =====
import type { ReactNode } from 'react';
import { Pressable, StyleSheet, Text, View } from 'react-native';

import { darkTheme, spacing, typography, useTheme } from '@shared/theme';

interface SectionProps {
  title: string;
  subtitle?: string;
  dark?: boolean;
  actionLabel?: string;
  onActionPress?: () => void;
  children: ReactNode;
}

export function Section({
  title,
  subtitle,
  dark = false,
  actionLabel,
  onActionPress,
  children,
}: SectionProps) {
  const { theme } = useTheme();
  const activeTheme = dark ? darkTheme : theme;

  return (
    <View style={styles.wrapper}>
      <View style={styles.headerRow}>
        <View style={styles.headerText}>
          <Text style={[styles.title, { color: activeTheme.colors.text }]}>{title}</Text>
          {subtitle ? (
            <Text style={[styles.subtitle, { color: activeTheme.colors.textMuted }]}>
              {subtitle}
            </Text>
          ) : null}
        </View>
        {actionLabel ? (
          <Pressable onPress={onActionPress} style={styles.actionButton}>
            <Text style={[styles.actionText, { color: activeTheme.colors.primary }]}>{actionLabel}</Text>
          </Pressable>
        ) : null}
      </View>
      <View style={styles.body}>{children}</View>
    </View>
  );
}

const styles = StyleSheet.create({
  wrapper: {
    gap: spacing.sm,
  },
  headerRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    gap: spacing.sm,
  },
  headerText: {
    flex: 1,
    gap: spacing.xxs,
    minWidth: 0,
  },
  title: {
    ...typography.heading,
    fontSize: 18,
    lineHeight: 24,
    flexShrink: 1,
  },
  subtitle: {
    ...typography.caption,
    flexShrink: 1,
    lineHeight: 18,
  },
  actionButton: {
    alignSelf: 'flex-start',
    paddingVertical: spacing.xxs,
    minHeight: 28,
    justifyContent: 'center',
  },
  actionText: {
    ...typography.caption,
    fontWeight: '700',
    textAlign: 'right',
  },
  body: {
    gap: spacing.sm,
  },
});

===== FILE: apps/mobile/src/shared/ui/SplitToggle.tsx =====
import { Pressable, StyleSheet, Text, View } from 'react-native';

import { radius, spacing, typography, useTheme } from '@shared/theme';

type SplitMode = 'equal' | 'custom';

interface SplitToggleProps {
  value: SplitMode;
  onChange: (value: SplitMode) => void;
  equalLabel: string;
  customLabel: string;
}

export function SplitToggle({ value, onChange, equalLabel, customLabel }: SplitToggleProps) {
  const { theme, mode } = useTheme();
  const dark = mode === 'dark';

  return (
    <View
      style={[
        styles.wrap,
        {
          backgroundColor: dark ? '#0E1528' : '#EEF3FC',
          borderColor: dark ? 'rgba(255,255,255,0.10)' : '#DCE5F4',
        },
      ]}
    >
      {([
        { key: 'equal', label: equalLabel },
        { key: 'custom', label: customLabel },
      ] as const).map((item) => {
        const selected = item.key === value;

        return (
          <Pressable
            key={item.key}
            accessibilityRole="button"
            onPress={() => onChange(item.key)}
            style={({ pressed }) => [
              styles.option,
              {
                backgroundColor: selected ? theme.colors.primary : 'transparent',
                borderColor: selected ? theme.colors.primary : 'transparent',
              },
              pressed ? styles.pressed : null,
            ]}
          >
            <Text style={[styles.label, { color: selected ? '#FFFFFF' : theme.colors.textMuted }]}>{item.label}</Text>
          </Pressable>
        );
      })}
    </View>
  );
}

const styles = StyleSheet.create({
  wrap: {
    borderRadius: radius.full,
    borderWidth: 1,
    flexDirection: 'row',
    padding: 3,
  },
  option: {
    alignItems: 'center',
    borderRadius: radius.full,
    borderWidth: 1,
    flex: 1,
    justifyContent: 'center',
    minHeight: 34,
    paddingHorizontal: spacing.sm,
  },
  pressed: {
    opacity: 0.86,
  },
  label: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
  },
});

===== FILE: apps/mobile/src/shared/ui/StatCard.tsx =====
import { StyleSheet, Text, View } from 'react-native';

import { darkTheme, spacing, typography, useTheme, type AppTheme } from '@shared/theme';

import { Card } from './Card';

type StatTone = 'neutral' | 'income' | 'expense' | 'primary';

interface StatCardProps {
  label: string;
  value: string;
  detail?: string;
  tone?: StatTone;
  dark?: boolean;
}

export function StatCard({ label, value, detail, tone = 'neutral', dark = false }: StatCardProps) {
  const { theme } = useTheme();
  const activeTheme = dark ? darkTheme : theme;
  const valueColor = getValueColor(tone, activeTheme);

  return (
    <Card dark={dark} style={styles.card}>
      <Text style={[styles.label, { color: activeTheme.colors.textMuted }]}>{label}</Text>
      <Text style={[styles.value, { color: valueColor }]}>{value}</Text>
      {detail ? (
        <Text style={[styles.detail, { color: activeTheme.colors.textMuted }]}>{detail}</Text>
      ) : null}
    </Card>
  );
}

function getValueColor(tone: StatTone, theme: AppTheme): string {
  if (tone === 'income') {
    return theme.colors.income;
  }

  if (tone === 'expense') {
    return theme.colors.expense;
  }

  if (tone === 'primary') {
    return theme.colors.primary;
  }

  return theme.colors.text;
}

const styles = StyleSheet.create({
  card: {
    flex: 1,
    minWidth: 140,
    gap: spacing.xs,
  },
  label: {
    ...typography.caption,
  },
  value: {
    ...typography.amount,
  },
  detail: {
    ...typography.caption,
  },
});

===== FILE: apps/mobile/src/shared/ui/TextField.tsx =====
import { forwardRef, useState, type ReactNode } from 'react';
import {
  StyleSheet,
  Text,
  TextInput,
  View,
  type KeyboardTypeOptions,
  type ReturnKeyTypeOptions,
  type StyleProp,
  type TextStyle,
  type ViewStyle,
} from 'react-native';

import { radius, spacing, typography, useTheme } from '@shared/theme';

// no touch/keyboard behavior changed by this PR.
interface TextFieldProps {
  label: string;
  value: string;
  onChangeText: (value: string) => void;
  placeholder: string;
  error?: string | null;
  secureTextEntry?: boolean;
  keyboardType?: KeyboardTypeOptions;
  autoCapitalize?: 'none' | 'sentences' | 'words' | 'characters';
  autoCorrect?: boolean;
  autoComplete?: 'off' | 'name' | 'email' | 'password' | 'username' | 'tel';
  textContentType?:
    | 'none'
    | 'name'
    | 'givenName'
    | 'familyName'
    | 'emailAddress'
    | 'password'
    | 'newPassword'
    | 'telephoneNumber'
    | 'username';
  returnKeyType?: ReturnKeyTypeOptions;
  onSubmitEditing?: () => void;
  blurOnSubmit?: boolean;
  editable?: boolean;
  containerStyle?: StyleProp<ViewStyle>;
  inputWrapStyle?: StyleProp<ViewStyle>;
  inputStyle?: StyleProp<TextStyle>;
  onFocus?: () => void;
  onBlur?: () => void;
  leftAdornment?: ReactNode;
  rightAdornment?: ReactNode;
  labelRight?: ReactNode;
  multiline?: boolean;
  numberOfLines?: number;
}

export const TextField = forwardRef<TextInput, TextFieldProps>(function TextField(
  {
    label,
    value,
    onChangeText,
    placeholder,
    error,
    secureTextEntry,
    keyboardType = 'default',
    autoCapitalize = 'none',
    autoCorrect = false,
    autoComplete = 'off',
    textContentType = 'none',
    returnKeyType = 'done',
    onSubmitEditing,
    blurOnSubmit = true,
    editable = true,
    containerStyle,
    inputWrapStyle,
    inputStyle,
    onFocus,
    onBlur,
    leftAdornment,
    rightAdornment,
    labelRight,
    multiline = false,
    numberOfLines,
  },
  ref,
) {
  const { theme } = useTheme();
  const [isFocused, setIsFocused] = useState(false);

  return (
    <View style={[styles.wrapper, containerStyle]}>
      <View style={styles.labelRow}>
        <Text style={[styles.label, { color: theme.colors.label }]}>{label}</Text>
        {labelRight ? <View>{labelRight}</View> : null}
      </View>

      <View
        style={[
          styles.inputWrap,
          {
            backgroundColor: theme.colors.inputBackground,
            borderColor: theme.colors.inputBorder,
          },
          isFocused && { borderColor: theme.colors.inputBorderFocused },
          error && { borderColor: theme.colors.inputBorderError },
          !editable && styles.inputWrapDisabled,
          multiline ? styles.inputWrapMultiline : null,
          inputWrapStyle,
        ]}
      >
        {leftAdornment ? (
          <View pointerEvents="none" style={styles.leftAdornment}>
            {leftAdornment}
          </View>
        ) : null}

        <TextInput
          ref={ref}
          autoCapitalize={autoCapitalize}
          autoComplete={autoComplete}
          autoCorrect={autoCorrect}
          blurOnSubmit={blurOnSubmit}
          editable={editable}
          keyboardType={keyboardType}
          onBlur={() => {
            setIsFocused(false);
            onBlur?.();
          }}
          onChangeText={onChangeText}
          onFocus={() => {
            setIsFocused(true);
            onFocus?.();
          }}
          onSubmitEditing={onSubmitEditing}
          placeholder={placeholder}
          placeholderTextColor={theme.colors.inputPlaceholder}
          returnKeyType={returnKeyType}
          secureTextEntry={secureTextEntry}
          multiline={multiline}
          numberOfLines={numberOfLines}
          style={[
            styles.input,
            { color: theme.colors.inputText },
            leftAdornment ? styles.inputWithLeftAdornment : null,
            rightAdornment ? styles.inputWithRightAdornment : null,
            multiline ? styles.inputMultiline : null,
            inputStyle,
          ]}
          textContentType={textContentType}
          value={value}
        />

        {rightAdornment ? <View style={styles.rightAdornment}>{rightAdornment}</View> : null}
      </View>

      {error ? <Text style={[styles.errorText, { color: theme.colors.inputBorderError }]}>{error}</Text> : null}
    </View>
  );
});

const styles = StyleSheet.create({
  wrapper: {
    gap: spacing.xs,
  },
  labelRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  label: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
    letterSpacing: 0.4,
  },
  inputWrap: {
    borderRadius: radius.md,
    borderWidth: 1,
    height: 52,
    justifyContent: 'center',
  },
  inputWrapMultiline: {
    height: 'auto',
    minHeight: 52,
    justifyContent: 'flex-start',
  },
  inputWrapDisabled: {
    opacity: 0.7,
  },
  input: {
    ...typography.body,
    fontSize: 16,
    paddingHorizontal: spacing.sm,
    paddingVertical: 0,
  },
  inputMultiline: {
    minHeight: 96,
    paddingTop: spacing.sm,
    paddingBottom: spacing.sm,
    textAlignVertical: 'top',
  },
  inputWithLeftAdornment: {
    paddingLeft: 44,
  },
  inputWithRightAdornment: {
    paddingRight: 46,
  },
  leftAdornment: {
    left: spacing.sm,
    position: 'absolute',
    top: 15,
  },
  rightAdornment: {
    alignItems: 'center',
    height: 52,
    justifyContent: 'center',
    position: 'absolute',
    right: spacing.sm,
    top: 0,
  },
  errorText: {
    ...typography.caption,
    fontSize: 12,
  },
});

===== FILE: apps/mobile/src/shared/ui/TransactionRow.tsx =====
import { Pressable, StyleSheet, Text, View } from 'react-native';

import { useI18n } from '@shared/i18n';
import { darkTheme, radius, spacing, typography, useTheme, type AppTheme } from '@shared/theme';

import { Card } from './Card';

interface TransactionRowProps {
  title: string;
  date: string;
  amount: string;
  type: 'income' | 'expense';
  kind?: 'normal' | 'transfer';
  dark?: boolean;
  categoryIcon?: string;
  onPress?: () => void;
}

export function TransactionRow({
  title,
  date,
  amount,
  type,
  kind = 'normal',
  dark = false,
  categoryIcon = '•',
  onPress,
}: TransactionRowProps) {
  const { theme } = useTheme();
  const { t } = useI18n();
  const activeTheme = dark ? darkTheme : theme;
  const palette = getPalette(type, kind, activeTheme);

  return (
    <Pressable
      accessibilityRole="button"
      onPress={onPress}
      style={({ pressed }) => [pressed && styles.pressed]}
    >
      <Card dark={dark} style={styles.card}>
        <View style={[styles.iconCircle, { backgroundColor: palette.iconBg }]}>
          <Text style={[styles.iconText, { color: palette.iconText }]}>{categoryIcon}</Text>
        </View>

        <View style={styles.meta}>
          <View style={styles.titleRow}>
            <Text numberOfLines={1} style={[styles.title, { color: activeTheme.colors.text }]}>
              {title}
            </Text>
            {kind === 'transfer' ? (
              <View
                style={[
                  styles.kindBadge,
                  {
                    backgroundColor:
                      activeTheme.mode === 'dark'
                        ? withAlpha(activeTheme.colors.primary, 0.24)
                        : activeTheme.colors.primaryMuted,
                  },
                ]}
              >
                <Text
                  ellipsizeMode="tail"
                  numberOfLines={1}
                  style={[styles.kindBadgeText, { color: activeTheme.colors.primary }]}
                >
                  {t('transactions.row.transferBadge')}
                </Text>
              </View>
            ) : null}
          </View>
          <Text numberOfLines={1} style={[styles.date, { color: activeTheme.colors.textMuted }]}>
            {date}
          </Text>
        </View>

        <Text adjustsFontSizeToFit numberOfLines={1} style={[styles.amount, { color: palette.amount }]}>
          {amount}
        </Text>
      </Card>
    </Pressable>
  );
}

function getPalette(type: 'income' | 'expense', kind: 'normal' | 'transfer', theme: AppTheme) {
  if (kind === 'transfer') {
    return {
      iconBg: theme.mode === 'dark' ? withAlpha(theme.colors.primary, 0.2) : theme.colors.primaryMuted,
      iconText: theme.colors.primary,
      amount: type === 'income' ? theme.colors.income : theme.colors.expense,
    };
  }

  if (type === 'income') {
    return {
      iconBg: withAlpha(theme.colors.income, theme.mode === 'dark' ? 0.2 : 0.12),
      iconText: theme.colors.income,
      amount: theme.colors.income,
    };
  }

  return {
    iconBg: withAlpha(theme.colors.expense, theme.mode === 'dark' ? 0.18 : 0.12),
    iconText: theme.colors.expense,
    amount: theme.colors.expense,
  };
}

function withAlpha(hexColor: string, alpha: number): string {
  const color = hexColor.trim();
  const hex = color.startsWith('#') ? color.slice(1) : color;

  if (!/^[0-9a-fA-F]{6}$/.test(hex)) {
    return color;
  }

  const red = Number.parseInt(hex.slice(0, 2), 16);
  const green = Number.parseInt(hex.slice(2, 4), 16);
  const blue = Number.parseInt(hex.slice(4, 6), 16);
  return `rgba(${red}, ${green}, ${blue}, ${Math.max(0, Math.min(alpha, 1))})`;
}

const styles = StyleSheet.create({
  card: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.sm,
    paddingVertical: spacing.sm,
  },
  pressed: {
    opacity: 0.92,
  },
  iconCircle: {
    width: 36,
    height: 36,
    borderRadius: radius.full,
    alignItems: 'center',
    justifyContent: 'center',
  },
  iconText: {
    ...typography.subheading,
    fontSize: 14,
    lineHeight: 16,
  },
  meta: {
    flex: 1,
    gap: spacing.xxs,
    minWidth: 0,
  },
  titleRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.xs,
  },
  title: {
    ...typography.body,
    fontWeight: '600',
    flexShrink: 1,
    fontSize: 15,
  },
  kindBadge: {
    paddingHorizontal: spacing.xs,
    paddingVertical: 2,
    borderRadius: radius.full,
  },
  kindBadgeText: {
    ...typography.caption,
    fontWeight: '700',
    fontSize: 10,
  },
  date: {
    ...typography.caption,
    fontSize: 11,
  },
  amount: {
    ...typography.subheading,
    fontWeight: '700',
  },
});

===== FILE: apps/mobile/src/shared/ui/index.ts =====
export { Card } from './Card';
export { Section } from './Section';
export { Chip } from './Chip';
export { StatCard } from './StatCard';
export { CategoryRow } from './CategoryRow';
export { TransactionRow } from './TransactionRow';
export { TextField } from './TextField';
export { PrimaryButton } from './PrimaryButton';
export { ScreenContainer } from './ScreenContainer';
export { GradientCard } from './GradientCard';
export { MemberChip } from './MemberChip';
export { ExpenseRow } from './ExpenseRow';
export { SplitToggle } from './SplitToggle';
export { AppIcon } from './AppIcon';

===== FILE: apps/mobile/src/shared/utils/apiErrorText.ts =====
import { normalizeApiError } from '@mintly/shared';
import i18n from 'i18next';

export function apiErrorText(error: unknown): string {
  const normalized = normalizeApiError(error);
  const localized = i18n.t(`errors.api.${normalized.code}`, { defaultValue: normalized.message });
  return `${normalized.code}: ${localized}`;
}

===== FILE: apps/mobile/src/shared/utils/month.ts =====
const MONTH_REGEX = /^(\d{4})-(0[1-9]|1[0-2])$/;

function parseMonthParts(month: string): { year: number; monthIndex: number } {
  const match = MONTH_REGEX.exec(month);
  if (!match) {
    throw new Error(`Invalid month value: ${month}`);
  }

  return {
    year: Number(match[1]),
    monthIndex: Number(match[2]) - 1,
  };
}

export function getCurrentMonthString(): string {
  return toMonthString(new Date());
}

export function toMonthString(value: Date): string {
  const year = value.getUTCFullYear();
  const month = String(value.getUTCMonth() + 1).padStart(2, '0');
  return `${year}-${month}`;
}

export function monthFromIsoString(value: string): string {
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return getCurrentMonthString();
  }

  return toMonthString(date);
}

export function shiftMonth(month: string, delta: number): string {
  const parsed = parseMonthParts(month);
  const moved = new Date(Date.UTC(parsed.year, parsed.monthIndex + delta, 1, 0, 0, 0, 0));
  return toMonthString(moved);
}

export function formatMonthLabel(month: string): string {
  const parsed = parseMonthParts(month);
  const date = new Date(Date.UTC(parsed.year, parsed.monthIndex, 1, 0, 0, 0, 0));
  return date.toLocaleDateString(undefined, {
    month: 'long',
    year: 'numeric',
    timeZone: 'UTC',
  });
}

export function getTrendRange(month: string, span: number): { from: string; to: string } {
  return {
    from: shiftMonth(month, -(span - 1)),
    to: month,
  };
}
