# Milestone 18 Full Updated Files

## FILE: apps/api/src/models/Group.ts
```
import mongoose, { type HydratedDocument, type InferSchemaType, type Types } from 'mongoose';

const { Schema, model } = mongoose;

const groupMemberSchema = new Schema(
  {
    email: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
      maxlength: 320,
    },
    name: {
      type: String,
      required: true,
      trim: true,
      maxlength: 120,
    },
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: false,
      default: null,
    },
  },
  {
    _id: true,
    id: false,
    versionKey: false,
  },
);

const groupSchema = new Schema(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      index: true,
    },
    name: {
      type: String,
      required: true,
      trim: true,
      maxlength: 120,
    },
    members: {
      type: [groupMemberSchema],
      required: true,
      default: [],
    },
  },
  {
    timestamps: true,
    versionKey: false,
  },
);

groupSchema.index({ userId: 1, createdAt: -1 });

export interface Group extends InferSchemaType<typeof groupSchema> {
  userId: Types.ObjectId;
}

export type GroupDocument = HydratedDocument<Group>;

export const GroupModel = mongoose.models.Group || model<Group>('Group', groupSchema);
```

## FILE: apps/api/src/models/GroupExpense.ts
```
import mongoose, { type HydratedDocument, type InferSchemaType, type Types } from 'mongoose';

const { Schema, model } = mongoose;

const splitSchema = new Schema(
  {
    memberId: {
      type: String,
      required: true,
      trim: true,
    },
    amount: {
      type: Number,
      required: true,
      min: 0,
    },
  },
  {
    _id: false,
    id: false,
    versionKey: false,
  },
);

const groupExpenseSchema = new Schema(
  {
    groupId: {
      type: Schema.Types.ObjectId,
      ref: 'Group',
      required: true,
      index: true,
    },
    paidByMemberId: {
      type: String,
      required: true,
      trim: true,
    },
    title: {
      type: String,
      required: true,
      trim: true,
      maxlength: 160,
    },
    amount: {
      type: Number,
      required: true,
      min: 0,
    },
    currency: {
      type: String,
      required: true,
      trim: true,
      uppercase: true,
      minlength: 3,
      maxlength: 3,
    },
    splits: {
      type: [splitSchema],
      required: true,
      default: [],
    },
    settledAt: {
      type: Date,
      required: false,
      default: null,
      index: true,
    },
  },
  {
    timestamps: true,
    versionKey: false,
  },
);

groupExpenseSchema.index({ groupId: 1, createdAt: -1 });
groupExpenseSchema.index({ groupId: 1, settledAt: 1, createdAt: -1 });

export interface GroupExpense extends InferSchemaType<typeof groupExpenseSchema> {
  groupId: Types.ObjectId;
}

export type GroupExpenseDocument = HydratedDocument<GroupExpense>;

export const GroupExpenseModel =
  mongoose.models.GroupExpense || model<GroupExpense>('GroupExpense', groupExpenseSchema);
```

## FILE: apps/api/src/routes/groups.ts
```
import {
  groupCreateInputSchema,
  groupExpenseCreateInputSchema,
  groupExpenseListResponseSchema,
  groupExpenseSchema,
  groupListResponseSchema,
  groupSchema,
  groupSettleResponseSchema,
  type Group,
  type GroupCreateInput,
  type GroupExpense,
  type GroupExpenseCreateInput,
} from '@mintly/shared';
import type { FastifyInstance } from 'fastify';
import { Types } from 'mongoose';

import { authenticate } from '../auth/middleware.js';
import { ApiError } from '../errors.js';
import { GroupExpenseModel, type GroupExpenseDocument } from '../models/GroupExpense.js';
import { GroupModel, type GroupDocument } from '../models/Group.js';

import { parseBody, parseObjectId, requireUser } from './utils.js';

function normalizeEmail(value: string): string {
  return value.trim().toLowerCase();
}

function getMemberId(member: { _id?: Types.ObjectId | string }): string {
  const raw = member._id;
  if (!raw) {
    return '';
  }

  return typeof raw === 'string' ? raw : raw.toString();
}

function toGroupDto(group: GroupDocument): Group {
  const stamped = group as GroupDocument & { createdAt: Date; updatedAt: Date };

  return {
    id: group.id,
    name: group.name,
    ownerUserId: group.userId.toString(),
    members: group.members.map((member) => {
      const memberId = getMemberId(member as { _id?: Types.ObjectId | string });

      return {
        id: memberId,
        email: member.email,
        name: member.name,
        userId: member.userId ? member.userId.toString() : null,
      };
    }),
    createdAt: stamped.createdAt.toISOString(),
    updatedAt: stamped.updatedAt.toISOString(),
  };
}

function toGroupExpenseDto(expense: GroupExpenseDocument): GroupExpense {
  const stamped = expense as GroupExpenseDocument & { createdAt: Date; updatedAt: Date };

  return {
    id: expense.id,
    groupId: expense.groupId.toString(),
    paidByMemberId: expense.paidByMemberId,
    title: expense.title,
    amount: expense.amount,
    currency: expense.currency,
    splits: expense.splits.map((split) => ({
      memberId: split.memberId,
      amount: split.amount,
    })),
    settledAt: expense.settledAt ? expense.settledAt.toISOString() : null,
    createdAt: stamped.createdAt.toISOString(),
    updatedAt: stamped.updatedAt.toISOString(),
  };
}

async function requireOwnedGroup(userId: Types.ObjectId, groupId: Types.ObjectId): Promise<GroupDocument> {
  const group = await GroupModel.findOne({
    _id: groupId,
    userId,
  });

  if (!group) {
    throw new ApiError({
      code: 'GROUP_NOT_FOUND',
      message: 'Group not found',
      statusCode: 404,
    });
  }

  return group;
}

function validateMemberIds(group: GroupDocument, payload: GroupExpenseCreateInput): void {
  const validMemberIds = new Set(
    group.members.map((member) => getMemberId(member as { _id?: Types.ObjectId | string })).filter(Boolean),
  );

  if (!validMemberIds.has(payload.paidByMemberId)) {
    throw new ApiError({
      code: 'INVALID_MEMBER',
      message: 'paidByMemberId does not belong to this group',
      statusCode: 400,
    });
  }

  for (const split of payload.splits) {
    if (!validMemberIds.has(split.memberId)) {
      throw new ApiError({
        code: 'INVALID_MEMBER',
        message: 'split memberId does not belong to this group',
        statusCode: 400,
      });
    }
  }
}

function validateSplitTotal(payload: GroupExpenseCreateInput): void {
  const total = payload.splits.reduce((sum, split) => sum + split.amount, 0);
  const diff = Math.abs(total - payload.amount);

  if (diff > 0.01) {
    throw new ApiError({
      code: 'INVALID_SPLIT_TOTAL',
      message: 'Split amounts must equal total amount',
      statusCode: 400,
    });
  }
}

export function registerGroupRoutes(app: FastifyInstance): void {
  app.post('/groups', { preHandler: authenticate }, async (request, reply) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const input = parseBody<GroupCreateInput>(groupCreateInputSchema, request.body);

    const ownerEmail = normalizeEmail(user.email);
    const ownerName = input.ownerName?.trim() || 'You';

    const seenEmails = new Set<string>([ownerEmail]);
    const members: Array<{ email: string; name: string; userId: Types.ObjectId | null }> = [
      {
        email: ownerEmail,
        name: ownerName,
        userId,
      },
    ];

    for (const member of input.members) {
      const email = normalizeEmail(member.email);
      if (seenEmails.has(email)) {
        continue;
      }

      seenEmails.add(email);
      members.push({
        email,
        name: member.name.trim(),
        userId: member.userId ? parseObjectId(member.userId, 'member.userId') : null,
      });
    }

    const group = await GroupModel.create({
      userId,
      name: input.name,
      members,
    });

    reply.status(201);
    return groupSchema.parse(toGroupDto(group));
  });

  app.get('/groups', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');

    const groups = await GroupModel.find({ userId }).sort({ createdAt: -1 });

    return groupListResponseSchema.parse({
      groups: groups.map((group) => toGroupDto(group)),
    });
  });

  app.get('/groups/:id', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const groupId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');

    const group = await requireOwnedGroup(userId, groupId);
    return groupSchema.parse(toGroupDto(group));
  });

  app.post('/groups/:id/expenses', { preHandler: authenticate }, async (request, reply) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const groupId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');
    const input = parseBody<GroupExpenseCreateInput>(groupExpenseCreateInputSchema, request.body);

    const group = await requireOwnedGroup(userId, groupId);
    validateMemberIds(group, input);
    validateSplitTotal(input);

    const expense = await GroupExpenseModel.create({
      groupId,
      paidByMemberId: input.paidByMemberId,
      title: input.title,
      amount: input.amount,
      currency: input.currency,
      splits: input.splits,
      settledAt: null,
    });

    reply.status(201);
    return groupExpenseSchema.parse(toGroupExpenseDto(expense));
  });

  app.get('/groups/:id/expenses', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const groupId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');

    await requireOwnedGroup(userId, groupId);

    const expenses = await GroupExpenseModel.find({ groupId }).sort({ createdAt: -1 });

    return groupExpenseListResponseSchema.parse({
      expenses: expenses.map((expense) => toGroupExpenseDto(expense)),
    });
  });

  app.post('/groups/:id/settle', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const groupId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');

    await requireOwnedGroup(userId, groupId);

    const now = new Date();
    const result = await GroupExpenseModel.updateMany(
      {
        groupId,
        settledAt: null,
      },
      {
        $set: {
          settledAt: now,
        },
      },
    );

    return groupSettleResponseSchema.parse({
      ok: true,
      settledCount: result.modifiedCount,
    });
  });
}
```

## FILE: apps/api/src/server.ts
```
import cors from '@fastify/cors';
import helmet from '@fastify/helmet';
import rateLimit from '@fastify/rate-limit';
import { healthResponseSchema } from '@mintly/shared';
import Fastify, { type FastifyError, type FastifyInstance } from 'fastify';

import { getConfig } from './config.js';
import { connectMongo, disconnectMongo } from './db/mongo.js';
import { ApiError, toErrorPayload } from './errors.js';
import { registerAccountRoutes } from './routes/accounts.js';
import { registerAnalyticsRoutes } from './routes/analytics.js';
import { registerAiRoutes } from './routes/ai.js';
import { registerAuthRoutes } from './routes/auth.js';
import { registerBudgetRoutes } from './routes/budgets.js';
import { registerCategoryRoutes } from './routes/categories.js';
import { registerDashboardRoutes } from './routes/dashboard.js';
import { registerExportRoutes } from './routes/export.js';
import { registerGroupRoutes } from './routes/groups.js';
import { registerMeRoute } from './routes/me.js';
import { registerRecurringRoutes } from './routes/recurring.js';
import { registerReportRoutes } from './routes/reports.js';
import { registerTransactionRoutes } from './routes/transactions.js';
import { registerTransferRoutes } from './routes/transfers.js';

interface BuildServerOptions {
  logger?: boolean;
}

function isAllowedOrigin(origin: string | undefined, allowedOrigins: Set<string>): boolean {
  if (!origin) {
    return true;
  }

  return allowedOrigins.has(origin);
}

export function buildServer(options: BuildServerOptions = {}): FastifyInstance {
  const config = getConfig();
  const app = Fastify({
    logger: options.logger ?? true,
  });

  const allowedOrigins = new Set(config.corsOrigins);

  if (config.isProduction) {
    app.register(helmet, {
      global: true,
    });
  }

  app.register(cors, {
    origin: (origin, callback) => {
      if (isAllowedOrigin(origin, allowedOrigins)) {
        callback(null, true);
        return;
      }

      callback(new Error('Origin not allowed by CORS policy'), false);
    },
    allowedHeaders: ['Authorization', 'Content-Type'],
    methods: ['GET', 'POST', 'PATCH', 'DELETE', 'OPTIONS'],
  });

  app.register(rateLimit, {
    global: true,
    max: 300,
    timeWindow: '1 minute',
    errorResponseBuilder: (_request, context) => {
      return {
        error: {
          code: 'RATE_LIMITED',
          message: `Too many requests. Retry in ${Math.ceil(context.ttl / 1000)}s`,
        },
      };
    },
  });

  app.addHook('onReady', async () => {
    await connectMongo(config.mongoUri);
  });

  app.addHook('onClose', async () => {
    await disconnectMongo();
  });

  app.addHook('onRequest', async (request) => {
    request.requestStartedAt = Date.now();
  });

  app.addHook('onSend', async (request, reply, payload) => {
    reply.header('x-request-id', request.id);
    return payload;
  });

  app.addHook('onResponse', async (request, reply) => {
    const durationMs = request.requestStartedAt
      ? Date.now() - request.requestStartedAt
      : undefined;

    request.log.info(
      {
        requestId: request.id,
        method: request.method,
        url: request.url,
        statusCode: reply.statusCode,
        userId: request.user?.id ?? null,
        durationMs,
      },
      'request completed',
    );
  });

  app.setErrorHandler((error: FastifyError, request, reply) => {
    if (error instanceof ApiError) {
      reply
        .status(error.statusCode)
        .send(toErrorPayload({ code: error.code, message: error.message, details: error.details }));
      return;
    }

    if (typeof error.statusCode === 'number' && error.statusCode >= 400 && error.statusCode < 500) {
      const message = config.isProduction ? 'Invalid request' : error.message;
      reply
        .status(error.statusCode)
        .send(toErrorPayload({ code: 'REQUEST_ERROR', message }));
      return;
    }

    request.log.error({ err: error }, 'unhandled server error');

    reply.status(500).send(
      toErrorPayload({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Unexpected server error',
      }),
    );
  });

  app.get('/health', async () => {
    return healthResponseSchema.parse({
      ok: true,
      name: config.apiName,
    });
  });

  registerAuthRoutes(app);
  registerMeRoute(app);
  registerAccountRoutes(app);
  registerCategoryRoutes(app);
  registerTransactionRoutes(app);
  registerTransferRoutes(app);
  registerRecurringRoutes(app);
  registerDashboardRoutes(app);
  registerAnalyticsRoutes(app);
  registerAiRoutes(app);
  registerReportRoutes(app);
  registerBudgetRoutes(app);
  registerGroupRoutes(app);
  registerExportRoutes(app);

  return app;
}
```

## FILE: apps/api/test/auth.e2e.test.ts
```
import { MongoMemoryServer } from 'mongodb-memory-server';
import request from 'supertest';
import { afterAll, beforeAll, beforeEach, describe, expect, it } from 'vitest';

import { AccountModel } from '../src/models/Account.js';
import { BudgetModel } from '../src/models/Budget.js';
import { CategoryModel } from '../src/models/Category.js';
import { GroupExpenseModel } from '../src/models/GroupExpense.js';
import { GroupModel } from '../src/models/Group.js';
import { RefreshTokenModel } from '../src/models/RefreshToken.js';
import { RecurringRunLogModel } from '../src/models/RecurringRunLog.js';
import { RecurringRuleModel } from '../src/models/RecurringRule.js';
import { TransactionModel } from '../src/models/Transaction.js';
import { UserModel } from '../src/models/User.js';
import { buildServer } from '../src/server.js';

describe('Auth + Finance API', () => {
  let mongo: MongoMemoryServer;
  let app!: ReturnType<typeof buildServer>;

  beforeAll(async () => {
    mongo = await MongoMemoryServer.create();

    process.env.MONGODB_URI = mongo.getUri();
    process.env.JWT_ACCESS_SECRET = 'test-access-secret';
    process.env.JWT_REFRESH_SECRET = 'test-refresh-secret';
    process.env.ACCESS_TTL_MIN = '15';
    process.env.REFRESH_TTL_DAYS = '30';
    process.env.CRON_SECRET = 'test-cron-secret';
    process.env.NODE_ENV = 'test';
    process.env.CORS_ORIGINS = 'http://localhost:8089';

    app = buildServer({ logger: false });
    await app.ready();
  }, 120000);

  beforeEach(async () => {
    await BudgetModel.deleteMany({});
    await TransactionModel.deleteMany({});
    await RecurringRunLogModel.deleteMany({});
    await RecurringRuleModel.deleteMany({});
    await GroupExpenseModel.deleteMany({});
    await GroupModel.deleteMany({});
    await CategoryModel.deleteMany({});
    await AccountModel.deleteMany({});
    await RefreshTokenModel.deleteMany({});
    await UserModel.deleteMany({});
  });

  afterAll(async () => {
    await app.close();

    if (mongo) {
      await mongo.stop();
    }
  }, 60000);

  async function registerUser(email: string, name = 'Fin User') {
    const response = await request(app.server).post('/auth/register').send({
      email,
      password: 'Password123',
      name,
    });

    expect(response.status).toBe(201);
    return response.body as {
      accessToken: string;
      refreshToken: string;
      user: { id: string; email: string; name: string | null };
    };
  }

  it('register -> login -> me success', async () => {
    const registerResponse = await request(app.server).post('/auth/register').send({
      email: 'user@example.com',
      password: 'Password123',
      name: 'Fin User',
    });

    expect(registerResponse.status).toBe(201);
    expect(registerResponse.body.user.email).toBe('user@example.com');
    expect(registerResponse.body.accessToken).toBeTypeOf('string');
    expect(registerResponse.body.refreshToken).toBeTypeOf('string');

    const loginResponse = await request(app.server).post('/auth/login').send({
      email: 'user@example.com',
      password: 'Password123',
    });

    expect(loginResponse.status).toBe(200);
    expect(loginResponse.body.user.email).toBe('user@example.com');

    const meResponse = await request(app.server)
      .get('/me')
      .set('Authorization', `Bearer ${loginResponse.body.accessToken}`);

    expect(meResponse.status).toBe(200);
    expect(meResponse.body).toEqual({
      user: {
        id: loginResponse.body.user.id,
        email: 'user@example.com',
        name: 'Fin User',
        baseCurrency: null,
      },
    });
  });

  it('allows creating multiple users without firebaseUid', async () => {
    const firstUser = await request(app.server).post('/auth/register').send({
      email: 'first-no-firebase@example.com',
      password: 'Password123',
      name: 'First User',
    });
    expect(firstUser.status).toBe(201);

    const secondUser = await request(app.server).post('/auth/register').send({
      email: 'second-no-firebase@example.com',
      password: 'Password123',
      name: 'Second User',
    });
    expect(secondUser.status).toBe(201);
  });

  it('returns invalid credentials on wrong password', async () => {
    await request(app.server).post('/auth/register').send({
      email: 'user@example.com',
      password: 'Password123',
      name: 'Fin User',
    });

    const response = await request(app.server).post('/auth/login').send({
      email: 'user@example.com',
      password: 'WrongPassword',
    });

    expect(response.status).toBe(401);
    expect(response.body).toEqual({
      error: {
        code: 'INVALID_CREDENTIALS',
        message: 'Invalid email or password',
      },
    });
  });

  it('rotates refresh token and invalidates old refresh token', async () => {
    await request(app.server).post('/auth/register').send({
      email: 'user@example.com',
      password: 'Password123',
      name: 'Fin User',
    });

    const loginResponse = await request(app.server).post('/auth/login').send({
      email: 'user@example.com',
      password: 'Password123',
    });

    const oldRefreshToken = loginResponse.body.refreshToken as string;

    const firstRefresh = await request(app.server).post('/auth/refresh').send({
      refreshToken: oldRefreshToken,
    });

    expect(firstRefresh.status).toBe(200);
    expect(firstRefresh.body.refreshToken).not.toBe(oldRefreshToken);

    const reuseOldRefresh = await request(app.server).post('/auth/refresh').send({
      refreshToken: oldRefreshToken,
    });

    expect(reuseOldRefresh.status).toBe(401);
    expect(reuseOldRefresh.body).toEqual({
      error: {
        code: 'INVALID_REFRESH_TOKEN',
        message: 'Refresh token is invalid or expired',
      },
    });
  });

  it('logout revokes refresh token', async () => {
    await request(app.server).post('/auth/register').send({
      email: 'user@example.com',
      password: 'Password123',
      name: 'Fin User',
    });

    const loginResponse = await request(app.server).post('/auth/login').send({
      email: 'user@example.com',
      password: 'Password123',
    });

    const refreshToken = loginResponse.body.refreshToken as string;

    const logoutResponse = await request(app.server).post('/auth/logout').send({ refreshToken });

    expect(logoutResponse.status).toBe(200);
    expect(logoutResponse.body).toEqual({ ok: true });

    const refreshAfterLogout = await request(app.server).post('/auth/refresh').send({ refreshToken });

    expect(refreshAfterLogout.status).toBe(401);
    expect(refreshAfterLogout.body).toEqual({
      error: {
        code: 'INVALID_REFRESH_TOKEN',
        message: 'Refresh token is invalid or expired',
      },
    });
  });

  it('logout returns INVALID_REFRESH_TOKEN for malformed refresh token', async () => {
    const response = await request(app.server).post('/auth/logout').send({
      refreshToken: 'not-a-valid-jwt',
    });

    expect(response.status).toBe(401);
    expect(response.body.error?.code).toBe('INVALID_REFRESH_TOKEN');
  });

  it('/me requires auth token', async () => {
    const response = await request(app.server).get('/me');

    expect(response.status).toBe(401);
    expect(response.body).toEqual({
      error: {
        code: 'UNAUTHORIZED',
        message: 'Missing Authorization header',
      },
    });
  });

  it('first account creation sets user baseCurrency', async () => {
    const session = await registerUser('base-currency-owner@example.com', 'Base Currency Owner');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const createAccount = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });

    expect(createAccount.status).toBe(201);

    const meResponse = await request(app.server).get('/me').set(authHeader);
    expect(meResponse.status).toBe(200);
    expect(meResponse.body.user.baseCurrency).toBe('USD');
  });

  it('creating second account with different currency fails', async () => {
    const session = await registerUser('second-account-currency@example.com', 'Currency Guard');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const firstAccount = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Primary',
      type: 'bank',
      currency: 'USD',
    });
    expect(firstAccount.status).toBe(201);

    const secondAccount = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Secondary',
      type: 'cash',
      currency: 'EUR',
    });

    expect(secondAccount.status).toBe(400);
    expect(secondAccount.body).toEqual({
      error: {
        code: 'BASE_CURRENCY_MISMATCH',
        message: 'Account currency must match your base currency',
      },
    });
  });

  it('updating account currency to a different currency fails', async () => {
    const session = await registerUser('update-currency-owner@example.com', 'Update Currency Owner');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const updateAccount = await request(app.server)
      .patch(`/accounts/${account.body.id}`)
      .set(authHeader)
      .send({ currency: 'EUR' });

    expect(updateAccount.status).toBe(400);
    expect(updateAccount.body).toEqual({
      error: {
        code: 'BASE_CURRENCY_MISMATCH',
        message: 'Account currency must match your base currency',
      },
    });
  });

  it('account CRUD', async () => {
    const session = await registerUser('account-owner@example.com', 'Account Owner');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const createAccount = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Wallet',
      type: 'cash',
      currency: 'USD',
    });

    expect(createAccount.status).toBe(201);
    expect(createAccount.body.name).toBe('Wallet');
    const accountId = createAccount.body.id as string;

    const listAccounts = await request(app.server).get('/accounts').set(authHeader);

    expect(listAccounts.status).toBe(200);
    expect(listAccounts.body.accounts).toHaveLength(1);
    expect(listAccounts.body.accounts[0].id).toBe(accountId);

    const updateAccount = await request(app.server).patch(`/accounts/${accountId}`).set(authHeader).send({
      name: 'Main Wallet',
      type: 'bank',
    });

    expect(updateAccount.status).toBe(200);
    expect(updateAccount.body.name).toBe('Main Wallet');
    expect(updateAccount.body.type).toBe('bank');

    const deleteAccount = await request(app.server).delete(`/accounts/${accountId}`).set(authHeader);

    expect(deleteAccount.status).toBe(200);
    expect(deleteAccount.body).toEqual({ ok: true });

    const listAfterDelete = await request(app.server).get('/accounts').set(authHeader);
    expect(listAfterDelete.status).toBe(200);
    expect(listAfterDelete.body.accounts).toHaveLength(0);
  });

  it('transaction CRUD', async () => {
    const session = await registerUser('tx-owner@example.com', 'Tx Owner');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const accountResponse = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Checking',
      type: 'bank',
      currency: 'USD',
    });
    expect(accountResponse.status).toBe(201);

    const categoryResponse = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Groceries',
      type: 'expense',
      color: '#12AA34',
      icon: 'cart',
    });
    expect(categoryResponse.status).toBe(201);

    const createTx = await request(app.server).post('/transactions').set(authHeader).send({
      accountId: accountResponse.body.id,
      categoryId: categoryResponse.body.id,
      type: 'expense',
      amount: 45.5,
      currency: 'USD',
      description: 'Weekly grocery',
      occurredAt: '2026-02-10T10:30:00.000Z',
    });

    expect(createTx.status).toBe(201);
    expect(createTx.body.amount).toBe(45.5);
    const transactionId = createTx.body.id as string;

    const getTx = await request(app.server).get(`/transactions/${transactionId}`).set(authHeader);
    expect(getTx.status).toBe(200);
    expect(getTx.body.description).toBe('Weekly grocery');

    const updateTx = await request(app.server).patch(`/transactions/${transactionId}`).set(authHeader).send({
      amount: 50,
      description: 'Weekly grocery updated',
    });
    expect(updateTx.status).toBe(200);
    expect(updateTx.body.amount).toBe(50);
    expect(updateTx.body.description).toBe('Weekly grocery updated');

    const deleteTx = await request(app.server).delete(`/transactions/${transactionId}`).set(authHeader);
    expect(deleteTx.status).toBe(200);
    expect(deleteTx.body).toEqual({ ok: true });

    const getAfterDelete = await request(app.server).get(`/transactions/${transactionId}`).set(authHeader);
    expect(getAfterDelete.status).toBe(404);
    expect(getAfterDelete.body.error.code).toBe('TRANSACTION_NOT_FOUND');
  });

  it('transaction listing supports pagination and filters', async () => {
    const session = await registerUser('filter-owner@example.com', 'Filter Owner');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const accountA = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Primary',
      type: 'bank',
      currency: 'USD',
    });
    const accountB = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Cash',
      type: 'cash',
      currency: 'USD',
    });
    expect(accountA.status).toBe(201);
    expect(accountB.status).toBe(201);

    const expenseCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Coffee',
      type: 'expense',
      color: '#AA2211',
      icon: 'cup',
    });
    const incomeCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Salary',
      type: 'income',
      color: '#11AA44',
      icon: 'banknote',
    });
    expect(expenseCategory.status).toBe(201);
    expect(incomeCategory.status).toBe(201);

    const txPayloads = [
      {
        accountId: accountA.body.id,
        categoryId: expenseCategory.body.id,
        type: 'expense',
        amount: 8,
        currency: 'USD',
        description: 'Morning coffee',
        occurredAt: '2026-02-11T08:00:00.000Z',
      },
      {
        accountId: accountA.body.id,
        categoryId: incomeCategory.body.id,
        type: 'income',
        amount: 1200,
        currency: 'USD',
        description: 'Monthly salary',
        occurredAt: '2026-02-09T08:00:00.000Z',
      },
      {
        accountId: accountB.body.id,
        categoryId: expenseCategory.body.id,
        type: 'expense',
        amount: 20,
        currency: 'USD',
        description: 'Coffee beans',
        occurredAt: '2026-02-12T08:00:00.000Z',
      },
    ];

    for (const payload of txPayloads) {
      const created = await request(app.server).post('/transactions').set(authHeader).send(payload);
      expect(created.status).toBe(201);
    }

    const expensePageOne = await request(app.server)
      .get('/transactions')
      .set(authHeader)
      .query({ type: 'expense', limit: 1, page: 1 });

    expect(expensePageOne.status).toBe(200);
    expect(expensePageOne.body.transactions).toHaveLength(1);
    expect(expensePageOne.body.pagination.total).toBe(2);
    expect(expensePageOne.body.pagination.totalPages).toBe(2);
    expect(expensePageOne.body.transactions[0].type).toBe('expense');

    const byAccountAndDate = await request(app.server)
      .get('/transactions')
      .set(authHeader)
      .query({
        accountId: accountA.body.id,
        from: '2026-02-10T00:00:00.000Z',
        to: '2026-02-12T23:59:59.000Z',
      });

    expect(byAccountAndDate.status).toBe(200);
    expect(byAccountAndDate.body.transactions).toHaveLength(1);
    expect(byAccountAndDate.body.transactions[0].description).toBe('Morning coffee');

    const bySearch = await request(app.server).get('/transactions').set(authHeader).query({ search: 'salary' });

    expect(bySearch.status).toBe(200);
    expect(bySearch.body.transactions).toHaveLength(1);
    expect(bySearch.body.transactions[0].description).toBe('Monthly salary');
  });

  it('cannot access another user transaction (object-level auth)', async () => {
    const owner = await registerUser('owner@example.com', 'Owner');
    const ownerHeader = { Authorization: `Bearer ${owner.accessToken}` };
    const attacker = await registerUser('attacker@example.com', 'Attacker');
    const attackerHeader = { Authorization: `Bearer ${attacker.accessToken}` };

    const ownerAccount = await request(app.server).post('/accounts').set(ownerHeader).send({
      name: 'Owner Account',
      type: 'bank',
      currency: 'USD',
    });
    const ownerCategory = await request(app.server).post('/categories').set(ownerHeader).send({
      name: 'Owner Expense',
      type: 'expense',
      color: '#334455',
      icon: 'shield',
    });

    expect(ownerAccount.status).toBe(201);
    expect(ownerCategory.status).toBe(201);

    const ownerTransaction = await request(app.server).post('/transactions').set(ownerHeader).send({
      accountId: ownerAccount.body.id,
      categoryId: ownerCategory.body.id,
      type: 'expense',
      amount: 99,
      currency: 'USD',
      description: 'Private transaction',
      occurredAt: '2026-02-12T08:00:00.000Z',
    });
    expect(ownerTransaction.status).toBe(201);

    const transactionId = ownerTransaction.body.id as string;

    const attackerGet = await request(app.server)
      .get(`/transactions/${transactionId}`)
      .set(attackerHeader);
    expect(attackerGet.status).toBe(404);
    expect(attackerGet.body.error.code).toBe('TRANSACTION_NOT_FOUND');

    const attackerPatch = await request(app.server)
      .patch(`/transactions/${transactionId}`)
      .set(attackerHeader)
      .send({ description: 'hacked' });
    expect(attackerPatch.status).toBe(404);
    expect(attackerPatch.body.error.code).toBe('TRANSACTION_NOT_FOUND');

    const attackerDelete = await request(app.server)
      .delete(`/transactions/${transactionId}`)
      .set(attackerHeader);
    expect(attackerDelete.status).toBe(404);
    expect(attackerDelete.body.error.code).toBe('TRANSACTION_NOT_FOUND');
  });

  it('analytics summary returns month totals and top categories', async () => {
    const session = await registerUser('analytics-summary@example.com', 'Analytics Summary');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const groceriesCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Groceries',
      type: 'expense',
      color: '#00AA44',
      icon: 'cart',
    });
    const rentCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Rent',
      type: 'expense',
      color: '#AA0044',
      icon: 'home',
    });
    const salaryCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Salary',
      type: 'income',
      color: '#4455AA',
      icon: 'wallet',
    });

    expect(groceriesCategory.status).toBe(201);
    expect(rentCategory.status).toBe(201);
    expect(salaryCategory.status).toBe(201);

    const payloads = [
      {
        accountId: account.body.id,
        categoryId: salaryCategory.body.id,
        type: 'income',
        amount: 3000,
        currency: 'USD',
        description: 'March salary',
        occurredAt: '2026-03-01T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: groceriesCategory.body.id,
        type: 'expense',
        amount: 200,
        currency: 'USD',
        description: 'Groceries',
        occurredAt: '2026-03-08T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: rentCategory.body.id,
        type: 'expense',
        amount: 1000,
        currency: 'USD',
        description: 'Rent',
        occurredAt: '2026-03-05T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: groceriesCategory.body.id,
        type: 'expense',
        amount: 80,
        currency: 'USD',
        description: 'Outside month',
        occurredAt: '2026-04-03T12:00:00.000Z',
      },
    ];

    for (const payload of payloads) {
      const created = await request(app.server).post('/transactions').set(authHeader).send(payload);
      expect(created.status).toBe(201);
    }

    const summary = await request(app.server)
      .get('/analytics/summary')
      .set(authHeader)
      .query({ month: '2026-03' });

    expect(summary.status).toBe(200);
    expect(summary.body.month).toBe('2026-03');
    expect(summary.body.currency).toBe('USD');
    expect(summary.body.incomeTotal).toBe(3000);
    expect(summary.body.expenseTotal).toBe(1200);
    expect(summary.body.netTotal).toBe(1800);
    expect(summary.body.transactionCount).toBe(3);

    const groceries = summary.body.topCategories.find(
      (category: { name: string }) => category.name === 'Groceries',
    );
    const salary = summary.body.topCategories.find(
      (category: { name: string }) => category.name === 'Salary',
    );

    expect(groceries).toBeDefined();
    expect(groceries.percent).toBeCloseTo((200 / 1200) * 100, 5);
    expect(salary).toBeDefined();
    expect(salary.percent).toBeCloseTo(100, 5);
  });

  it('analytics by-category returns grouped totals sorted desc', async () => {
    const session = await registerUser('analytics-category@example.com', 'Analytics Category');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const coffeeCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Coffee',
      type: 'expense',
      color: '#663300',
      icon: 'cup',
    });
    const travelCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Travel',
      type: 'expense',
      color: '#003366',
      icon: 'plane',
    });
    expect(coffeeCategory.status).toBe(201);
    expect(travelCategory.status).toBe(201);

    const payloads = [
      {
        accountId: account.body.id,
        categoryId: travelCategory.body.id,
        type: 'expense',
        amount: 900,
        currency: 'USD',
        description: 'Trip',
        occurredAt: '2026-05-01T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: coffeeCategory.body.id,
        type: 'expense',
        amount: 20,
        currency: 'USD',
        description: 'Coffee #1',
        occurredAt: '2026-05-02T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: coffeeCategory.body.id,
        type: 'expense',
        amount: 10,
        currency: 'USD',
        description: 'Coffee #2',
        occurredAt: '2026-05-03T12:00:00.000Z',
      },
    ];

    for (const payload of payloads) {
      const created = await request(app.server).post('/transactions').set(authHeader).send(payload);
      expect(created.status).toBe(201);
    }

    const byCategory = await request(app.server)
      .get('/analytics/by-category')
      .set(authHeader)
      .query({ month: '2026-05', type: 'expense' });

    expect(byCategory.status).toBe(200);
    expect(byCategory.body.month).toBe('2026-05');
    expect(byCategory.body.type).toBe('expense');
    expect(byCategory.body.currency).toBe('USD');
    expect(byCategory.body.categories).toHaveLength(2);
    expect(byCategory.body.categories[0].name).toBe('Travel');
    expect(byCategory.body.categories[0].total).toBe(900);
    expect(byCategory.body.categories[1].name).toBe('Coffee');
    expect(byCategory.body.categories[1].total).toBe(30);
    expect(byCategory.body.categories[1].count).toBe(2);
  });

  it('analytics trend includes zero-filled missing months', async () => {
    const session = await registerUser('analytics-trend@example.com', 'Analytics Trend');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const salaryCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Salary',
      type: 'income',
      color: '#11AA44',
      icon: 'wallet',
    });
    const groceriesCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Groceries',
      type: 'expense',
      color: '#AA1144',
      icon: 'cart',
    });

    expect(salaryCategory.status).toBe(201);
    expect(groceriesCategory.status).toBe(201);

    const payloads = [
      {
        accountId: account.body.id,
        categoryId: salaryCategory.body.id,
        type: 'income',
        amount: 1000,
        currency: 'USD',
        description: 'January income',
        occurredAt: '2026-01-15T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: groceriesCategory.body.id,
        type: 'expense',
        amount: 200,
        currency: 'USD',
        description: 'March expense',
        occurredAt: '2026-03-15T12:00:00.000Z',
      },
    ];

    for (const payload of payloads) {
      const created = await request(app.server).post('/transactions').set(authHeader).send(payload);
      expect(created.status).toBe(201);
    }

    const trend = await request(app.server)
      .get('/analytics/trend')
      .set(authHeader)
      .query({ from: '2026-01', to: '2026-03' });

    expect(trend.status).toBe(200);
    expect(trend.body.currency).toBe('USD');
    expect(trend.body.points).toEqual([
      {
        month: '2026-01',
        incomeTotal: 1000,
        expenseTotal: 0,
        netTotal: 1000,
      },
      {
        month: '2026-02',
        incomeTotal: 0,
        expenseTotal: 0,
        netTotal: 0,
      },
      {
        month: '2026-03',
        incomeTotal: 0,
        expenseTotal: 200,
        netTotal: -200,
      },
    ]);
  });

  it('ai advice returns rule-based insights and next actions', async () => {
    const session = await registerUser('ai-advice@example.com', 'AI Advice');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const salaryCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Salary',
      type: 'income',
      color: '#22AA55',
      icon: 'wallet',
    });
    const foodCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Food',
      type: 'expense',
      color: '#AA5533',
      icon: 'fork',
    });
    const travelCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Travel',
      type: 'expense',
      color: '#3355AA',
      icon: 'bus',
    });
    expect(salaryCategory.status).toBe(201);
    expect(foodCategory.status).toBe(201);
    expect(travelCategory.status).toBe(201);

    const budget = await request(app.server).post('/budgets').set(authHeader).send({
      categoryId: foodCategory.body.id,
      month: '2026-10',
      limitAmount: 100,
    });
    expect(budget.status).toBe(201);

    const payloads = [
      {
        accountId: account.body.id,
        categoryId: salaryCategory.body.id,
        type: 'income',
        amount: 1000,
        currency: 'USD',
        description: 'Monthly salary',
        occurredAt: '2026-10-01T09:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: foodCategory.body.id,
        type: 'expense',
        amount: 180,
        currency: 'USD',
        description: 'Food spending',
        occurredAt: '2026-10-07T09:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: travelCategory.body.id,
        type: 'expense',
        amount: 120,
        currency: 'USD',
        description: 'Metro and taxi',
        occurredAt: '2026-10-11T09:00:00.000Z',
      },
    ];

    for (const payload of payloads) {
      const created = await request(app.server).post('/transactions').set(authHeader).send(payload);
      expect(created.status).toBe(201);
    }

    const advice = await request(app.server)
      .get('/ai/advice')
      .set(authHeader)
      .query({ month: '2026-10' });

    expect(advice.status).toBe(200);
    expect(advice.body.month).toBe('2026-10');
    expect(advice.body.currency).toBe('USD');
    expect(advice.body.totalIncome).toBe(1000);
    expect(advice.body.totalExpense).toBe(300);
    expect(advice.body.net).toBe(700);
    expect(advice.body.topExpenseCategory?.name).toBe('Food');
    expect(advice.body.budgetOverruns).toHaveLength(1);
    expect(advice.body.budgetOverruns[0].categoryName).toBe('Food');
    expect(advice.body.budgetOverruns[0].overAmount).toBe(80);
    expect(advice.body.advice.length).toBeGreaterThan(0);
    expect(advice.body.nextActions.length).toBeGreaterThan(0);
  });

  it('weekly report returns health score, highlights, risks and forecast', async () => {
    const session = await registerUser('weekly-report@example.com', 'Weekly Report');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const incomeCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Salary',
      type: 'income',
      color: '#22AA55',
      icon: 'wallet',
    });
    const expenseCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Rent',
      type: 'expense',
      color: '#AA2255',
      icon: 'home',
    });
    expect(incomeCategory.status).toBe(201);
    expect(expenseCategory.status).toBe(201);

    const budget = await request(app.server).post('/budgets').set(authHeader).send({
      categoryId: expenseCategory.body.id,
      month: '2026-11',
      limitAmount: 500,
    });
    expect(budget.status).toBe(201);

    const payloads = [
      {
        accountId: account.body.id,
        categoryId: incomeCategory.body.id,
        type: 'income',
        amount: 1000,
        currency: 'USD',
        description: 'Income',
        occurredAt: '2026-11-04T10:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: expenseCategory.body.id,
        type: 'expense',
        amount: 950,
        currency: 'USD',
        description: 'Rent and extras',
        occurredAt: '2026-11-05T10:00:00.000Z',
      },
    ];

    for (const payload of payloads) {
      const created = await request(app.server).post('/transactions').set(authHeader).send(payload);
      expect(created.status).toBe(201);
    }

    const report = await request(app.server)
      .get('/reports/weekly')
      .set(authHeader)
      .query({ weekStart: '2026-11-03' });

    expect(report.status).toBe(200);
    expect(report.body.weekStart).toBe('2026-11-03');
    expect(report.body.weekEnd).toBe('2026-11-09');
    expect(report.body.currency).toBe('USD');
    expect(report.body.healthScore).toBeGreaterThanOrEqual(0);
    expect(report.body.healthScore).toBeLessThanOrEqual(100);
    expect(typeof report.body.summaryText).toBe('string');
    expect(report.body.summaryText.length).toBeGreaterThan(0);
    expect(report.body.highlights.length).toBeGreaterThan(0);
    expect(report.body.riskFlags.length).toBeGreaterThan(0);
    expect(typeof report.body.nextWeekForecastText).toBe('string');
    expect(report.body.nextWeekForecastText.length).toBeGreaterThan(0);
  });

  it('budgets create and usage reflects month expense transactions', async () => {
    const session = await registerUser('budget-usage@example.com', 'Budget Usage');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const expenseCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Dining',
      type: 'expense',
      color: '#CC5500',
      icon: 'utensils',
    });
    expect(expenseCategory.status).toBe(201);

    const budgetCreate = await request(app.server).post('/budgets').set(authHeader).send({
      categoryId: expenseCategory.body.id,
      month: '2026-06',
      limitAmount: 100,
    });

    expect(budgetCreate.status).toBe(201);

    const payloads = [
      {
        accountId: account.body.id,
        categoryId: expenseCategory.body.id,
        type: 'expense',
        amount: 20,
        currency: 'USD',
        description: 'Meal 1',
        occurredAt: '2026-06-02T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: expenseCategory.body.id,
        type: 'expense',
        amount: 35,
        currency: 'USD',
        description: 'Meal 2',
        occurredAt: '2026-06-10T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: expenseCategory.body.id,
        type: 'expense',
        amount: 12,
        currency: 'USD',
        description: 'Outside month',
        occurredAt: '2026-07-02T12:00:00.000Z',
      },
    ];

    for (const payload of payloads) {
      const created = await request(app.server).post('/transactions').set(authHeader).send(payload);
      expect(created.status).toBe(201);
    }

    const budgets = await request(app.server).get('/budgets').set(authHeader).query({ month: '2026-06' });

    expect(budgets.status).toBe(200);
    expect(budgets.body.budgets).toHaveLength(1);
    expect(budgets.body.budgets[0].categoryName).toBe('Dining');
    expect(budgets.body.budgets[0].spentAmount).toBe(55);
    expect(budgets.body.budgets[0].remainingAmount).toBe(45);
    expect(budgets.body.budgets[0].percentUsed).toBeCloseTo(55, 5);
  });

  it('cannot create budget for income category', async () => {
    const session = await registerUser('budget-income@example.com', 'Budget Income');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });

    const incomeCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Salary',
      type: 'income',
      color: '#00AA44',
      icon: 'wallet',
    });
    expect(incomeCategory.status).toBe(201);

    const createBudget = await request(app.server).post('/budgets').set(authHeader).send({
      categoryId: incomeCategory.body.id,
      month: '2026-06',
      limitAmount: 200,
    });

    expect(createBudget.status).toBe(400);
    expect(createBudget.body).toEqual({
      error: {
        code: 'INVALID_BUDGET_CATEGORY',
        message: 'Category must be an expense category',
      },
    });
  });

  it('budget routes enforce object-level authorization', async () => {
    const owner = await registerUser('budget-owner@example.com', 'Budget Owner');
    const ownerHeader = { Authorization: `Bearer ${owner.accessToken}` };
    const attacker = await registerUser('budget-attacker@example.com', 'Budget Attacker');
    const attackerHeader = { Authorization: `Bearer ${attacker.accessToken}` };

    await request(app.server).post('/accounts').set(ownerHeader).send({
      name: 'Owner Main',
      type: 'bank',
      currency: 'USD',
    });

    const ownerCategory = await request(app.server).post('/categories').set(ownerHeader).send({
      name: 'Owner Category',
      type: 'expense',
      color: '#2222AA',
      icon: 'shield',
    });
    expect(ownerCategory.status).toBe(201);

    const ownerBudget = await request(app.server).post('/budgets').set(ownerHeader).send({
      categoryId: ownerCategory.body.id,
      month: '2026-08',
      limitAmount: 500,
    });
    expect(ownerBudget.status).toBe(201);

    const patchByAttacker = await request(app.server)
      .patch(`/budgets/${ownerBudget.body.id}`)
      .set(attackerHeader)
      .send({ limitAmount: 900 });
    expect(patchByAttacker.status).toBe(404);
    expect(patchByAttacker.body.error.code).toBe('BUDGET_NOT_FOUND');

    const deleteByAttacker = await request(app.server)
      .delete(`/budgets/${ownerBudget.body.id}`)
      .set(attackerHeader);
    expect(deleteByAttacker.status).toBe(404);
    expect(deleteByAttacker.body.error.code).toBe('BUDGET_NOT_FOUND');

    const attackerBudgets = await request(app.server)
      .get('/budgets')
      .set(attackerHeader)
      .query({ month: '2026-08' });
    expect(attackerBudgets.status).toBe(200);
    expect(attackerBudgets.body.budgets).toEqual([]);
  });

  it('groups create/list/get works for owner', async () => {
    const session = await registerUser('groups-owner@example.com', 'Groups Owner');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const created = await request(app.server).post('/groups').set(authHeader).send({
      name: 'Istanbul Trip',
      members: [
        { name: 'Ayse', email: 'ayse@example.com' },
        { name: 'Mehmet', email: 'mehmet@example.com' },
      ],
    });

    expect(created.status).toBe(201);
    expect(created.body.name).toBe('Istanbul Trip');
    expect(created.body.members.length).toBe(3);
    expect(created.body.members[0].email).toBe('groups-owner@example.com');

    const listed = await request(app.server).get('/groups').set(authHeader);
    expect(listed.status).toBe(200);
    expect(listed.body.groups).toHaveLength(1);
    expect(listed.body.groups[0].id).toBe(created.body.id);

    const detail = await request(app.server).get(`/groups/${created.body.id}`).set(authHeader);
    expect(detail.status).toBe(200);
    expect(detail.body.id).toBe(created.body.id);
    expect(detail.body.members.map((member: { name: string }) => member.name)).toContain('Ayse');
  });

  it('group expenses create/list and settle marks unsettled expenses', async () => {
    const session = await registerUser('groups-expense@example.com', 'Groups Expense');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const createdGroup = await request(app.server).post('/groups').set(authHeader).send({
      name: 'Weekend Plan',
      members: [
        { name: 'Ali', email: 'ali@example.com' },
        { name: 'Ece', email: 'ece@example.com' },
      ],
    });
    expect(createdGroup.status).toBe(201);

    const ownerMemberId = createdGroup.body.members.find(
      (member: { email: string }) => member.email === 'groups-expense@example.com',
    )?.id as string;
    const aliMemberId = createdGroup.body.members.find(
      (member: { email: string }) => member.email === 'ali@example.com',
    )?.id as string;
    const eceMemberId = createdGroup.body.members.find(
      (member: { email: string }) => member.email === 'ece@example.com',
    )?.id as string;

    expect(ownerMemberId).toBeTypeOf('string');
    expect(aliMemberId).toBeTypeOf('string');
    expect(eceMemberId).toBeTypeOf('string');

    const createExpense = await request(app.server)
      .post(`/groups/${createdGroup.body.id}/expenses`)
      .set(authHeader)
      .send({
        paidByMemberId: ownerMemberId,
        title: 'Dinner',
        amount: 900,
        currency: 'TRY',
        splits: [
          { memberId: ownerMemberId, amount: 300 },
          { memberId: aliMemberId, amount: 300 },
          { memberId: eceMemberId, amount: 300 },
        ],
      });

    expect(createExpense.status).toBe(201);
    expect(createExpense.body.title).toBe('Dinner');
    expect(createExpense.body.settledAt).toBeNull();

    const expenses = await request(app.server)
      .get(`/groups/${createdGroup.body.id}/expenses`)
      .set(authHeader);
    expect(expenses.status).toBe(200);
    expect(expenses.body.expenses).toHaveLength(1);
    expect(expenses.body.expenses[0].splits).toHaveLength(3);

    const settle = await request(app.server)
      .post(`/groups/${createdGroup.body.id}/settle`)
      .set(authHeader)
      .send({});
    expect(settle.status).toBe(200);
    expect(settle.body.ok).toBe(true);
    expect(settle.body.settledCount).toBe(1);

    const settledExpenses = await request(app.server)
      .get(`/groups/${createdGroup.body.id}/expenses`)
      .set(authHeader);
    expect(settledExpenses.status).toBe(200);
    expect(settledExpenses.body.expenses[0].settledAt).toBeTypeOf('string');
  });

  it('groups enforce owner-only object-level authorization', async () => {
    const owner = await registerUser('groups-owner-only@example.com', 'Owner');
    const ownerHeader = { Authorization: `Bearer ${owner.accessToken}` };
    const attacker = await registerUser('groups-attacker@example.com', 'Attacker');
    const attackerHeader = { Authorization: `Bearer ${attacker.accessToken}` };

    const createdGroup = await request(app.server).post('/groups').set(ownerHeader).send({
      name: 'Private Group',
      members: [{ name: 'Friend', email: 'friend@example.com' }],
    });
    expect(createdGroup.status).toBe(201);

    const readAttempt = await request(app.server)
      .get(`/groups/${createdGroup.body.id}`)
      .set(attackerHeader);
    expect(readAttempt.status).toBe(404);
    expect(readAttempt.body.error.code).toBe('GROUP_NOT_FOUND');

    const expenseAttempt = await request(app.server)
      .post(`/groups/${createdGroup.body.id}/expenses`)
      .set(attackerHeader)
      .send({
        paidByMemberId: createdGroup.body.members[0].id,
        title: 'Hack attempt',
        amount: 50,
        currency: 'TRY',
        splits: [{ memberId: createdGroup.body.members[0].id, amount: 50 }],
      });
    expect(expenseAttempt.status).toBe(404);
    expect(expenseAttempt.body.error.code).toBe('GROUP_NOT_FOUND');
  });

  it('soft-deleted transaction is excluded from lists, analytics, and budget usage', async () => {
    const session = await registerUser('soft-delete-tx@example.com', 'Soft Delete');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const category = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Food',
      type: 'expense',
      color: '#AA3311',
      icon: 'utensils',
    });
    expect(category.status).toBe(201);

    const budget = await request(app.server).post('/budgets').set(authHeader).send({
      categoryId: category.body.id,
      month: '2026-09',
      limitAmount: 200,
    });
    expect(budget.status).toBe(201);

    const createdTx = await request(app.server).post('/transactions').set(authHeader).send({
      accountId: account.body.id,
      categoryId: category.body.id,
      type: 'expense',
      amount: 60,
      currency: 'USD',
      description: 'Lunch',
      occurredAt: '2026-09-07T12:00:00.000Z',
    });
    expect(createdTx.status).toBe(201);

    const deleted = await request(app.server)
      .delete(`/transactions/${createdTx.body.id}`)
      .set(authHeader);
    expect(deleted.status).toBe(200);

    const activeList = await request(app.server).get('/transactions').set(authHeader);
    expect(activeList.status).toBe(200);
    expect(activeList.body.transactions).toHaveLength(0);

    const includeDeletedList = await request(app.server)
      .get('/transactions')
      .set(authHeader)
      .query({ includeDeleted: true });
    expect(includeDeletedList.status).toBe(200);
    expect(includeDeletedList.body.transactions).toHaveLength(1);

    const analytics = await request(app.server)
      .get('/analytics/summary')
      .set(authHeader)
      .query({ month: '2026-09' });
    expect(analytics.status).toBe(200);
    expect(analytics.body.expenseTotal).toBe(0);
    expect(analytics.body.transactionCount).toBe(0);

    const budgets = await request(app.server).get('/budgets').set(authHeader).query({ month: '2026-09' });
    expect(budgets.status).toBe(200);
    expect(budgets.body.budgets).toHaveLength(1);
    expect(budgets.body.budgets[0].spentAmount).toBe(0);
  });

  it('creating a transfer creates paired in/out transactions', async () => {
    const session = await registerUser('transfer-pair@example.com', 'Transfer Pair');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const [fromAccount, toAccount] = await Promise.all([
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Checking',
        type: 'bank',
        currency: 'USD',
      }),
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Cash',
        type: 'cash',
        currency: 'USD',
      }),
    ]);

    expect(fromAccount.status).toBe(201);
    expect(toAccount.status).toBe(201);

    const transfer = await request(app.server).post('/transfers').set(authHeader).send({
      fromAccountId: fromAccount.body.id,
      toAccountId: toAccount.body.id,
      amount: 120.25,
      occurredAt: '2026-09-08T09:00:00.000Z',
      description: 'ATM cashout',
    });

    expect(transfer.status).toBe(201);
    expect(transfer.body.groupId).toBeTypeOf('string');
    expect(transfer.body.fromTransactionId).toBeTypeOf('string');
    expect(transfer.body.toTransactionId).toBeTypeOf('string');

    const transferList = await request(app.server)
      .get('/transactions')
      .set(authHeader)
      .query({ kind: 'transfer', limit: 50, page: 1 });

    expect(transferList.status).toBe(200);
    expect(transferList.body.transactions).toHaveLength(2);

    const directions = transferList.body.transactions.map(
      (transaction: { transferDirection: string | null }) => transaction.transferDirection,
    );
    expect(directions).toContain('in');
    expect(directions).toContain('out');

    const groupIds = new Set(
      transferList.body.transactions.map((transaction: { transferGroupId: string | null }) => transaction.transferGroupId),
    );
    expect(groupIds.size).toBe(1);
  });

  it('dashboard balances reflect transfer while total net stays unchanged', async () => {
    const session = await registerUser('transfer-balance@example.com', 'Transfer Balance');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const [accountA, accountB] = await Promise.all([
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Bank',
        type: 'bank',
        currency: 'USD',
      }),
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Wallet',
        type: 'cash',
        currency: 'USD',
      }),
    ]);
    expect(accountA.status).toBe(201);
    expect(accountB.status).toBe(201);

    const incomeCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Salary',
      type: 'income',
      color: '#11AA44',
      icon: 'wallet',
    });
    expect(incomeCategory.status).toBe(201);

    const seedIncome = await request(app.server).post('/transactions').set(authHeader).send({
      accountId: accountA.body.id,
      categoryId: incomeCategory.body.id,
      type: 'income',
      amount: 500,
      currency: 'USD',
      description: 'Seed funds',
      occurredAt: '2026-09-09T08:00:00.000Z',
    });
    expect(seedIncome.status).toBe(201);

    const transfer = await request(app.server).post('/transfers').set(authHeader).send({
      fromAccountId: accountA.body.id,
      toAccountId: accountB.body.id,
      amount: 200,
      occurredAt: '2026-09-09T09:00:00.000Z',
      description: 'Move to wallet',
    });
    expect(transfer.status).toBe(201);

    const dashboard = await request(app.server).get('/dashboard/recent').set(authHeader);
    expect(dashboard.status).toBe(200);
    expect(dashboard.body.totalBalance).toBe(500);

    const balanceMap = new Map(
      dashboard.body.balances.map((entry: { accountId: string; balance: number }) => [
        entry.accountId,
        entry.balance,
      ]),
    );

    expect(balanceMap.get(accountA.body.id)).toBe(300);
    expect(balanceMap.get(accountB.body.id)).toBe(200);
  });

  it('cannot transfer between accounts owned by different users', async () => {
    const owner = await registerUser('transfer-owner@example.com', 'Transfer Owner');
    const ownerHeader = { Authorization: `Bearer ${owner.accessToken}` };
    const otherUser = await registerUser('transfer-other@example.com', 'Transfer Other');
    const otherHeader = { Authorization: `Bearer ${otherUser.accessToken}` };

    const ownerAccount = await request(app.server).post('/accounts').set(ownerHeader).send({
      name: 'Owner Account',
      type: 'bank',
      currency: 'USD',
    });
    const otherAccount = await request(app.server).post('/accounts').set(otherHeader).send({
      name: 'Other Account',
      type: 'bank',
      currency: 'USD',
    });

    expect(ownerAccount.status).toBe(201);
    expect(otherAccount.status).toBe(201);

    const forbiddenTransfer = await request(app.server).post('/transfers').set(ownerHeader).send({
      fromAccountId: ownerAccount.body.id,
      toAccountId: otherAccount.body.id,
      amount: 50,
      occurredAt: '2026-09-10T12:00:00.000Z',
    });

    expect(forbiddenTransfer.status).toBe(404);
    expect(forbiddenTransfer.body.error.code).toBe('ACCOUNT_NOT_FOUND');
  });

  it('weekly recurring rule generates one transaction and advances nextRunAt', async () => {
    const session = await registerUser('recurring-weekly@example.com', 'Recurring Weekly');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    const category = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Utilities',
      type: 'expense',
      color: '#3344AA',
      icon: 'bolt',
    });
    expect(account.status).toBe(201);
    expect(category.status).toBe(201);

    const createRule = await request(app.server).post('/recurring').set(authHeader).send({
      kind: 'normal',
      accountId: account.body.id,
      categoryId: category.body.id,
      type: 'expense',
      amount: 25,
      description: 'Weekly utility',
      cadence: 'weekly',
      dayOfWeek: 1,
      startAt: new Date().toISOString(),
    });
    expect(createRule.status).toBe(201);

    const ruleId = createRule.body.id as string;
    const dueAt = new Date(Date.now() - 60 * 1000);
    await RecurringRuleModel.updateOne(
      { _id: ruleId },
      {
        $set: {
          nextRunAt: dueAt,
          lastRunAt: null,
          isPaused: false,
        },
      },
    );

    const runDue = await request(app.server)
      .post('/recurring/run-due')
      .set('x-cron-secret', 'test-cron-secret')
      .send({});

    expect(runDue.status).toBe(200);
    expect(runDue.body.processedRuns).toBe(1);
    expect(runDue.body.generatedTransactions).toBe(1);

    const rule = await RecurringRuleModel.findById(ruleId);
    expect(rule).toBeTruthy();
    expect(rule?.lastRunAt?.toISOString()).toBe(dueAt.toISOString());
    expect(rule?.nextRunAt.toISOString()).toBe(
      new Date(dueAt.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString(),
    );

    const generatedTransactions = await request(app.server)
      .get('/transactions')
      .set(authHeader)
      .query({ kind: 'normal' });
    expect(generatedTransactions.status).toBe(200);
    expect(generatedTransactions.body.transactions).toHaveLength(1);
  });

  it('monthly recurring rule generates one transaction and advances to next month', async () => {
    const session = await registerUser('recurring-monthly@example.com', 'Recurring Monthly');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    const category = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Subscription',
      type: 'expense',
      color: '#AA8844',
      icon: 'card',
    });
    expect(account.status).toBe(201);
    expect(category.status).toBe(201);

    const createRule = await request(app.server).post('/recurring').set(authHeader).send({
      kind: 'normal',
      accountId: account.body.id,
      categoryId: category.body.id,
      type: 'expense',
      amount: 15,
      description: 'Monthly plan',
      cadence: 'monthly',
      dayOfMonth: 1,
      startAt: new Date().toISOString(),
    });
    expect(createRule.status).toBe(201);

    const ruleId = createRule.body.id as string;
    const now = new Date();
    const dueAt = new Date(
      Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), 1, now.getUTCHours(), now.getUTCMinutes(), 0, 0),
    );
    await RecurringRuleModel.updateOne(
      { _id: ruleId },
      {
        $set: {
          nextRunAt: dueAt,
          lastRunAt: null,
          isPaused: false,
        },
      },
    );

    const runDue = await request(app.server)
      .post('/recurring/run-due')
      .set('x-cron-secret', 'test-cron-secret')
      .send({});

    expect(runDue.status).toBe(200);
    expect(runDue.body.processedRuns).toBe(1);
    expect(runDue.body.generatedTransactions).toBe(1);

    const expectedNextRun = new Date(
      Date.UTC(
        dueAt.getUTCFullYear(),
        dueAt.getUTCMonth() + 1,
        1,
        dueAt.getUTCHours(),
        dueAt.getUTCMinutes(),
        dueAt.getUTCSeconds(),
        dueAt.getUTCMilliseconds(),
      ),
    );

    const rule = await RecurringRuleModel.findById(ruleId);
    expect(rule).toBeTruthy();
    expect(rule?.lastRunAt?.toISOString()).toBe(dueAt.toISOString());
    expect(rule?.nextRunAt.toISOString()).toBe(expectedNextRun.toISOString());
  });

  it('transfer recurring rule generates paired transactions', async () => {
    const session = await registerUser('recurring-transfer@example.com', 'Recurring Transfer');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const [fromAccount, toAccount] = await Promise.all([
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Bank',
        type: 'bank',
        currency: 'USD',
      }),
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Cash',
        type: 'cash',
        currency: 'USD',
      }),
    ]);

    expect(fromAccount.status).toBe(201);
    expect(toAccount.status).toBe(201);

    const createRule = await request(app.server).post('/recurring').set(authHeader).send({
      kind: 'transfer',
      fromAccountId: fromAccount.body.id,
      toAccountId: toAccount.body.id,
      amount: 40,
      description: 'Weekly transfer',
      cadence: 'weekly',
      dayOfWeek: 2,
      startAt: new Date().toISOString(),
    });
    expect(createRule.status).toBe(201);

    const ruleId = createRule.body.id as string;
    const dueAt = new Date(Date.now() - 60 * 1000);
    await RecurringRuleModel.updateOne(
      { _id: ruleId },
      {
        $set: {
          nextRunAt: dueAt,
          lastRunAt: null,
          isPaused: false,
        },
      },
    );

    const runDue = await request(app.server)
      .post('/recurring/run-due')
      .set('x-cron-secret', 'test-cron-secret')
      .send({});

    expect(runDue.status).toBe(200);
    expect(runDue.body.processedRuns).toBe(1);
    expect(runDue.body.generatedTransactions).toBe(2);

    const transfers = await request(app.server)
      .get('/transactions')
      .set(authHeader)
      .query({ kind: 'transfer' });
    expect(transfers.status).toBe(200);
    expect(transfers.body.transactions).toHaveLength(2);
  });

  it('paused and soft-deleted recurring rules are not executed', async () => {
    const session = await registerUser('recurring-paused@example.com', 'Recurring Paused');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    const category = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Bills',
      type: 'expense',
      color: '#7733AA',
      icon: 'receipt',
    });
    expect(account.status).toBe(201);
    expect(category.status).toBe(201);

    const pausedRule = await request(app.server).post('/recurring').set(authHeader).send({
      kind: 'normal',
      accountId: account.body.id,
      categoryId: category.body.id,
      type: 'expense',
      amount: 20,
      cadence: 'weekly',
      dayOfWeek: 3,
      startAt: new Date().toISOString(),
    });
    const deletedRule = await request(app.server).post('/recurring').set(authHeader).send({
      kind: 'normal',
      accountId: account.body.id,
      categoryId: category.body.id,
      type: 'expense',
      amount: 30,
      cadence: 'weekly',
      dayOfWeek: 4,
      startAt: new Date().toISOString(),
    });
    expect(pausedRule.status).toBe(201);
    expect(deletedRule.status).toBe(201);

    const dueAt = new Date(Date.now() - 60 * 1000);
    await RecurringRuleModel.updateOne(
      { _id: pausedRule.body.id },
      {
        $set: {
          nextRunAt: dueAt,
          isPaused: true,
        },
      },
    );
    await RecurringRuleModel.updateOne(
      { _id: deletedRule.body.id },
      {
        $set: {
          nextRunAt: dueAt,
          deletedAt: new Date(),
          isPaused: false,
        },
      },
    );

    const runDue = await request(app.server)
      .post('/recurring/run-due')
      .set('x-cron-secret', 'test-cron-secret')
      .send({});

    expect(runDue.status).toBe(200);
    expect(runDue.body.processedRules).toBe(0);
    expect(runDue.body.processedRuns).toBe(0);
    expect(runDue.body.generatedTransactions).toBe(0);

    const txCount = await TransactionModel.countDocuments({});
    expect(txCount).toBe(0);
  });

  it('exports transactions csv with expected headers and rows', async () => {
    const session = await registerUser('export-csv@example.com', 'CSV Export');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const [bank, wallet] = await Promise.all([
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Bank',
        type: 'bank',
        currency: 'USD',
      }),
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Wallet',
        type: 'cash',
        currency: 'USD',
      }),
    ]);
    expect(bank.status).toBe(201);
    expect(wallet.status).toBe(201);

    const expenseCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Groceries',
      type: 'expense',
      color: '#22AA66',
      icon: 'cart',
    });
    expect(expenseCategory.status).toBe(201);

    const normalTx = await request(app.server).post('/transactions').set(authHeader).send({
      accountId: bank.body.id,
      categoryId: expenseCategory.body.id,
      type: 'expense',
      amount: 35,
      currency: 'USD',
      description: 'Grocery run',
      occurredAt: '2026-09-10T08:00:00.000Z',
    });
    expect(normalTx.status).toBe(201);

    const transfer = await request(app.server).post('/transfers').set(authHeader).send({
      fromAccountId: bank.body.id,
      toAccountId: wallet.body.id,
      amount: 20,
      occurredAt: '2026-09-10T09:00:00.000Z',
      description: 'Cash move',
    });
    expect(transfer.status).toBe(201);

    const csvResponse = await request(app.server)
      .get('/export/transactions.csv')
      .set(authHeader)
      .query({
        from: '2026-09-01T00:00:00.000Z',
        to: '2026-09-30T23:59:59.000Z',
      });

    expect(csvResponse.status).toBe(200);
    expect(csvResponse.headers['content-type']).toContain('text/csv');

    const lines = csvResponse.text.trim().split('\n');
    expect(lines[0]).toBe(
      'occurredAt,type,kind,accountName,categoryName,amount,currency,description',
    );
    expect(lines.length).toBeGreaterThan(1);
    expect(csvResponse.text).toContain(',normal,');
    expect(csvResponse.text).toContain(',transfer,');
  });
});
```

## FILE: packages/shared/src/schemas.ts
```
import { z } from 'zod';

const emailSchema = z.string().trim().email().max(320);
const passwordSchema = z.string().min(8).max(128);
const currencySchema = z
  .string()
  .trim()
  .toUpperCase()
  .regex(/^[A-Z]{3}$/, 'Currency must be a 3-letter ISO code');
const monthStringSchema = z
  .string()
  .trim()
  .regex(/^\d{4}-(0[1-9]|1[0-2])$/, 'Month must be YYYY-MM');
const dateTimeStringSchema = z
  .string()
  .refine((value) => !Number.isNaN(Date.parse(value)), 'Invalid datetime');
const dateOnlyStringSchema = z
  .string()
  .trim()
  .regex(/^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$/, 'Date must be YYYY-MM-DD');

export const healthResponseSchema = z.object({
  ok: z.literal(true),
  name: z.literal('FinSight API'),
});

export const registerInputSchema = z.object({
  email: emailSchema,
  password: passwordSchema,
  name: z.string().trim().min(1).max(120).optional(),
});

export const loginInputSchema = z.object({
  email: emailSchema,
  password: z.string().min(1).max(128),
});

export const refreshInputSchema = z.object({
  refreshToken: z.string().min(1),
});

export const logoutInputSchema = z.object({
  refreshToken: z.string().min(1),
});

export const authUserSchema = z.object({
  id: z.string().min(1),
  email: emailSchema,
  name: z.string().nullable(),
});

export const authResponseSchema = z.object({
  accessToken: z.string().min(1),
  refreshToken: z.string().min(1),
  user: authUserSchema,
});

export const meResponseSchema = z.object({
  user: authUserSchema.extend({
    baseCurrency: currencySchema.nullable(),
  }),
});

export const logoutResponseSchema = z.object({
  ok: z.literal(true),
});

export const accountTypeSchema = z.enum(['cash', 'bank', 'credit']);
export const categoryTypeSchema = z.enum(['income', 'expense']);
export const transactionTypeSchema = z.enum(['income', 'expense']);
export const transactionKindSchema = z.enum(['normal', 'transfer']);
export const transferDirectionSchema = z.enum(['out', 'in']);
export const recurringCadenceSchema = z.enum(['weekly', 'monthly']);
export const recurringKindSchema = z.enum(['normal', 'transfer']);

export const accountSchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1).max(120),
  type: accountTypeSchema,
  currency: currencySchema,
  createdAt: dateTimeStringSchema,
  updatedAt: dateTimeStringSchema,
});

export const accountListResponseSchema = z.object({
  accounts: z.array(accountSchema),
});

export const accountCreateInputSchema = z.object({
  name: z.string().trim().min(1).max(120),
  type: accountTypeSchema,
  currency: currencySchema,
});

export const accountUpdateInputSchema = z
  .object({
    name: z.string().trim().min(1).max(120).optional(),
    type: accountTypeSchema.optional(),
    currency: currencySchema.optional(),
  })
  .refine((value) => Object.keys(value).length > 0, {
    message: 'At least one field must be provided',
  });

export const categorySchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1).max(120),
  type: categoryTypeSchema,
  color: z.string().regex(/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/, 'Invalid color hex'),
  icon: z.string().min(1).max(64).nullable(),
  isSystem: z.boolean(),
  createdAt: dateTimeStringSchema,
  updatedAt: dateTimeStringSchema,
});

export const categoryListResponseSchema = z.object({
  categories: z.array(categorySchema),
});

export const categoryCreateInputSchema = z.object({
  name: z.string().trim().min(1).max(120),
  type: categoryTypeSchema,
  color: z.string().regex(/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/, 'Invalid color hex'),
  icon: z.string().trim().min(1).max(64).optional(),
});

export const transactionSchema = z.object({
  id: z.string().min(1),
  accountId: z.string().min(1),
  categoryId: z.string().min(1).nullable(),
  type: transactionTypeSchema,
  kind: transactionKindSchema,
  transferGroupId: z.string().min(1).nullable(),
  transferDirection: transferDirectionSchema.nullable(),
  relatedAccountId: z.string().min(1).nullable(),
  amount: z.number().positive(),
  currency: currencySchema,
  description: z.string().max(500).nullable(),
  occurredAt: dateTimeStringSchema,
  createdAt: dateTimeStringSchema,
  updatedAt: dateTimeStringSchema,
});

export const transactionCreateInputSchema = z.object({
  accountId: z.string().trim().min(1),
  categoryId: z.string().trim().min(1),
  type: transactionTypeSchema,
  amount: z.number().positive(),
  currency: currencySchema,
  description: z.string().trim().max(500).optional(),
  occurredAt: dateTimeStringSchema,
});

export const transactionUpdateInputSchema = z
  .object({
    accountId: z.string().trim().min(1).optional(),
    categoryId: z.string().trim().min(1).optional(),
    type: transactionTypeSchema.optional(),
    amount: z.number().positive().optional(),
    currency: currencySchema.optional(),
    description: z.string().trim().max(500).nullable().optional(),
    occurredAt: dateTimeStringSchema.optional(),
  })
  .refine((value) => Object.keys(value).length > 0, {
    message: 'At least one field must be provided',
  });

export const transactionListQuerySchema = z
  .object({
    page: z.coerce.number().int().min(1).default(1),
    limit: z.coerce.number().int().min(1).max(100).default(20),
    accountId: z.string().trim().min(1).optional(),
    categoryId: z.string().trim().min(1).optional(),
    type: transactionTypeSchema.optional(),
    kind: transactionKindSchema.optional(),
    currency: currencySchema.optional(),
    from: dateTimeStringSchema.optional(),
    to: dateTimeStringSchema.optional(),
    search: z.string().trim().min(1).max(120).optional(),
    includeDeleted: z.coerce.boolean().default(false),
  })
  .refine(
    (value) => {
      if (!value.from || !value.to) {
        return true;
      }

      return new Date(value.from).getTime() <= new Date(value.to).getTime();
    },
    {
      message: '`from` must be less than or equal to `to`',
      path: ['from'],
    },
  );

export const transactionListResponseSchema = z.object({
  transactions: z.array(transactionSchema),
  pagination: z.object({
    page: z.number().int().min(1),
    limit: z.number().int().min(1),
    total: z.number().int().min(0),
    totalPages: z.number().int().min(0),
  }),
});

export const accountBalanceSchema = z.object({
  accountId: z.string().min(1),
  name: z.string().min(1).max(120),
  type: accountTypeSchema,
  currency: currencySchema,
  balance: z.number(),
});

export const dashboardRecentResponseSchema = z.object({
  recentTransactions: z.array(transactionSchema),
  totalBalance: z.number(),
  balances: z.array(accountBalanceSchema),
});

export const transferCreateInputSchema = z
  .object({
    fromAccountId: z.string().trim().min(1),
    toAccountId: z.string().trim().min(1),
    amount: z.number().positive(),
    occurredAt: dateTimeStringSchema,
    description: z.string().trim().max(500).optional(),
  })
  .refine((value) => value.fromAccountId !== value.toAccountId, {
    message: '`fromAccountId` and `toAccountId` must differ',
    path: ['toAccountId'],
  });

export const transferCreateResponseSchema = z.object({
  groupId: z.string().min(1),
  fromTransactionId: z.string().min(1),
  toTransactionId: z.string().min(1),
});

export const analyticsSummaryQuerySchema = z.object({
  month: monthStringSchema,
});

export const analyticsTopCategorySchema = z.object({
  categoryId: z.string().min(1),
  name: z.string().min(1).max(120),
  type: categoryTypeSchema,
  total: z.number().min(0),
  percent: z.number().min(0),
});

export const analyticsSummaryResponseSchema = z.object({
  month: monthStringSchema,
  currency: currencySchema.nullable(),
  incomeTotal: z.number().min(0),
  expenseTotal: z.number().min(0),
  netTotal: z.number(),
  transactionCount: z.number().int().min(0),
  topCategories: z.array(analyticsTopCategorySchema),
});

export const analyticsByCategoryQuerySchema = z.object({
  month: monthStringSchema,
  type: categoryTypeSchema,
});

export const analyticsByCategoryItemSchema = z.object({
  categoryId: z.string().min(1),
  name: z.string().min(1).max(120),
  total: z.number().min(0),
  count: z.number().int().min(0),
});

export const analyticsByCategoryResponseSchema = z.object({
  month: monthStringSchema,
  type: categoryTypeSchema,
  currency: currencySchema.nullable(),
  categories: z.array(analyticsByCategoryItemSchema),
});

export const analyticsTrendQuerySchema = z
  .object({
    from: monthStringSchema,
    to: monthStringSchema,
  })
  .refine((value) => value.from <= value.to, {
    message: '`from` must be less than or equal to `to`',
    path: ['from'],
  });

export const analyticsTrendPointSchema = z.object({
  month: monthStringSchema,
  incomeTotal: z.number().min(0),
  expenseTotal: z.number().min(0),
  netTotal: z.number(),
});

export const analyticsTrendResponseSchema = z.object({
  currency: currencySchema.nullable(),
  points: z.array(analyticsTrendPointSchema),
});

export const aiAdviceSeveritySchema = z.enum(['info', 'warning', 'success']);

export const aiAdviceQuerySchema = z.object({
  month: monthStringSchema,
});

export const aiAdviceItemSchema = z.object({
  title: z.string().min(1).max(140),
  message: z.string().min(1).max(500),
  severity: aiAdviceSeveritySchema,
});

export const aiAdviceBudgetOverrunSchema = z.object({
  budgetId: z.string().min(1),
  categoryId: z.string().min(1),
  categoryName: z.string().min(1).max(120),
  limitAmount: z.number().min(0),
  spentAmount: z.number().min(0),
  overAmount: z.number().min(0),
});

export const aiAdviceResponseSchema = z.object({
  month: monthStringSchema,
  currency: currencySchema.nullable(),
  totalIncome: z.number().min(0),
  totalExpense: z.number().min(0),
  net: z.number(),
  topExpenseCategory: z
    .object({
      categoryId: z.string().min(1),
      name: z.string().min(1).max(120),
      total: z.number().min(0),
    })
    .nullable(),
  budgetOverruns: z.array(aiAdviceBudgetOverrunSchema),
  advice: z.array(aiAdviceItemSchema),
  nextActions: z.array(z.string().min(1).max(280)),
});

export const weeklyReportQuerySchema = z.object({
  weekStart: dateOnlyStringSchema.optional(),
});

export const weeklyReportResponseSchema = z.object({
  weekStart: dateOnlyStringSchema,
  weekEnd: dateOnlyStringSchema,
  currency: currencySchema.nullable(),
  healthScore: z.number().int().min(0).max(100),
  summaryText: z.string().min(1).max(500),
  highlights: z.array(z.string().min(1).max(280)),
  riskFlags: z.array(z.string().min(1).max(280)),
  nextWeekForecastText: z.string().min(1).max(500),
});

export const groupMemberSchema = z.object({
  id: z.string().min(1),
  email: emailSchema,
  name: z.string().min(1).max(120),
  userId: z.string().min(1).nullable(),
});

export const groupSchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1).max(120),
  ownerUserId: z.string().min(1),
  members: z.array(groupMemberSchema),
  createdAt: dateTimeStringSchema,
  updatedAt: dateTimeStringSchema,
});

export const groupListResponseSchema = z.object({
  groups: z.array(groupSchema),
});

export const groupCreateInputMemberSchema = z.object({
  email: emailSchema,
  name: z.string().trim().min(1).max(120),
  userId: z.string().trim().min(1).optional(),
});

export const groupCreateInputSchema = z.object({
  name: z.string().trim().min(1).max(120),
  ownerName: z.string().trim().min(1).max(120).optional(),
  members: z.array(groupCreateInputMemberSchema).default([]),
});

export const groupExpenseSplitSchema = z.object({
  memberId: z.string().trim().min(1),
  amount: z.number().nonnegative(),
});

export const groupExpenseSchema = z.object({
  id: z.string().min(1),
  groupId: z.string().min(1),
  paidByMemberId: z.string().min(1),
  title: z.string().min(1).max(160),
  amount: z.number().positive(),
  currency: currencySchema,
  splits: z.array(groupExpenseSplitSchema),
  settledAt: dateTimeStringSchema.nullable(),
  createdAt: dateTimeStringSchema,
  updatedAt: dateTimeStringSchema,
});

export const groupExpenseCreateInputSchema = z.object({
  paidByMemberId: z.string().trim().min(1),
  title: z.string().trim().min(1).max(160),
  amount: z.number().positive(),
  currency: currencySchema,
  splits: z.array(groupExpenseSplitSchema).min(1),
});

export const groupExpenseListResponseSchema = z.object({
  expenses: z.array(groupExpenseSchema),
});

export const groupSettleResponseSchema = z.object({
  ok: z.literal(true),
  settledCount: z.number().int().min(0),
});

export const budgetSchema = z.object({
  id: z.string().min(1),
  categoryId: z.string().min(1),
  month: monthStringSchema,
  limitAmount: z.number().positive(),
  createdAt: dateTimeStringSchema,
  updatedAt: dateTimeStringSchema,
});

export const budgetListQuerySchema = z.object({
  month: monthStringSchema,
  includeDeleted: z.coerce.boolean().default(false),
});

export const budgetListItemSchema = z.object({
  id: z.string().min(1),
  categoryId: z.string().min(1),
  categoryName: z.string().min(1).max(120),
  month: monthStringSchema,
  limitAmount: z.number().positive(),
  spentAmount: z.number().min(0),
  remainingAmount: z.number(),
  percentUsed: z.number().min(0),
});

export const budgetListResponseSchema = z.object({
  budgets: z.array(budgetListItemSchema),
});

export const budgetCreateInputSchema = z.object({
  categoryId: z.string().trim().min(1),
  month: monthStringSchema,
  limitAmount: z.number().positive(),
});

export const budgetUpdateInputSchema = z.object({
  limitAmount: z.number().positive(),
});

export const recurringRuleSchema = z.object({
  id: z.string().min(1),
  kind: recurringKindSchema,
  accountId: z.string().min(1).nullable(),
  categoryId: z.string().min(1).nullable(),
  type: transactionTypeSchema.nullable(),
  fromAccountId: z.string().min(1).nullable(),
  toAccountId: z.string().min(1).nullable(),
  amount: z.number().positive(),
  description: z.string().max(500).nullable(),
  cadence: recurringCadenceSchema,
  dayOfWeek: z.number().int().min(0).max(6).nullable(),
  dayOfMonth: z.number().int().min(1).max(28).nullable(),
  startAt: dateTimeStringSchema,
  endAt: dateTimeStringSchema.nullable(),
  nextRunAt: dateTimeStringSchema,
  lastRunAt: dateTimeStringSchema.nullable(),
  isPaused: z.boolean(),
  deletedAt: dateTimeStringSchema.nullable(),
  createdAt: dateTimeStringSchema,
  updatedAt: dateTimeStringSchema,
});

const recurringScheduleFieldsSchema = z
  .object({
    cadence: recurringCadenceSchema,
    dayOfWeek: z.number().int().min(0).max(6).optional(),
    dayOfMonth: z.number().int().min(1).max(28).optional(),
  })
  .superRefine((value, ctx) => {
    if (value.cadence === 'weekly') {
      if (value.dayOfWeek === undefined) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: '`dayOfWeek` is required for weekly cadence',
          path: ['dayOfWeek'],
        });
      }
      return;
    }

    if (value.dayOfMonth === undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: '`dayOfMonth` is required for monthly cadence',
        path: ['dayOfMonth'],
      });
    }
  });

const recurringBaseCreateSchema = z.object({
  cadence: recurringCadenceSchema,
  dayOfWeek: z.number().int().min(0).max(6).optional(),
  dayOfMonth: z.number().int().min(1).max(28).optional(),
  startAt: dateTimeStringSchema,
  endAt: dateTimeStringSchema.optional(),
  amount: z.number().positive(),
  description: z.string().trim().max(500).optional(),
});

export const recurringCreateInputSchema = z
  .discriminatedUnion('kind', [
    recurringBaseCreateSchema.extend({
      kind: z.literal('normal'),
      accountId: z.string().trim().min(1),
      categoryId: z.string().trim().min(1),
      type: transactionTypeSchema,
    }),
    recurringBaseCreateSchema.extend({
      kind: z.literal('transfer'),
      fromAccountId: z.string().trim().min(1),
      toAccountId: z.string().trim().min(1),
    }),
  ])
  .and(recurringScheduleFieldsSchema);

export const recurringUpdateInputSchema = z
  .object({
    amount: z.number().positive().optional(),
    description: z.string().trim().max(500).nullable().optional(),
    isPaused: z.boolean().optional(),
    cadence: recurringCadenceSchema.optional(),
    dayOfWeek: z.number().int().min(0).max(6).optional(),
    dayOfMonth: z.number().int().min(1).max(28).optional(),
    endAt: dateTimeStringSchema.nullable().optional(),
  })
  .refine((value) => Object.keys(value).length > 0, {
    message: 'At least one field must be provided',
  })
  .superRefine((value, ctx) => {
    const cadence = value.cadence;
    if (cadence === 'weekly' && value.dayOfWeek === undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: '`dayOfWeek` is required when setting weekly cadence',
        path: ['dayOfWeek'],
      });
    }
    if (cadence === 'monthly' && value.dayOfMonth === undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: '`dayOfMonth` is required when setting monthly cadence',
        path: ['dayOfMonth'],
      });
    }
  });

export const recurringListQuerySchema = z.object({
  month: monthStringSchema.optional(),
  includeDeleted: z.coerce.boolean().default(false),
});

export const recurringListResponseSchema = z.object({
  rules: z.array(recurringRuleSchema),
});

export const recurringRunDueResponseSchema = z.object({
  processedRules: z.number().int().min(0),
  processedRuns: z.number().int().min(0),
  generatedTransactions: z.number().int().min(0),
});

export const exportTransactionsQuerySchema = z
  .object({
    from: dateTimeStringSchema.optional(),
    to: dateTimeStringSchema.optional(),
    accountId: z.string().trim().min(1).optional(),
    type: transactionTypeSchema.optional(),
    kind: transactionKindSchema.optional(),
  })
  .refine(
    (value) => {
      if (!value.from || !value.to) {
        return true;
      }
      return new Date(value.from).getTime() <= new Date(value.to).getTime();
    },
    {
      message: '`from` must be less than or equal to `to`',
      path: ['from'],
    },
  );

export const exportTransactionsCsvResponseSchema = z.string();

export const apiErrorSchema = z.object({
  error: z.object({
    code: z.string(),
    message: z.string(),
    details: z.unknown().optional(),
  }),
});

export type HealthResponse = z.infer<typeof healthResponseSchema>;
export type RegisterInput = z.infer<typeof registerInputSchema>;
export type LoginInput = z.infer<typeof loginInputSchema>;
export type RefreshInput = z.infer<typeof refreshInputSchema>;
export type LogoutInput = z.infer<typeof logoutInputSchema>;
export type AuthUser = z.infer<typeof authUserSchema>;
export type AuthResponse = z.infer<typeof authResponseSchema>;
export type MeResponse = z.infer<typeof meResponseSchema>;
export type LogoutResponse = z.infer<typeof logoutResponseSchema>;
export type AccountType = z.infer<typeof accountTypeSchema>;
export type CategoryType = z.infer<typeof categoryTypeSchema>;
export type TransactionType = z.infer<typeof transactionTypeSchema>;
export type TransactionKind = z.infer<typeof transactionKindSchema>;
export type TransferDirection = z.infer<typeof transferDirectionSchema>;
export type RecurringCadence = z.infer<typeof recurringCadenceSchema>;
export type RecurringKind = z.infer<typeof recurringKindSchema>;
export type Account = z.infer<typeof accountSchema>;
export type AccountListResponse = z.infer<typeof accountListResponseSchema>;
export type AccountCreateInput = z.infer<typeof accountCreateInputSchema>;
export type AccountUpdateInput = z.infer<typeof accountUpdateInputSchema>;
export type Category = z.infer<typeof categorySchema>;
export type CategoryListResponse = z.infer<typeof categoryListResponseSchema>;
export type CategoryCreateInput = z.infer<typeof categoryCreateInputSchema>;
export type Transaction = z.infer<typeof transactionSchema>;
export type TransactionCreateInput = z.infer<typeof transactionCreateInputSchema>;
export type TransactionUpdateInput = z.infer<typeof transactionUpdateInputSchema>;
export type TransactionListQuery = z.infer<typeof transactionListQuerySchema>;
export type TransactionListResponse = z.infer<typeof transactionListResponseSchema>;
export type AccountBalance = z.infer<typeof accountBalanceSchema>;
export type DashboardRecentResponse = z.infer<typeof dashboardRecentResponseSchema>;
export type TransferCreateInput = z.infer<typeof transferCreateInputSchema>;
export type TransferCreateResponse = z.infer<typeof transferCreateResponseSchema>;
export type AnalyticsSummaryQuery = z.infer<typeof analyticsSummaryQuerySchema>;
export type AnalyticsTopCategory = z.infer<typeof analyticsTopCategorySchema>;
export type AnalyticsSummaryResponse = z.infer<typeof analyticsSummaryResponseSchema>;
export type AnalyticsByCategoryQuery = z.infer<typeof analyticsByCategoryQuerySchema>;
export type AnalyticsByCategoryItem = z.infer<typeof analyticsByCategoryItemSchema>;
export type AnalyticsByCategoryResponse = z.infer<typeof analyticsByCategoryResponseSchema>;
export type AnalyticsTrendQuery = z.infer<typeof analyticsTrendQuerySchema>;
export type AnalyticsTrendPoint = z.infer<typeof analyticsTrendPointSchema>;
export type AnalyticsTrendResponse = z.infer<typeof analyticsTrendResponseSchema>;
export type AiAdviceSeverity = z.infer<typeof aiAdviceSeveritySchema>;
export type AiAdviceQuery = z.infer<typeof aiAdviceQuerySchema>;
export type AiAdviceItem = z.infer<typeof aiAdviceItemSchema>;
export type AiAdviceBudgetOverrun = z.infer<typeof aiAdviceBudgetOverrunSchema>;
export type AiAdviceResponse = z.infer<typeof aiAdviceResponseSchema>;
export type WeeklyReportQuery = z.infer<typeof weeklyReportQuerySchema>;
export type WeeklyReportResponse = z.infer<typeof weeklyReportResponseSchema>;
export type GroupMember = z.infer<typeof groupMemberSchema>;
export type Group = z.infer<typeof groupSchema>;
export type GroupListResponse = z.infer<typeof groupListResponseSchema>;
export type GroupCreateInputMember = z.infer<typeof groupCreateInputMemberSchema>;
export type GroupCreateInput = z.infer<typeof groupCreateInputSchema>;
export type GroupExpenseSplit = z.infer<typeof groupExpenseSplitSchema>;
export type GroupExpense = z.infer<typeof groupExpenseSchema>;
export type GroupExpenseCreateInput = z.infer<typeof groupExpenseCreateInputSchema>;
export type GroupExpenseListResponse = z.infer<typeof groupExpenseListResponseSchema>;
export type GroupSettleResponse = z.infer<typeof groupSettleResponseSchema>;
export type Budget = z.infer<typeof budgetSchema>;
export type BudgetListQuery = z.infer<typeof budgetListQuerySchema>;
export type BudgetListItem = z.infer<typeof budgetListItemSchema>;
export type BudgetListResponse = z.infer<typeof budgetListResponseSchema>;
export type BudgetCreateInput = z.infer<typeof budgetCreateInputSchema>;
export type BudgetUpdateInput = z.infer<typeof budgetUpdateInputSchema>;
export type RecurringRule = z.infer<typeof recurringRuleSchema>;
export type RecurringCreateInput = z.infer<typeof recurringCreateInputSchema>;
export type RecurringUpdateInput = z.infer<typeof recurringUpdateInputSchema>;
export type RecurringListQuery = z.infer<typeof recurringListQuerySchema>;
export type RecurringListResponse = z.infer<typeof recurringListResponseSchema>;
export type RecurringRunDueResponse = z.infer<typeof recurringRunDueResponseSchema>;
export type ExportTransactionsQuery = z.infer<typeof exportTransactionsQuerySchema>;
export type ExportTransactionsCsvResponse = z.infer<typeof exportTransactionsCsvResponseSchema>;
export type ApiErrorResponse = z.infer<typeof apiErrorSchema>;
```

## FILE: packages/shared/src/client.ts
```
import { z } from 'zod';

import {
  accountCreateInputSchema,
  accountListResponseSchema,
  accountSchema,
  accountUpdateInputSchema,
  analyticsByCategoryQuerySchema,
  analyticsByCategoryResponseSchema,
  analyticsSummaryQuerySchema,
  analyticsSummaryResponseSchema,
  analyticsTrendQuerySchema,
  analyticsTrendResponseSchema,
  aiAdviceQuerySchema,
  aiAdviceResponseSchema,
  apiErrorSchema,
  authResponseSchema,
  budgetCreateInputSchema,
  budgetListQuerySchema,
  budgetListResponseSchema,
  budgetSchema,
  budgetUpdateInputSchema,
  categoryCreateInputSchema,
  categoryListResponseSchema,
  categorySchema,
  dashboardRecentResponseSchema,
  exportTransactionsCsvResponseSchema,
  exportTransactionsQuerySchema,
  groupCreateInputSchema,
  groupExpenseCreateInputSchema,
  groupExpenseListResponseSchema,
  groupExpenseSchema,
  groupListResponseSchema,
  groupSchema,
  groupSettleResponseSchema,
  healthResponseSchema,
  logoutResponseSchema,
  meResponseSchema,
  recurringCreateInputSchema,
  recurringListQuerySchema,
  recurringListResponseSchema,
  recurringRuleSchema,
  recurringRunDueResponseSchema,
  recurringUpdateInputSchema,
  transferCreateInputSchema,
  transferCreateResponseSchema,
  transactionCreateInputSchema,
  transactionListQuerySchema,
  transactionListResponseSchema,
  transactionSchema,
  transactionUpdateInputSchema,
  weeklyReportQuerySchema,
  weeklyReportResponseSchema,
  type Account,
  type AccountCreateInput,
  type AccountListResponse,
  type AccountUpdateInput,
  type AnalyticsByCategoryQuery,
  type AnalyticsByCategoryResponse,
  type AnalyticsSummaryQuery,
  type AnalyticsSummaryResponse,
  type AnalyticsTrendQuery,
  type AnalyticsTrendResponse,
  type AiAdviceQuery,
  type AiAdviceResponse,
  type AuthResponse,
  type Budget,
  type BudgetCreateInput,
  type BudgetListQuery,
  type BudgetListResponse,
  type BudgetUpdateInput,
  type Category,
  type CategoryCreateInput,
  type CategoryListResponse,
  type DashboardRecentResponse,
  type ExportTransactionsCsvResponse,
  type ExportTransactionsQuery,
  type Group,
  type GroupCreateInput,
  type GroupExpense,
  type GroupExpenseCreateInput,
  type GroupExpenseListResponse,
  type GroupListResponse,
  type GroupSettleResponse,
  type HealthResponse,
  type LoginInput,
  type LogoutInput,
  type MeResponse,
  type RecurringCreateInput,
  type RecurringListQuery,
  type RecurringListResponse,
  type RecurringRule,
  type RecurringRunDueResponse,
  type RecurringUpdateInput,
  type RefreshInput,
  type RegisterInput,
  type TransferCreateInput,
  type TransferCreateResponse,
  type Transaction,
  type TransactionCreateInput,
  type TransactionListQuery,
  type TransactionListResponse,
  type TransactionUpdateInput,
  type WeeklyReportQuery,
  type WeeklyReportResponse,
} from './schemas';

type FetchLike = (input: string, init?: RequestInit) => Promise<Response>;

export interface ApiClientOptions {
  baseUrl?: string;
  fetchImpl?: FetchLike;
}

export interface NormalizedApiError {
  code: string;
  message: string;
  details?: unknown;
  status?: number;
}

interface RequestOptions {
  method?: 'GET' | 'POST' | 'PATCH' | 'DELETE';
  body?: unknown;
  accessToken?: string;
  query?: Record<string, unknown>;
}

export class ApiClientError extends Error {
  public readonly code: string;
  public readonly details?: unknown;
  public readonly status: number;

  constructor(params: { code: string; message: string; status: number; details?: unknown }) {
    super(params.message);
    this.code = params.code;
    this.details = params.details;
    this.status = params.status;
    this.name = 'ApiClientError';
  }
}

type ProcessLike = {
  env?: Record<string, string | undefined>;
};

function readEnv(): Record<string, string | undefined> {
  const processLike = (globalThis as { process?: ProcessLike }).process;
  return processLike?.env ?? {};
}

function trimTrailingSlash(value: string): string {
  return value.replace(/\/+$/, '');
}

function resolveBaseUrl(baseUrl?: string): string {
  if (baseUrl && baseUrl.trim()) {
    return trimTrailingSlash(baseUrl.trim());
  }

  const env = readEnv();
  const resolved = env.EXPO_PUBLIC_API_BASE_URL ?? env.API_BASE_URL ?? 'http://localhost:4000';
  return trimTrailingSlash(resolved);
}

async function readPayload(response: Response): Promise<unknown> {
  const text = await response.text();
  if (!text) {
    return null;
  }

  try {
    return JSON.parse(text);
  } catch {
    return text;
  }
}

function parseApiError(response: Response, payload: unknown): ApiClientError {
  const parsed = apiErrorSchema.safeParse(payload);

  if (parsed.success) {
    return new ApiClientError({
      code: parsed.data.error.code,
      message: parsed.data.error.message,
      details: parsed.data.error.details,
      status: response.status,
    });
  }

  return new ApiClientError({
    code: 'API_REQUEST_FAILED',
    message: `Request failed with status ${response.status}`,
    details: payload,
    status: response.status,
  });
}

function buildPathWithQuery(path: string, query?: Record<string, unknown>): string {
  if (!query) {
    return path;
  }

  const searchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(query)) {
    if (value === undefined || value === null) {
      continue;
    }

    if (Array.isArray(value)) {
      for (const entry of value) {
        searchParams.append(key, String(entry));
      }
      continue;
    }

    searchParams.append(key, String(value));
  }

  const queryString = searchParams.toString();
  if (!queryString) {
    return path;
  }

  return `${path}?${queryString}`;
}

export function normalizeApiError(error: unknown): NormalizedApiError {
  if (error instanceof ApiClientError) {
    return {
      code: error.code,
      message: error.message,
      details: error.details,
      status: error.status,
    };
  }

  if (error instanceof Error) {
    return {
      code: 'UNKNOWN_ERROR',
      message: error.message,
    };
  }

  return {
    code: 'UNKNOWN_ERROR',
    message: 'Unexpected error',
  };
}

export class ApiClient {
  private readonly baseUrl: string;
  private readonly fetchImpl: FetchLike;

  constructor(options: ApiClientOptions = {}) {
    this.baseUrl = resolveBaseUrl(options.baseUrl);
    this.fetchImpl = options.fetchImpl ?? ((input, init) => fetch(input, init));
  }

  async getHealth(): Promise<HealthResponse> {
    return this.request('/health', healthResponseSchema);
  }

  async register(input: RegisterInput): Promise<AuthResponse> {
    return this.request('/auth/register', authResponseSchema, {
      method: 'POST',
      body: input,
    });
  }

  async login(input: LoginInput): Promise<AuthResponse> {
    return this.request('/auth/login', authResponseSchema, {
      method: 'POST',
      body: input,
    });
  }

  async refresh(input: RefreshInput): Promise<AuthResponse> {
    return this.request('/auth/refresh', authResponseSchema, {
      method: 'POST',
      body: input,
    });
  }

  async logout(input: LogoutInput): Promise<void> {
    await this.request('/auth/logout', logoutResponseSchema, {
      method: 'POST',
      body: input,
    });
  }

  async getMe(accessToken: string): Promise<MeResponse> {
    return this.request('/me', meResponseSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async getAccounts(accessToken: string): Promise<AccountListResponse> {
    return this.request('/accounts', accountListResponseSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async createAccount(input: AccountCreateInput, accessToken: string): Promise<Account> {
    return this.request('/accounts', accountSchema, {
      method: 'POST',
      accessToken,
      body: accountCreateInputSchema.parse(input),
    });
  }

  async updateAccount(id: string, input: AccountUpdateInput, accessToken: string): Promise<Account> {
    return this.request(`/accounts/${encodeURIComponent(id)}`, accountSchema, {
      method: 'PATCH',
      accessToken,
      body: accountUpdateInputSchema.parse(input),
    });
  }

  async deleteAccount(id: string, accessToken: string): Promise<void> {
    await this.request(`/accounts/${encodeURIComponent(id)}`, logoutResponseSchema, {
      method: 'DELETE',
      accessToken,
    });
  }

  async getCategories(accessToken: string): Promise<CategoryListResponse> {
    return this.request('/categories', categoryListResponseSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async createCategory(input: CategoryCreateInput, accessToken: string): Promise<Category> {
    return this.request('/categories', categorySchema, {
      method: 'POST',
      accessToken,
      body: categoryCreateInputSchema.parse(input),
    });
  }

  async listTransactions(
    query: Partial<TransactionListQuery> = {},
    accessToken: string,
  ): Promise<TransactionListResponse> {
    return this.request('/transactions', transactionListResponseSchema, {
      method: 'GET',
      accessToken,
      query: transactionListQuerySchema.parse(query),
    });
  }

  async createTransfer(input: TransferCreateInput, accessToken: string): Promise<TransferCreateResponse> {
    return this.request('/transfers', transferCreateResponseSchema, {
      method: 'POST',
      accessToken,
      body: transferCreateInputSchema.parse(input),
    });
  }

  async createTransaction(input: TransactionCreateInput, accessToken: string): Promise<Transaction> {
    return this.request('/transactions', transactionSchema, {
      method: 'POST',
      accessToken,
      body: transactionCreateInputSchema.parse(input),
    });
  }

  async getTransaction(id: string, accessToken: string): Promise<Transaction> {
    return this.request(`/transactions/${encodeURIComponent(id)}`, transactionSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async updateTransaction(
    id: string,
    input: TransactionUpdateInput,
    accessToken: string,
  ): Promise<Transaction> {
    return this.request(`/transactions/${encodeURIComponent(id)}`, transactionSchema, {
      method: 'PATCH',
      accessToken,
      body: transactionUpdateInputSchema.parse(input),
    });
  }

  async deleteTransaction(id: string, accessToken: string): Promise<void> {
    await this.request(`/transactions/${encodeURIComponent(id)}`, logoutResponseSchema, {
      method: 'DELETE',
      accessToken,
    });
  }

  async getDashboardRecent(accessToken: string): Promise<DashboardRecentResponse> {
    return this.request('/dashboard/recent', dashboardRecentResponseSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async getAnalyticsSummary(
    query: AnalyticsSummaryQuery,
    accessToken: string,
  ): Promise<AnalyticsSummaryResponse> {
    return this.request('/analytics/summary', analyticsSummaryResponseSchema, {
      method: 'GET',
      accessToken,
      query: analyticsSummaryQuerySchema.parse(query),
    });
  }

  async getAnalyticsByCategory(
    query: AnalyticsByCategoryQuery,
    accessToken: string,
  ): Promise<AnalyticsByCategoryResponse> {
    return this.request('/analytics/by-category', analyticsByCategoryResponseSchema, {
      method: 'GET',
      accessToken,
      query: analyticsByCategoryQuerySchema.parse(query),
    });
  }

  async getAnalyticsTrend(query: AnalyticsTrendQuery, accessToken: string): Promise<AnalyticsTrendResponse> {
    return this.request('/analytics/trend', analyticsTrendResponseSchema, {
      method: 'GET',
      accessToken,
      query: analyticsTrendQuerySchema.parse(query),
    });
  }

  async getAiAdvice(query: AiAdviceQuery, accessToken: string): Promise<AiAdviceResponse> {
    return this.request('/ai/advice', aiAdviceResponseSchema, {
      method: 'GET',
      accessToken,
      query: aiAdviceQuerySchema.parse(query),
    });
  }

  async getWeeklyReport(
    query: Partial<WeeklyReportQuery> = {},
    accessToken: string,
  ): Promise<WeeklyReportResponse> {
    return this.request('/reports/weekly', weeklyReportResponseSchema, {
      method: 'GET',
      accessToken,
      query: weeklyReportQuerySchema.parse(query),
    });
  }

  async listBudgets(
    query: Partial<BudgetListQuery> = {},
    accessToken: string,
  ): Promise<BudgetListResponse> {
    return this.request('/budgets', budgetListResponseSchema, {
      method: 'GET',
      accessToken,
      query: budgetListQuerySchema.parse(query),
    });
  }

  async createBudget(input: BudgetCreateInput, accessToken: string): Promise<Budget> {
    return this.request('/budgets', budgetSchema, {
      method: 'POST',
      accessToken,
      body: budgetCreateInputSchema.parse(input),
    });
  }

  async updateBudget(id: string, input: BudgetUpdateInput, accessToken: string): Promise<Budget> {
    return this.request(`/budgets/${encodeURIComponent(id)}`, budgetSchema, {
      method: 'PATCH',
      accessToken,
      body: budgetUpdateInputSchema.parse(input),
    });
  }

  async deleteBudget(id: string, accessToken: string): Promise<void> {
    await this.request(`/budgets/${encodeURIComponent(id)}`, logoutResponseSchema, {
      method: 'DELETE',
      accessToken,
    });
  }

  async getGroups(accessToken: string): Promise<GroupListResponse> {
    return this.request('/groups', groupListResponseSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async createGroup(input: GroupCreateInput, accessToken: string): Promise<Group> {
    return this.request('/groups', groupSchema, {
      method: 'POST',
      accessToken,
      body: groupCreateInputSchema.parse(input),
    });
  }

  async getGroup(id: string, accessToken: string): Promise<Group> {
    return this.request(`/groups/${encodeURIComponent(id)}`, groupSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async getGroupExpenses(id: string, accessToken: string): Promise<GroupExpenseListResponse> {
    return this.request(`/groups/${encodeURIComponent(id)}/expenses`, groupExpenseListResponseSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async createGroupExpense(
    id: string,
    input: GroupExpenseCreateInput,
    accessToken: string,
  ): Promise<GroupExpense> {
    return this.request(`/groups/${encodeURIComponent(id)}/expenses`, groupExpenseSchema, {
      method: 'POST',
      accessToken,
      body: groupExpenseCreateInputSchema.parse(input),
    });
  }

  async settleGroup(id: string, accessToken: string): Promise<GroupSettleResponse> {
    return this.request(`/groups/${encodeURIComponent(id)}/settle`, groupSettleResponseSchema, {
      method: 'POST',
      accessToken,
      body: {},
    });
  }

  async listRecurring(
    query: Partial<RecurringListQuery> = {},
    accessToken: string,
  ): Promise<RecurringListResponse> {
    return this.request('/recurring', recurringListResponseSchema, {
      method: 'GET',
      accessToken,
      query: recurringListQuerySchema.parse(query),
    });
  }

  async createRecurring(input: RecurringCreateInput, accessToken: string): Promise<RecurringRule> {
    return this.request('/recurring', recurringRuleSchema, {
      method: 'POST',
      accessToken,
      body: recurringCreateInputSchema.parse(input),
    });
  }

  async updateRecurring(
    id: string,
    input: RecurringUpdateInput,
    accessToken: string,
  ): Promise<RecurringRule> {
    return this.request(`/recurring/${encodeURIComponent(id)}`, recurringRuleSchema, {
      method: 'PATCH',
      accessToken,
      body: recurringUpdateInputSchema.parse(input),
    });
  }

  async deleteRecurring(id: string, accessToken: string): Promise<void> {
    await this.request(`/recurring/${encodeURIComponent(id)}`, logoutResponseSchema, {
      method: 'DELETE',
      accessToken,
    });
  }

  async runRecurringDue(cronSecret: string): Promise<RecurringRunDueResponse> {
    return this.request(
      '/recurring/run-due',
      recurringRunDueResponseSchema,
      {
        method: 'POST',
      },
      {
        'x-cron-secret': cronSecret,
      },
    );
  }

  async exportTransactionsCsv(
    query: Partial<ExportTransactionsQuery> = {},
    accessToken: string,
  ): Promise<ExportTransactionsCsvResponse> {
    return this.request('/export/transactions.csv', exportTransactionsCsvResponseSchema, {
      method: 'GET',
      accessToken,
      query: exportTransactionsQuerySchema.parse(query),
    });
  }

  private async request<T>(
    path: string,
    schema: z.ZodSchema<T>,
    options: RequestOptions = {},
    extraHeaders?: Record<string, string>,
  ): Promise<T> {
    const method = options.method ?? 'GET';
    const resolvedPath = buildPathWithQuery(path, options.query);
    const headers: Record<string, string> = {
      Accept: 'application/json',
    };

    if (options.body !== undefined) {
      headers['Content-Type'] = 'application/json';
    }

    if (options.accessToken) {
      headers.Authorization = `Bearer ${options.accessToken}`;
    }
    if (extraHeaders) {
      Object.assign(headers, extraHeaders);
    }

    const response = await this.fetchImpl(`${this.baseUrl}${resolvedPath}`, {
      method,
      headers,
      body: options.body !== undefined ? JSON.stringify(options.body) : undefined,
    });

    const payload = await readPayload(response);

    if (!response.ok) {
      throw parseApiError(response, payload);
    }

    const parsedPayload = schema.safeParse(payload);
    if (!parsedPayload.success) {
      throw new ApiClientError({
        code: 'INVALID_RESPONSE_PAYLOAD',
        message: 'Received invalid response payload from API',
        details: parsedPayload.error.flatten(),
        status: response.status,
      });
    }

    return parsedPayload.data;
  }
}

export function createApiClient(options: ApiClientOptions = {}): ApiClient {
  return new ApiClient(options);
}
```

## FILE: packages/shared/src/index.ts
```
export {
  ApiClient,
  ApiClientError,
  createApiClient,
  normalizeApiError,
  type NormalizedApiError,
} from './client';
export {
  accountBalanceSchema,
  accountCreateInputSchema,
  accountListResponseSchema,
  accountSchema,
  accountTypeSchema,
  accountUpdateInputSchema,
  analyticsByCategoryItemSchema,
  analyticsByCategoryQuerySchema,
  analyticsByCategoryResponseSchema,
  analyticsSummaryQuerySchema,
  analyticsSummaryResponseSchema,
  analyticsTopCategorySchema,
  analyticsTrendPointSchema,
  analyticsTrendQuerySchema,
  analyticsTrendResponseSchema,
  aiAdviceBudgetOverrunSchema,
  aiAdviceItemSchema,
  aiAdviceQuerySchema,
  aiAdviceResponseSchema,
  aiAdviceSeveritySchema,
  apiErrorSchema,
  authResponseSchema,
  authUserSchema,
  budgetCreateInputSchema,
  budgetListItemSchema,
  budgetListQuerySchema,
  budgetListResponseSchema,
  budgetSchema,
  budgetUpdateInputSchema,
  categoryCreateInputSchema,
  categoryListResponseSchema,
  categorySchema,
  categoryTypeSchema,
  dashboardRecentResponseSchema,
  exportTransactionsCsvResponseSchema,
  exportTransactionsQuerySchema,
  groupCreateInputMemberSchema,
  groupCreateInputSchema,
  groupExpenseCreateInputSchema,
  groupExpenseListResponseSchema,
  groupExpenseSchema,
  groupExpenseSplitSchema,
  groupListResponseSchema,
  groupMemberSchema,
  groupSchema,
  groupSettleResponseSchema,
  healthResponseSchema,
  loginInputSchema,
  logoutInputSchema,
  logoutResponseSchema,
  meResponseSchema,
  recurringCadenceSchema,
  recurringCreateInputSchema,
  recurringKindSchema,
  recurringListQuerySchema,
  recurringListResponseSchema,
  recurringRuleSchema,
  recurringRunDueResponseSchema,
  recurringUpdateInputSchema,
  refreshInputSchema,
  registerInputSchema,
  transferCreateInputSchema,
  transferCreateResponseSchema,
  transferDirectionSchema,
  transactionCreateInputSchema,
  transactionKindSchema,
  transactionListQuerySchema,
  transactionListResponseSchema,
  transactionSchema,
  transactionTypeSchema,
  transactionUpdateInputSchema,
  weeklyReportQuerySchema,
  weeklyReportResponseSchema,
} from './schemas';
export type {
  Account,
  AccountBalance,
  AccountCreateInput,
  AccountListResponse,
  AccountType,
  AccountUpdateInput,
  AnalyticsByCategoryItem,
  AnalyticsByCategoryQuery,
  AnalyticsByCategoryResponse,
  AnalyticsSummaryQuery,
  AnalyticsSummaryResponse,
  AnalyticsTopCategory,
  AnalyticsTrendPoint,
  AnalyticsTrendQuery,
  AnalyticsTrendResponse,
  AiAdviceBudgetOverrun,
  AiAdviceItem,
  AiAdviceQuery,
  AiAdviceResponse,
  AiAdviceSeverity,
  ApiErrorResponse,
  AuthResponse,
  AuthUser,
  Budget,
  BudgetCreateInput,
  BudgetListItem,
  BudgetListQuery,
  BudgetListResponse,
  BudgetUpdateInput,
  Category,
  CategoryCreateInput,
  CategoryListResponse,
  CategoryType,
  DashboardRecentResponse,
  ExportTransactionsCsvResponse,
  ExportTransactionsQuery,
  Group,
  GroupCreateInput,
  GroupCreateInputMember,
  GroupExpense,
  GroupExpenseCreateInput,
  GroupExpenseListResponse,
  GroupExpenseSplit,
  GroupListResponse,
  GroupMember,
  GroupSettleResponse,
  HealthResponse,
  LoginInput,
  LogoutInput,
  LogoutResponse,
  MeResponse,
  RecurringCadence,
  RecurringCreateInput,
  RecurringKind,
  RecurringListQuery,
  RecurringListResponse,
  RecurringRule,
  RecurringRunDueResponse,
  RecurringUpdateInput,
  RefreshInput,
  RegisterInput,
  TransferCreateInput,
  TransferCreateResponse,
  TransferDirection,
  Transaction,
  TransactionCreateInput,
  TransactionKind,
  TransactionListQuery,
  TransactionListResponse,
  TransactionType,
  TransactionUpdateInput,
  WeeklyReportQuery,
  WeeklyReportResponse,
} from './schemas';
```

## FILE: apps/mobile/package.json
```
{
  "name": "mobile",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "dev": "expo start --port 8089",
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@mintly/shared": "workspace:*",
    "@hookform/resolvers": "^5.2.2",
    "@react-navigation/bottom-tabs": "^7.8.6",
    "@react-navigation/native": "^7.1.17",
    "@react-navigation/native-stack": "^7.3.25",
    "@tanstack/react-query": "^5.90.5",
    "expo": "~54.0.33",
    "expo-camera": "~17.0.8",
    "expo-secure-store": "~15.0.7",
    "expo-status-bar": "~3.0.9",
    "react": "19.1.0",
    "react-hook-form": "^7.66.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-safe-area-context": "5.6.1",
    "react-native-screens": "~4.16.0",
    "zod": "^4.3.6"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "typescript": "~5.9.2"
  },
  "private": true
}
```

## FILE: apps/mobile/src/api/queryKeys.ts
```
import type { CategoryType } from '@mintly/shared';

export const financeQueryKeys = {
  dashboard: {
    recent: () => ['dashboard', 'recent'] as const,
  },
  accounts: {
    all: () => ['accounts'] as const,
    list: () => ['accounts', 'list'] as const,
  },
  categories: {
    all: () => ['categories'] as const,
    list: () => ['categories', 'list'] as const,
  },
  transactions: {
    all: () => ['transactions'] as const,
    list: (filters: Record<string, unknown>) => ['transactions', 'list', filters] as const,
  },
  recurring: {
    all: () => ['recurring'] as const,
    list: (filters: Record<string, unknown>) => ['recurring', 'list', filters] as const,
  },
  analytics: {
    all: () => ['analytics'] as const,
    month: (month: string) => ['analytics', month] as const,
    summary: (month: string) => ['analytics', month, 'summary'] as const,
    byCategory: (month: string, type: CategoryType) =>
      ['analytics', month, 'by-category', type] as const,
    trend: (month: string, from: string, to: string) =>
      ['analytics', month, 'trend', { from, to }] as const,
  },
  ai: {
    all: () => ['ai'] as const,
    advice: (month: string) => ['ai', 'advice', month] as const,
  },
  reports: {
    all: () => ['reports'] as const,
    weekly: (weekStart?: string) => ['reports', 'weekly', weekStart ?? 'current'] as const,
  },
  groups: {
    all: () => ['groups'] as const,
    list: () => ['groups', 'list'] as const,
    detail: (groupId: string) => ['groups', 'detail', groupId] as const,
    expenses: (groupId: string) => ['groups', 'expenses', groupId] as const,
  },
  budgets: {
    all: () => ['budgets'] as const,
    month: (month: string) => ['budgets', month] as const,
    list: (month: string) => ['budgets', month, 'list'] as const,
  },
};
```

## FILE: apps/mobile/src/navigation/types.ts
```
import type { NavigatorScreenParams } from '@react-navigation/native';

export type ModuleStackParamList = {
  Hub: undefined;
  StitchPreview: { screenKey: string };
};

export type RootTabParamList = {
  HomeTab: NavigatorScreenParams<ModuleStackParamList>;
  TransactionsTab: NavigatorScreenParams<ModuleStackParamList>;
  AnalyticsTab: NavigatorScreenParams<ModuleStackParamList>;
  AddTab:
    | {
        prefill?: {
          amount?: string;
          description?: string;
          occurredAt?: string;
        };
      }
    | undefined;
  ProfileTab: NavigatorScreenParams<ModuleStackParamList>;
};

export type AuthStackParamList = {
  DebugInput: undefined;
  Login: undefined;
  Register: undefined;
  ForgotPassword: undefined;
};
```

## FILE: apps/mobile/src/navigation/stacks/TransactionsStack.tsx
```
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import { createStackOptions } from '../createStackOptions';
import { ScanCameraScreen } from '../../screens/scan/ScanCameraScreen';
import { ScanHomeScreen } from '../../screens/scan/ScanHomeScreen';
import { ScanReviewScreen } from '../../screens/scan/ScanReviewScreen';
import { AddGroupExpenseScreen } from '../../screens/split/AddGroupExpenseScreen';
import { CreateGroupScreen } from '../../screens/split/CreateGroupScreen';
import { GroupDetailScreen } from '../../screens/split/GroupDetailScreen';
import { GroupsScreen } from '../../screens/split/GroupsScreen';
import { SettleUpScreen } from '../../screens/split/SettleUpScreen';
import { RecurringScreen } from '../../screens/finance/RecurringScreen';
import { TransactionDetailScreen } from '../../screens/finance/TransactionDetailScreen';
import { TransferScreen } from '../../screens/finance/TransferScreen';
import { TransactionsScreen } from '../../screens/finance/TransactionsScreen';
import { useTheme } from '../../theme';

export type TransactionsStackParamList = {
  Transactions: undefined;
  TransactionDetail: { transactionId: string };
  Transfer: undefined;
  Recurring: undefined;
  ScanHome: undefined;
  ScanCamera: undefined;
  ScanReview: { photoUri: string };
  Groups: undefined;
  CreateGroup: undefined;
  GroupDetail: { groupId: string };
  AddGroupExpense: { groupId: string };
  SettleUp: { groupId: string };
};

const Stack = createNativeStackNavigator<TransactionsStackParamList>();

export function TransactionsStack() {
  const { theme } = useTheme();

  return (
    <Stack.Navigator screenOptions={createStackOptions(theme)}>
      <Stack.Screen
        name="Transactions"
        component={TransactionsScreen}
        options={{ headerShown: false }}
      />
      <Stack.Screen
        name="TransactionDetail"
        component={TransactionDetailScreen}
        options={{ headerShown: false }}
      />
      <Stack.Screen name="Transfer" component={TransferScreen} options={{ title: 'Transfer' }} />
      <Stack.Screen name="Recurring" component={RecurringScreen} options={{ title: 'Recurring' }} />
      <Stack.Screen name="ScanHome" component={ScanHomeScreen} options={{ title: 'Scan Receipt' }} />
      <Stack.Screen name="ScanCamera" component={ScanCameraScreen} options={{ title: 'Camera' }} />
      <Stack.Screen name="ScanReview" component={ScanReviewScreen} options={{ title: 'Review Scan' }} />
      <Stack.Screen name="Groups" component={GroupsScreen} options={{ title: 'Split Groups' }} />
      <Stack.Screen name="CreateGroup" component={CreateGroupScreen} options={{ title: 'Create Group' }} />
      <Stack.Screen name="GroupDetail" component={GroupDetailScreen} options={{ title: 'Group Detail' }} />
      <Stack.Screen name="AddGroupExpense" component={AddGroupExpenseScreen} options={{ title: 'Add Group Expense' }} />
      <Stack.Screen name="SettleUp" component={SettleUpScreen} options={{ title: 'Settle Up' }} />
    </Stack.Navigator>
  );
}
```

## FILE: apps/mobile/src/screens/finance/TransactionsScreen.tsx
```
import { useCallback, useMemo, useState } from 'react';
import {
  ActivityIndicator,
  FlatList,
  Pressable,
  RefreshControl,
  StyleSheet,
  Text,
  TextInput,
  View,
} from 'react-native';

import type { Transaction } from '@mintly/shared';
import { useInfiniteQuery } from '@tanstack/react-query';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useNavigation } from '@react-navigation/native';

import { apiClient } from '../../api/client';
import { financeQueryKeys } from '../../api/queryKeys';
import { useAuth } from '../../auth/AuthProvider';
import { Card, PrimaryButton, ScreenContainer, TransactionRow } from '../../components/ui';
import type { TransactionsStackParamList } from '../../navigation/stacks/TransactionsStack';
import { radius, spacing, typography, useTheme } from '../../theme';
import { apiErrorText } from '../../utils/apiErrorText';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/gncel_ilem_gemii_(bor_kapama_dahil)/screen.png
// no touch/keyboard behavior changed by this PR.

type TypeFilter = 'all' | 'income' | 'expense';

type ListItem =
  | { id: string; kind: 'header'; title: string }
  | { id: string; kind: 'transaction'; transaction: Transaction };

function formatCurrency(amount: number, currency: string): string {
  return new Intl.NumberFormat('tr-TR', {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

function formatSignedAmount(amount: number, currency: string, type: 'income' | 'expense'): string {
  const value = formatCurrency(amount, currency);
  return `${type === 'income' ? '+' : '-'}${value}`;
}

function formatTime(dateIso: string): string {
  const date = new Date(dateIso);
  if (Number.isNaN(date.getTime())) {
    return '--:--';
  }

  return date.toLocaleTimeString('tr-TR', {
    hour: '2-digit',
    minute: '2-digit',
  });
}

function getDayKey(dateIso: string): string {
  const date = new Date(dateIso);
  if (Number.isNaN(date.getTime())) {
    return 'unknown';
  }

  const year = date.getFullYear();
  const month = `${date.getMonth() + 1}`.padStart(2, '0');
  const day = `${date.getDate()}`.padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function getDayLabel(dayKey: string): string {
  if (dayKey === 'unknown') {
    return 'DIGER';
  }

  const [year, month, day] = dayKey.split('-').map(Number);
  const target = new Date(year, (month ?? 1) - 1, day ?? 1);
  if (Number.isNaN(target.getTime())) {
    return 'DIGER';
  }

  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const diffDays = Math.round((today.getTime() - target.getTime()) / (1000 * 60 * 60 * 24));

  if (diffDays === 0) {
    return 'BUGUN';
  }

  if (diffDays === 1) {
    return 'DUN';
  }

  return target
    .toLocaleDateString('tr-TR', {
      day: 'numeric',
      month: 'long',
    })
    .toLocaleUpperCase('tr-TR');
}

function buildListItems(transactions: Transaction[]): ListItem[] {
  const groups = new Map<string, Transaction[]>();

  for (const transaction of transactions) {
    const dayKey = getDayKey(transaction.occurredAt);
    const existing = groups.get(dayKey) ?? [];
    existing.push(transaction);
    groups.set(dayKey, existing);
  }

  const sortedDayKeys = [...groups.keys()].sort((a, b) => {
    if (a === 'unknown') {
      return 1;
    }
    if (b === 'unknown') {
      return -1;
    }
    return a < b ? 1 : -1;
  });

  const items: ListItem[] = [];

  for (const dayKey of sortedDayKeys) {
    items.push({
      id: `header-${dayKey}`,
      kind: 'header',
      title: getDayLabel(dayKey),
    });

    const groupTransactions = groups.get(dayKey) ?? [];
    for (const transaction of groupTransactions) {
      items.push({
        id: `tx-${transaction.id}`,
        kind: 'transaction',
        transaction,
      });
    }
  }

  return items;
}

function getTransactionTitle(transaction: Transaction): string {
  if (transaction.description?.trim()) {
    return transaction.description.trim();
  }

  if (transaction.kind === 'transfer') {
    return 'Hesap Transferi';
  }

  return transaction.type === 'income' ? 'Gelir Islemi' : 'Harcama';
}

function getCategoryHint(transaction: Transaction): string {
  if (transaction.kind === 'transfer') {
    return `Transfer  ${formatTime(transaction.occurredAt)}`;
  }

  return `${transaction.type === 'income' ? 'Gelir' : 'Gider'}  ${formatTime(transaction.occurredAt)}`;
}

function getCategoryIcon(transaction: Transaction): string {
  const title = getTransactionTitle(transaction);
  const firstLetter = title.charAt(0).toUpperCase();

  if (!firstLetter) {
    return transaction.type === 'income' ? '+' : '-';
  }

  if (transaction.kind === 'transfer') {
    return '';
  }

  return firstLetter;
}

function LoadingSkeleton() {
  return (
    <View style={styles.skeletonWrap}>
      <View style={styles.skeletonHeader} />
      <View style={styles.skeletonSearch} />
      <View style={styles.skeletonChips}>
        <View style={styles.skeletonChip} />
        <View style={styles.skeletonChip} />
        <View style={styles.skeletonChip} />
      </View>
      <View style={styles.skeletonSummaryRow}>
        <View style={styles.skeletonSummary} />
        <View style={styles.skeletonSummary} />
      </View>
      <View style={styles.skeletonItem} />
      <View style={styles.skeletonItem} />
      <View style={styles.skeletonItem} />
    </View>
  );
}

export function TransactionsScreen() {
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();

  const [draftSearch, setDraftSearch] = useState('');
  const [activeSearch, setActiveSearch] = useState('');
  const [typeFilter, setTypeFilter] = useState<TypeFilter>('all');

  const queryFilters = useMemo(
    () => ({
      search: activeSearch.trim() || undefined,
      type: typeFilter === 'all' ? undefined : typeFilter,
    }),
    [activeSearch, typeFilter],
  );

  const transactionsQuery = useInfiniteQuery({
    queryKey: financeQueryKeys.transactions.list(queryFilters),
    initialPageParam: 1,
    queryFn: ({ pageParam }) =>
      withAuth((token) =>
        apiClient.listTransactions(
          {
            ...queryFilters,
            page: pageParam,
            limit: 20,
          },
          token,
        ),
      ),
    getNextPageParam: (lastPage) => {
      if (lastPage.pagination.page >= lastPage.pagination.totalPages) {
        return undefined;
      }

      return lastPage.pagination.page + 1;
    },
  });

  const transactions = useMemo(
    () => transactionsQuery.data?.pages.flatMap((page) => page.transactions) ?? [],
    [transactionsQuery.data?.pages],
  );

  const totals = useMemo(() => {
    let income = 0;
    let expense = 0;

    for (const transaction of transactions) {
      if (transaction.kind === 'transfer') {
        continue;
      }

      if (transaction.type === 'income') {
        income += transaction.amount;
      } else {
        expense += transaction.amount;
      }
    }

    return {
      income,
      expense,
    };
  }, [transactions]);

  const listItems = useMemo(() => buildListItems(transactions), [transactions]);

  const renderListItem = useCallback(
    ({ item }: { item: ListItem }) => {
      if (item.kind === 'header') {
        return <Text style={[styles.groupHeader, { color: theme.colors.textMuted }]}>{item.title}</Text>;
      }

      const transaction = item.transaction;
      return (
        <TransactionRow
          amount={formatSignedAmount(transaction.amount, transaction.currency, transaction.type)}
          categoryIcon={getCategoryIcon(transaction)}
          date={getCategoryHint(transaction)}
          dark={mode === 'dark'}
          kind={transaction.kind}
          onPress={() => navigation.navigate('TransactionDetail', { transactionId: transaction.id })}
          title={getTransactionTitle(transaction)}
          type={transaction.type}
        />
      );
    },
    [mode, navigation, theme.colors.textMuted],
  );

  if (transactionsQuery.isLoading) {
    return (
      <ScreenContainer scrollable={false} contentStyle={styles.containerContent}>
        <LoadingSkeleton />
      </ScreenContainer>
    );
  }

  if (transactionsQuery.isError) {
    return (
      <ScreenContainer>
        <Card style={styles.errorCard}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>Islemler yuklenemedi</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(transactionsQuery.error)}</Text>
          <PrimaryButton label="Tekrar dene" onPress={() => void transactionsQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  return (
    <ScreenContainer scrollable={false} contentStyle={styles.containerContent}>
      <FlatList
        contentContainerStyle={styles.listContent}
        data={listItems}
        ItemSeparatorComponent={() => <View style={styles.itemSeparator} />}
        keyExtractor={(item) => item.id}
        ListEmptyComponent={
          <Card>
            <Text style={[styles.emptyText, { color: theme.colors.textMuted }]}>Filtrelere uygun islem bulunamadi.</Text>
          </Card>
        }
        ListFooterComponent={
          transactionsQuery.hasNextPage ? (
            <View style={styles.footerLoaderWrap}>
              {transactionsQuery.isFetchingNextPage ? (
                <>
                  <ActivityIndicator color={theme.colors.primary} size="small" />
                  <Text style={[styles.footerLoaderText, { color: theme.colors.textMuted }]}>Daha fazla yukleniyor...</Text>
                </>
              ) : (
                <PrimaryButton
                  label="Daha fazla"
                  onPress={() => {
                    void transactionsQuery.fetchNextPage();
                  }}
                />
              )}
            </View>
          ) : (
            <View style={styles.footerSpacer} />
          )
        }
        ListHeaderComponent={
          <View style={styles.headerWrap}>
            <View style={styles.topBar}>
              <Pressable
                accessibilityRole="button"
                onPress={() => {
                  if (navigation.canGoBack()) {
                    navigation.goBack();
                  }
                }}
                style={styles.iconButton}
              >
                <Text style={[styles.iconButtonText, { color: theme.colors.text }]}>{'<'}</Text>
              </Pressable>

              <Text style={[styles.screenTitle, { color: theme.colors.text }]}>Islem Gecmisi</Text>

              <Pressable accessibilityRole="button" onPress={() => undefined} style={styles.iconButton}>
                <Text style={[styles.iconButtonText, { color: theme.colors.text }]}></Text>
              </Pressable>
            </View>

            <View
              style={[
                styles.searchWrap,
                {
                  backgroundColor: mode === 'dark' ? '#111A2E' : '#EEF2FA',
                },
              ]}
            >
              <Text style={[styles.searchIcon, { color: mode === 'dark' ? '#5C79C8' : '#6A84CB' }]}></Text>
              <TextInput
                autoCapitalize="none"
                onChangeText={setDraftSearch}
                onSubmitEditing={() => setActiveSearch(draftSearch)}
                placeholder="Islem veya magaza ara..."
                placeholderTextColor={theme.colors.textMuted}
                returnKeyType="search"
                style={[styles.searchInput, { color: theme.colors.text }]}
                value={draftSearch}
              />
            </View>

            <View style={styles.filterChipRow}>
              {(['all', 'income', 'expense'] as const).map((filter) => {
                const isActive = typeFilter === filter;
                const label = filter === 'all' ? 'Tumu' : filter === 'income' ? 'Gelir' : 'Gider';

                return (
                  <Pressable
                    key={filter}
                    accessibilityRole="button"
                    onPress={() => setTypeFilter(filter)}
                    style={[
                      styles.filterChip,
                      {
                        backgroundColor: isActive
                          ? theme.colors.primary
                          : mode === 'dark'
                            ? 'rgba(47,107,255,0.20)'
                            : '#EAF0FF',
                      },
                    ]}
                  >
                    <Text
                      style={[
                        styles.filterChipText,
                        {
                          color: isActive
                            ? '#FFFFFF'
                            : theme.colors.primary,
                        },
                      ]}
                    >
                      {label}
                    </Text>
                  </Pressable>
                );
              })}

              <Pressable
                accessibilityRole="button"
                onPress={() => setActiveSearch(draftSearch)}
                style={[
                  styles.filterApplyButton,
                  {
                    borderColor: mode === 'dark' ? 'rgba(255,255,255,0.12)' : '#D8E0EE',
                    backgroundColor: mode === 'dark' ? '#151D2E' : '#FFFFFF',
                  },
                ]}
              >
                <Text style={[styles.filterApplyText, { color: theme.colors.textMuted }]}>Ara</Text>
              </Pressable>
            </View>

            <View style={styles.summaryRow}>
              <View
                style={[
                  styles.summaryCard,
                  {
                    backgroundColor: mode === 'dark' ? '#171F33' : '#FFFFFF',
                    borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#EAF0FA',
                  },
                ]}
              >
                <Text style={[styles.summaryLabel, { color: theme.colors.textMuted }]}>TOPLAM GELIR</Text>
                <Text style={styles.summaryIncome}>{formatCurrency(totals.income, transactions[0]?.currency ?? 'TRY')}</Text>
              </View>

              <View
                style={[
                  styles.summaryCard,
                  {
                    backgroundColor: mode === 'dark' ? '#171F33' : '#FFFFFF',
                    borderColor: mode === 'dark' ? 'rgba(255,255,255,0.10)' : '#EAF0FA',
                  },
                ]}
              >
                <Text style={[styles.summaryLabel, { color: theme.colors.textMuted }]}>TOPLAM GIDER</Text>
                <Text style={styles.summaryExpense}>{formatCurrency(totals.expense, transactions[0]?.currency ?? 'TRY')}</Text>
              </View>
            </View>

            <View style={styles.quickActionsRow}>
              <Pressable
                accessibilityRole="button"
                onPress={() => navigation.navigate('ScanHome')}
                style={[
                  styles.quickActionButton,
                  {
                    backgroundColor: mode === 'dark' ? '#151E33' : '#EAF0FF',
                    borderColor: mode === 'dark' ? 'rgba(255,255,255,0.12)' : '#D4E2FF',
                  },
                ]}
              >
                <Text style={[styles.quickActionTitle, { color: theme.colors.primary }]}>Scan</Text>
                <Text style={[styles.quickActionSubtitle, { color: theme.colors.textMuted }]}>Receipt OCR flow</Text>
              </Pressable>

              <Pressable
                accessibilityRole="button"
                onPress={() => navigation.navigate('Groups')}
                style={[
                  styles.quickActionButton,
                  {
                    backgroundColor: mode === 'dark' ? '#141C2B' : '#EAF9F0',
                    borderColor: mode === 'dark' ? 'rgba(255,255,255,0.12)' : '#CDEBD8',
                  },
                ]}
              >
                <Text style={[styles.quickActionTitle, { color: theme.colors.income }]}>Split</Text>
                <Text style={[styles.quickActionSubtitle, { color: theme.colors.textMuted }]}>Groups & settle up</Text>
              </Pressable>
            </View>
          </View>
        }
        refreshControl={
          <RefreshControl
            onRefresh={() => {
              void transactionsQuery.refetch();
            }}
            refreshing={transactionsQuery.isRefetching && !transactionsQuery.isFetchingNextPage}
            tintColor={theme.colors.primary}
          />
        }
        renderItem={renderListItem}
        showsVerticalScrollIndicator={false}
      />
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    gap: 0,
    paddingBottom: 0,
    paddingHorizontal: 0,
    paddingTop: 0,
  },
  listContent: {
    paddingBottom: spacing.xl,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
  },
  headerWrap: {
    gap: spacing.sm,
    marginBottom: spacing.sm,
  },
  topBar: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  iconButton: {
    alignItems: 'center',
    borderRadius: radius.full,
    height: 36,
    justifyContent: 'center',
    width: 36,
  },
  iconButtonText: {
    ...typography.subheading,
    fontSize: 19,
    fontWeight: '700',
  },
  screenTitle: {
    ...typography.subheading,
    fontSize: 21,
    fontWeight: '700',
  },
  searchWrap: {
    alignItems: 'center',
    borderRadius: radius.md,
    flexDirection: 'row',
    gap: spacing.xs,
    height: 46,
    paddingHorizontal: spacing.sm,
  },
  searchIcon: {
    ...typography.subheading,
    fontSize: 14,
  },
  searchInput: {
    ...typography.body,
    flex: 1,
    fontSize: 14,
    lineHeight: 20,
    paddingVertical: 0,
  },
  filterChipRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  filterChip: {
    borderRadius: radius.full,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xs,
  },
  filterChipText: {
    ...typography.caption,
    fontWeight: '700',
  },
  filterApplyButton: {
    borderRadius: radius.full,
    borderWidth: 1,
    marginLeft: 'auto',
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.xs,
  },
  filterApplyText: {
    ...typography.caption,
    fontWeight: '700',
  },
  summaryRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  quickActionsRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  quickActionButton: {
    borderRadius: radius.md,
    borderWidth: 1,
    flex: 1,
    gap: 2,
    minHeight: 58,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  quickActionTitle: {
    ...typography.subheading,
    fontSize: 16,
    fontWeight: '700',
  },
  quickActionSubtitle: {
    ...typography.caption,
    fontSize: 11,
  },
  summaryCard: {
    borderRadius: radius.md,
    borderWidth: 1,
    flex: 1,
    paddingHorizontal: spacing.sm,
    paddingVertical: spacing.sm,
  },
  summaryLabel: {
    ...typography.caption,
    fontSize: 10,
    fontWeight: '700',
    letterSpacing: 0.6,
    marginBottom: spacing.xxs,
  },
  summaryIncome: {
    ...typography.subheading,
    color: '#17B26A',
    fontSize: 28,
    lineHeight: 34,
    fontWeight: '700',
  },
  summaryExpense: {
    ...typography.subheading,
    color: '#F04438',
    fontSize: 28,
    lineHeight: 34,
    fontWeight: '700',
  },
  groupHeader: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '700',
    letterSpacing: 1,
    marginTop: spacing.sm,
    textTransform: 'uppercase',
  },
  itemSeparator: {
    height: spacing.xs,
  },
  footerLoaderWrap: {
    alignItems: 'center',
    gap: spacing.xs,
    marginTop: spacing.md,
  },
  footerLoaderText: {
    ...typography.caption,
    fontSize: 12,
  },
  footerSpacer: {
    height: spacing.xl,
  },
  emptyText: {
    ...typography.body,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
  },
  errorText: {
    ...typography.body,
  },
  skeletonWrap: {
    gap: spacing.sm,
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
  },
  skeletonHeader: {
    borderRadius: radius.md,
    height: 30,
    width: '45%',
  },
  skeletonSearch: {
    borderRadius: radius.md,
    height: 46,
    width: '100%',
  },
  skeletonChips: {
    flexDirection: 'row',
    gap: spacing.xs,
  },
  skeletonChip: {
    borderRadius: radius.full,
    height: 34,
    width: 90,
  },
  skeletonSummaryRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  skeletonSummary: {
    borderRadius: radius.md,
    flex: 1,
    height: 84,
  },
  skeletonItem: {
    borderRadius: radius.md,
    height: 66,
    width: '100%',
  },
});
```

## FILE: apps/mobile/src/screens/finance/AddTransactionScreen.tsx
```
import { useEffect, useMemo, useRef } from 'react';
import {
  ActivityIndicator,
  Alert,
  Pressable,
  StyleSheet,
  Text,
  View,
} from 'react-native';

import { zodResolver } from '@hookform/resolvers/zod';
import { transactionCreateInputSchema, type TransactionType } from '@mintly/shared';
import { useNavigation, useRoute } from '@react-navigation/native';
import type { RouteProp } from '@react-navigation/native';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { Controller, useForm } from 'react-hook-form';
import { z } from 'zod';

import { useAuth } from '../../auth/AuthProvider';
import { apiClient } from '../../api/client';
import { financeQueryKeys } from '../../api/queryKeys';
import { Card, PrimaryButton, ScreenContainer, TextField } from '../../components/ui';
import type { RootTabParamList } from '../../navigation/types';
import { radius, spacing, typography, useTheme } from '../../theme';
import { apiErrorText } from '../../utils/apiErrorText';
import { monthFromIsoString } from '../../utils/month';

// stitch asset: stitch/export/stitch_ana_ekran_dashboard/grup_harcamas_ekle_(dark)/screen.png
// no touch/keyboard behavior changed by this PR.

const typeOptions: TransactionType[] = ['expense', 'income'];

const transactionFormSchema = z.object({
  type: z.enum(typeOptions),
  accountId: z.string().trim().min(1, 'Select an account'),
  categoryId: z.string().trim().min(1, 'Select a category'),
  amount: z
    .string()
    .trim()
    .min(1, 'Amount is required')
    .refine((value) => {
      const parsed = Number(value);
      return Number.isFinite(parsed) && parsed > 0;
    }, 'Amount must be a positive number'),
  description: z.string().trim().max(500).optional(),
  occurredAt: z
    .string()
    .trim()
    .min(1, 'Date/time is required')
    .refine((value) => !Number.isNaN(Date.parse(value)), 'Enter a valid ISO datetime'),
});

type TransactionFormValues = z.infer<typeof transactionFormSchema>;

export function AddTransactionScreen() {
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();
  const queryClient = useQueryClient();
  const route = useRoute<RouteProp<RootTabParamList, 'AddTab'>>();
  const navigation = useNavigation();
  const lastPrefillSignatureRef = useRef('');

  const accountsQuery = useQuery({
    queryKey: financeQueryKeys.accounts.list(),
    queryFn: () => withAuth((token) => apiClient.getAccounts(token)),
  });

  const categoriesQuery = useQuery({
    queryKey: financeQueryKeys.categories.list(),
    queryFn: () => withAuth((token) => apiClient.getCategories(token)),
  });

  const form = useForm<TransactionFormValues>({
    resolver: zodResolver(transactionFormSchema),
    defaultValues: {
      type: 'expense',
      accountId: '',
      categoryId: '',
      amount: '',
      description: '',
      occurredAt: new Date().toISOString(),
    },
  });

  const selectedType = form.watch('type');
  const selectedAccountId = form.watch('accountId');
  const selectedCategoryId = form.watch('categoryId');

  const selectedAccount = useMemo(
    () => accountsQuery.data?.accounts.find((account) => account.id === selectedAccountId) ?? null,
    [accountsQuery.data?.accounts, selectedAccountId],
  );

  const filteredCategories = useMemo(
    () => categoriesQuery.data?.categories.filter((category) => category.type === selectedType) ?? [],
    [categoriesQuery.data?.categories, selectedType],
  );

  useEffect(() => {
    if (!selectedCategoryId) {
      return;
    }

    const exists = filteredCategories.some((category) => category.id === selectedCategoryId);
    if (!exists) {
      form.setValue('categoryId', '');
    }
  }, [filteredCategories, form, selectedCategoryId]);

  useEffect(() => {
    const prefill = route.params?.prefill;
    if (!prefill) {
      return;
    }

    const signature = `${prefill.amount ?? ''}|${prefill.description ?? ''}|${prefill.occurredAt ?? ''}`;
    if (lastPrefillSignatureRef.current === signature) {
      return;
    }

    if (prefill.amount) {
      form.setValue('amount', prefill.amount, { shouldValidate: true });
    }
    if (prefill.description) {
      form.setValue('description', prefill.description);
    }
    if (prefill.occurredAt) {
      form.setValue('occurredAt', prefill.occurredAt, { shouldValidate: true });
    }

    lastPrefillSignatureRef.current = signature;
    (navigation as { setParams?: (params: RootTabParamList['AddTab']) => void }).setParams?.({
      prefill: undefined,
    });
  }, [form, navigation, route.params?.prefill]);

  const createTransactionMutation = useMutation({
    mutationFn: (values: TransactionFormValues) => {
      const amount = Number(values.amount);
      const occurredAt = new Date(values.occurredAt).toISOString();

      return withAuth((token) =>
        apiClient.createTransaction(
          transactionCreateInputSchema.parse({
            type: values.type,
            accountId: values.accountId,
            categoryId: values.categoryId,
            amount,
            currency: selectedAccount?.currency ?? 'USD',
            description: values.description?.trim() || undefined,
            occurredAt,
          }),
          token,
        ),
      );
    },
    onSuccess: async (_, values) => {
      const transactionMonth = monthFromIsoString(values.occurredAt);

      await Promise.all([
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.transactions.all() }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.budgets.month(transactionMonth) }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.analytics.month(transactionMonth) }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.dashboard.recent() }),
      ]);

      form.reset({
        type: 'expense',
        accountId: '',
        categoryId: '',
        amount: '',
        description: '',
        occurredAt: new Date().toISOString(),
      });

      Alert.alert('Transaction created', 'The transaction was saved successfully.');
    },
    onError: (error) => {
      Alert.alert('Create transaction failed', apiErrorText(error));
    },
  });

  if (accountsQuery.isLoading || categoriesQuery.isLoading) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.stateCard}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={[styles.stateText, { color: theme.colors.textMuted }]}>Loading add transaction form...</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (accountsQuery.isError || categoriesQuery.isError) {
    const error = accountsQuery.error ?? categoriesQuery.error;

    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.errorCard}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>Could not load transaction form</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(error)}</Text>
          <PrimaryButton
            label="Retry"
            onPress={() => {
              void accountsQuery.refetch();
              void categoriesQuery.refetch();
            }}
          />
        </Card>
      </ScreenContainer>
    );
  }

  const dark = mode === 'dark';
  const accounts = accountsQuery.data?.accounts ?? [];
  const panelBg = dark ? '#121826' : theme.colors.surface;
  const panelBorder = dark ? '#27344F' : theme.colors.border;

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.container}>
        <Card
          dark={dark}
          style={[
            styles.heroCard,
            {
              backgroundColor: panelBg,
              borderColor: panelBorder,
            },
          ]}
        >
          <Text style={[styles.heroTitle, { color: theme.colors.text }]}>Add Transaction</Text>
          <Text style={[styles.heroSubtitle, { color: theme.colors.textMuted }]}>Create a new income or expense record.</Text>

          <View style={styles.segmentWrap}>
            <Controller
              control={form.control}
              name="type"
              render={({ field: { value, onChange } }) => (
                <View style={[styles.segment, { backgroundColor: dark ? '#0E1523' : '#EEF3FB' }]}>
                  {typeOptions.map((option) => {
                    const active = option === value;
                    const tone = option === 'income' ? '#17B26A' : '#F04438';

                    return (
                      <Pressable
                        key={option}
                        accessibilityRole="button"
                        onPress={() => onChange(option)}
                        style={[
                          styles.segmentButton,
                          active
                            ? {
                                backgroundColor: dark ? '#1A2336' : '#FFFFFF',
                                borderColor: tone,
                              }
                            : null,
                        ]}
                      >
                        <Text
                          style={[
                            styles.segmentButtonText,
                            { color: active ? tone : theme.colors.textMuted },
                          ]}
                        >
                          {option === 'income' ? 'Income' : 'Expense'}
                        </Text>
                      </Pressable>
                    );
                  })}
                </View>
              )}
            />
          </View>
        </Card>

        <Card
          dark={dark}
          style={[
            styles.formCard,
            {
              backgroundColor: panelBg,
              borderColor: panelBorder,
            },
          ]}
        >
          <View style={styles.sectionHead}>
            <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>Transaction Details</Text>
            <Text style={[styles.sectionSubtitle, { color: theme.colors.textMuted }]}>Step 1 of 1</Text>
          </View>

          <Text style={[styles.fieldLabel, { color: theme.colors.labelMuted }]}>Account</Text>
          <Controller
            control={form.control}
            name="accountId"
            render={({ field: { value, onChange } }) => (
              <View style={styles.choiceWrap}>
                {accounts.map((account) => {
                  const selected = value === account.id;

                  return (
                    <Pressable
                      key={account.id}
                      accessibilityRole="button"
                      onPress={() => onChange(account.id)}
                      style={[
                        styles.choiceChip,
                        {
                          borderColor: selected ? theme.colors.primary : panelBorder,
                          backgroundColor: selected
                            ? dark
                              ? 'rgba(47, 107, 255, 0.20)'
                              : '#EAF0FF'
                            : dark
                              ? '#0E1523'
                              : '#F8FBFF',
                        },
                      ]}
                    >
                      <Text
                        style={[
                          styles.choiceChipLabel,
                          { color: selected ? theme.colors.primary : theme.colors.textMuted },
                        ]}
                      >
                        {account.name}
                      </Text>
                    </Pressable>
                  );
                })}
              </View>
            )}
          />
          {form.formState.errors.accountId ? (
            <Text style={[styles.inlineError, { color: theme.colors.expense }]}>{form.formState.errors.accountId.message}</Text>
          ) : null}

          <Text style={[styles.fieldLabel, { color: theme.colors.labelMuted }]}>Category</Text>
          <Controller
            control={form.control}
            name="categoryId"
            render={({ field: { value, onChange } }) => (
              <View style={styles.choiceWrap}>
                {filteredCategories.map((category) => {
                  const selected = value === category.id;

                  return (
                    <Pressable
                      key={category.id}
                      accessibilityRole="button"
                      onPress={() => onChange(category.id)}
                      style={[
                        styles.choiceChip,
                        {
                          borderColor: selected ? theme.colors.primary : panelBorder,
                          backgroundColor: selected
                            ? dark
                              ? 'rgba(47, 107, 255, 0.20)'
                              : '#EAF0FF'
                            : dark
                              ? '#0E1523'
                              : '#F8FBFF',
                        },
                      ]}
                    >
                      <Text
                        style={[
                          styles.choiceChipLabel,
                          { color: selected ? theme.colors.primary : theme.colors.textMuted },
                        ]}
                      >
                        {category.name}
                      </Text>
                    </Pressable>
                  );
                })}
              </View>
            )}
          />
          {form.formState.errors.categoryId ? (
            <Text style={[styles.inlineError, { color: theme.colors.expense }]}>{form.formState.errors.categoryId.message}</Text>
          ) : null}

          <Controller
            control={form.control}
            name="amount"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextField
                autoCapitalize="none"
                error={form.formState.errors.amount?.message}
                keyboardType="decimal-pad"
                label="Amount"
                leftAdornment={
                  <Text style={[styles.adornmentText, { color: theme.colors.textMuted }]}></Text>
                }
                onBlur={onBlur}
                onChangeText={onChange}
                placeholder="0.00"
                value={value}
              />
            )}
          />

          <Controller
            control={form.control}
            name="description"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextField
                autoCapitalize="sentences"
                label="Description"
                onBlur={onBlur}
                onChangeText={onChange}
                placeholder="Optional note"
                value={value ?? ''}
              />
            )}
          />

          <Controller
            control={form.control}
            name="occurredAt"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextField
                autoCapitalize="none"
                error={form.formState.errors.occurredAt?.message}
                label="Date & Time (ISO)"
                labelRight={
                  <Pressable
                    accessibilityRole="button"
                    onPress={() => onChange(new Date().toISOString())}
                    style={styles.nowButton}
                  >
                    <Text style={[styles.nowButtonText, { color: theme.colors.primary }]}>Now</Text>
                  </Pressable>
                }
                onBlur={onBlur}
                onChangeText={onChange}
                placeholder="2026-02-17T10:30:00.000Z"
                value={value}
              />
            )}
          />

          <View
            style={[
              styles.currencyRow,
              {
                borderColor: panelBorder,
                backgroundColor: dark ? '#0E1523' : '#F8FBFF',
              },
            ]}
          >
            <Text style={[styles.currencyLabel, { color: theme.colors.textMuted }]}>Currency</Text>
            <Text style={[styles.currencyValue, { color: theme.colors.text }]}> 
              {selectedAccount?.currency ?? 'Select account first'}
            </Text>
          </View>

          <PrimaryButton
            disabled={createTransactionMutation.isPending}
            label={createTransactionMutation.isPending ? 'Saving...' : 'Save Transaction'}
            onPress={form.handleSubmit((values) => {
              createTransactionMutation.mutate(values);
            })}
          />
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  heroCard: {
    gap: spacing.sm,
  },
  heroTitle: {
    ...typography.heading,
    fontSize: 22,
    fontWeight: '700',
  },
  heroSubtitle: {
    ...typography.body,
    fontSize: 14,
  },
  segmentWrap: {
    marginTop: spacing.xxs,
  },
  segment: {
    borderRadius: radius.full,
    flexDirection: 'row',
    gap: spacing.xs,
    padding: spacing.xxs,
  },
  segmentButton: {
    alignItems: 'center',
    borderRadius: radius.full,
    borderWidth: 1,
    borderColor: 'transparent',
    flex: 1,
    minHeight: 38,
    justifyContent: 'center',
    paddingHorizontal: spacing.sm,
  },
  segmentButtonText: {
    ...typography.caption,
    fontWeight: '700',
  },
  formCard: {
    gap: spacing.sm,
  },
  sectionHead: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  sectionTitle: {
    ...typography.subheading,
    fontSize: 17,
    fontWeight: '700',
  },
  sectionSubtitle: {
    ...typography.caption,
    fontSize: 11,
    fontWeight: '600',
    letterSpacing: 0.3,
  },
  fieldLabel: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
  },
  choiceWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  choiceChip: {
    borderRadius: radius.full,
    borderWidth: 1,
    minHeight: 34,
    justifyContent: 'center',
    paddingHorizontal: spacing.sm,
  },
  choiceChipLabel: {
    ...typography.caption,
    fontWeight: '700',
  },
  inlineError: {
    ...typography.caption,
    fontSize: 12,
  },
  adornmentText: {
    ...typography.subheading,
    fontSize: 16,
    fontWeight: '700',
  },
  nowButton: {
    paddingHorizontal: spacing.xxs,
    paddingVertical: 2,
  },
  nowButtonText: {
    ...typography.caption,
    fontWeight: '700',
  },
  currencyRow: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
    minHeight: 44,
    paddingHorizontal: spacing.sm,
  },
  currencyLabel: {
    ...typography.caption,
    fontSize: 12,
  },
  currencyValue: {
    ...typography.caption,
    fontWeight: '700',
  },
  stateCard: {
    alignItems: 'center',
    gap: spacing.sm,
    justifyContent: 'center',
    minHeight: 160,
  },
  stateText: {
    ...typography.body,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
  },
  errorText: {
    ...typography.caption,
  },
});
```

## FILE: apps/mobile/src/screens/scan/ScanHomeScreen.tsx
```
import { Pressable, StyleSheet, Text, View } from 'react-native';

import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';

import { Card, PrimaryButton, ScreenContainer } from '../../components/ui';
import type { TransactionsStackParamList } from '../../navigation/stacks/TransactionsStack';
import { radius, spacing, typography, useTheme } from '../../theme';

export function ScanHomeScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const { theme, mode } = useTheme();
  const dark = mode === 'dark';

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.container}>
        <Card dark={dark} style={styles.heroCard}>
          <View style={[styles.heroIconWrap, { backgroundColor: theme.colors.primaryMuted }]}> 
            <Text style={styles.heroIcon}></Text>
          </View>
          <Text style={[styles.title, { color: theme.colors.text }]}>Scan Receipt</Text>
          <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}> 
            Capture a bill photo and prefill transaction details in seconds.
          </Text>

          <View style={styles.stepsWrap}>
            <View style={styles.stepRow}>
              <View style={[styles.stepDot, { backgroundColor: theme.colors.primary }]} />
              <Text style={[styles.stepText, { color: theme.colors.textMuted }]}>Capture receipt image</Text>
            </View>
            <View style={styles.stepRow}>
              <View style={[styles.stepDot, { backgroundColor: theme.colors.primary }]} />
              <Text style={[styles.stepText, { color: theme.colors.textMuted }]}>Review extracted fields</Text>
            </View>
            <View style={styles.stepRow}>
              <View style={[styles.stepDot, { backgroundColor: theme.colors.primary }]} />
              <Text style={[styles.stepText, { color: theme.colors.textMuted }]}>Create transaction with prefill</Text>
            </View>
          </View>

          <PrimaryButton
            label="Scan receipt"
            onPress={() => navigation.navigate('ScanCamera')}
          />
        </Card>

        <Pressable
          accessibilityRole="button"
          onPress={() => navigation.navigate('Transactions')}
          style={styles.backButton}
        >
          <Text style={[styles.backLabel, { color: theme.colors.primary }]}>Back to transactions</Text>
        </Pressable>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  heroCard: {
    gap: spacing.sm,
  },
  heroIconWrap: {
    alignItems: 'center',
    alignSelf: 'center',
    borderRadius: radius.full,
    height: 64,
    justifyContent: 'center',
    width: 64,
  },
  heroIcon: {
    ...typography.heading,
    color: '#FFFFFF',
    fontSize: 26,
    lineHeight: 30,
  },
  title: {
    ...typography.heading,
    fontSize: 26,
    textAlign: 'center',
  },
  subtitle: {
    ...typography.body,
    textAlign: 'center',
  },
  stepsWrap: {
    gap: spacing.xs,
  },
  stepRow: {
    alignItems: 'center',
    flexDirection: 'row',
    gap: spacing.xs,
  },
  stepDot: {
    borderRadius: radius.full,
    height: 8,
    width: 8,
  },
  stepText: {
    ...typography.body,
    flex: 1,
  },
  backButton: {
    alignItems: 'center',
    paddingVertical: spacing.xs,
  },
  backLabel: {
    ...typography.caption,
    fontSize: 13,
    fontWeight: '700',
  },
});
```

## FILE: apps/mobile/src/screens/scan/ScanCameraScreen.tsx
```
import { useRef, useState } from 'react';
import { ActivityIndicator, Pressable, StyleSheet, Text, View } from 'react-native';

import { CameraView, useCameraPermissions } from 'expo-camera';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';

import { Card, ScreenContainer } from '../../components/ui';
import type { TransactionsStackParamList } from '../../navigation/stacks/TransactionsStack';
import { radius, spacing, typography, useTheme } from '../../theme';

export function ScanCameraScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const { theme, mode } = useTheme();
  const [permission, requestPermission] = useCameraPermissions();
  const [isCapturing, setIsCapturing] = useState(false);
  const cameraRef = useRef<CameraView | null>(null);

  const dark = mode === 'dark';

  const permissionGranted = permission?.granted ?? false;

  async function handleCapture() {
    if (!cameraRef.current || isCapturing) {
      return;
    }

    setIsCapturing(true);
    try {
      const photo = await cameraRef.current.takePictureAsync({ quality: 0.6 });
      if (!photo?.uri) {
        return;
      }

      navigation.navigate('ScanReview', { photoUri: photo.uri });
    } finally {
      setIsCapturing(false);
    }
  }

  if (!permission) {
    return (
      <ScreenContainer dark={dark}>
        <Card dark={dark} style={styles.stateCard}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={[styles.stateText, { color: theme.colors.textMuted }]}>Preparing camera...</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (!permissionGranted) {
    return (
      <ScreenContainer dark={dark}>
        <Card dark={dark} style={styles.permissionCard}>
          <Text style={[styles.permissionTitle, { color: theme.colors.text }]}>Camera access needed</Text>
          <Text style={[styles.permissionText, { color: theme.colors.textMuted }]}> 
            Allow camera permission to scan receipts.
          </Text>

          <Pressable
            accessibilityRole="button"
            onPress={() => {
              void requestPermission();
            }}
            style={[styles.primaryAction, { backgroundColor: theme.colors.primary }]}
          >
            <Text style={styles.primaryActionLabel}>Allow camera</Text>
          </Pressable>
        </Card>
      </ScreenContainer>
    );
  }

  return (
    <ScreenContainer dark={dark} contentStyle={styles.containerContent} scrollable={false}>
      <View style={styles.container}>
        <View style={[styles.cameraWrap, { borderColor: theme.colors.border }]}> 
          <CameraView
            ref={cameraRef}
            style={StyleSheet.absoluteFill}
            facing="back"
            mode="picture"
          />
        </View>

        <View style={styles.footerActions}>
          <Pressable
            accessibilityRole="button"
            onPress={() => navigation.goBack()}
            style={[styles.secondaryAction, { borderColor: theme.colors.border }]}
          >
            <Text style={[styles.secondaryActionLabel, { color: theme.colors.textMuted }]}>Cancel</Text>
          </Pressable>

          <Pressable
            accessibilityRole="button"
            onPress={() => {
              void handleCapture();
            }}
            style={[styles.captureAction, { backgroundColor: theme.colors.primary }]}
          >
            {isCapturing ? (
              <ActivityIndicator color="#FFFFFF" size="small" />
            ) : (
              <Text style={styles.captureActionLabel}>Capture</Text>
            )}
          </Pressable>
        </View>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    gap: 0,
    paddingBottom: spacing.md,
  },
  container: {
    flex: 1,
    gap: spacing.sm,
  },
  cameraWrap: {
    borderRadius: radius.xl,
    borderWidth: 1,
    flex: 1,
    overflow: 'hidden',
  },
  footerActions: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  primaryAction: {
    alignItems: 'center',
    borderRadius: radius.md,
    height: 48,
    justifyContent: 'center',
    paddingHorizontal: spacing.lg,
  },
  primaryActionLabel: {
    ...typography.subheading,
    color: '#FFFFFF',
    fontWeight: '700',
  },
  secondaryAction: {
    alignItems: 'center',
    borderRadius: radius.md,
    borderWidth: 1,
    flex: 1,
    height: 48,
    justifyContent: 'center',
    paddingHorizontal: spacing.lg,
  },
  secondaryActionLabel: {
    ...typography.subheading,
    fontWeight: '700',
  },
  captureAction: {
    alignItems: 'center',
    borderRadius: radius.md,
    flex: 2,
    height: 48,
    justifyContent: 'center',
    paddingHorizontal: spacing.lg,
  },
  captureActionLabel: {
    ...typography.subheading,
    color: '#FFFFFF',
    fontWeight: '700',
  },
  stateCard: {
    alignItems: 'center',
    gap: spacing.sm,
    justifyContent: 'center',
    minHeight: 160,
  },
  stateText: {
    ...typography.body,
  },
  permissionCard: {
    gap: spacing.sm,
  },
  permissionTitle: {
    ...typography.heading,
    fontSize: 24,
  },
  permissionText: {
    ...typography.body,
  },
});
```

## FILE: apps/mobile/src/screens/scan/ScanReviewScreen.tsx
```
import { useEffect, useMemo, useState } from 'react';
import { Alert, Image, Pressable, StyleSheet, Text, View } from 'react-native';

import { useNavigation, useRoute } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import type { RouteProp } from '@react-navigation/native';

import { Card, PrimaryButton, ScreenContainer, TextField } from '../../components/ui';
import type { RootTabParamList } from '../../navigation/types';
import type { TransactionsStackParamList } from '../../navigation/stacks/TransactionsStack';
import { radius, spacing, typography, useTheme } from '../../theme';

function stableHash(value: string): number {
  let hash = 0;
  for (let i = 0; i < value.length; i += 1) {
    hash = (hash * 31 + value.charCodeAt(i)) >>> 0;
  }
  return hash;
}

function toDateOnly(value: Date): string {
  const year = value.getUTCFullYear();
  const month = String(value.getUTCMonth() + 1).padStart(2, '0');
  const day = String(value.getUTCDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function buildMockExtraction(uri: string) {
  const hash = stableHash(uri);
  const amount = ((hash % 15000) / 100 + 50).toFixed(2);
  const daysBack = hash % 11;
  const date = new Date();
  date.setUTCDate(date.getUTCDate() - daysBack);

  const merchants = ['Migros', 'Starbucks', 'Carrefour', 'Shell', 'Getir', 'LC Waikiki'];
  const merchantName = merchants[hash % merchants.length] ?? 'Market';

  return {
    merchantName,
    amount,
    date: toDateOnly(date),
  };
}

export function ScanReviewScreen() {
  const { theme, mode } = useTheme();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const route = useRoute<RouteProp<TransactionsStackParamList, 'ScanReview'>>();

  const dark = mode === 'dark';

  const initialMock = useMemo(() => buildMockExtraction(route.params.photoUri), [route.params.photoUri]);

  const [merchantName, setMerchantName] = useState(initialMock.merchantName);
  const [amount, setAmount] = useState(initialMock.amount);
  const [receiptDate, setReceiptDate] = useState(initialMock.date);

  useEffect(() => {
    setMerchantName(initialMock.merchantName);
    setAmount(initialMock.amount);
    setReceiptDate(initialMock.date);
  }, [initialMock]);

  function handleCreateTransaction() {
    const parsedAmount = Number(amount);
    const occurredAt = new Date(`${receiptDate}T12:00:00.000Z`);

    if (!Number.isFinite(parsedAmount) || parsedAmount <= 0) {
      Alert.alert('Invalid amount', 'Please enter a positive amount.');
      return;
    }

    if (Number.isNaN(occurredAt.getTime())) {
      Alert.alert('Invalid date', 'Please enter a valid date (YYYY-MM-DD).');
      return;
    }

    const parent = navigation.getParent();
    if (!parent) {
      Alert.alert('Navigation error', 'Could not open Add Transaction screen.');
      return;
    }

    const params: RootTabParamList['AddTab'] = {
      prefill: {
        amount: parsedAmount.toFixed(2),
        description: merchantName.trim() || 'Receipt transaction',
        occurredAt: occurredAt.toISOString(),
      },
    };

    (parent as { navigate: (routeName: keyof RootTabParamList, params?: RootTabParamList['AddTab']) => void }).navigate(
      'AddTab',
      params,
    );
  }

  return (
    <ScreenContainer dark={dark}>
      <View style={styles.container}>
        <Card dark={dark} style={styles.previewCard}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>Receipt Preview</Text>
          <Image source={{ uri: route.params.photoUri }} style={styles.previewImage} />
        </Card>

        <Card dark={dark} style={styles.formCard}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>Extracted Fields (Mock)</Text>

          <TextField
            label="Merchant"
            value={merchantName}
            onChangeText={setMerchantName}
            placeholder="Merchant name"
            autoCapitalize="words"
          />

          <TextField
            label="Amount"
            value={amount}
            onChangeText={setAmount}
            placeholder="0.00"
            keyboardType="decimal-pad"
          />

          <TextField
            label="Date"
            value={receiptDate}
            onChangeText={setReceiptDate}
            placeholder="YYYY-MM-DD"
            autoCapitalize="none"
          />

          <PrimaryButton label="Create transaction" onPress={handleCreateTransaction} />

          <Pressable
            accessibilityRole="button"
            onPress={() => navigation.navigate('ScanCamera')}
            style={styles.retakeButton}
          >
            <Text style={[styles.retakeLabel, { color: theme.colors.primary }]}>Retake photo</Text>
          </Pressable>
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  previewCard: {
    gap: spacing.xs,
  },
  formCard: {
    gap: spacing.sm,
  },
  sectionTitle: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  previewImage: {
    borderRadius: radius.md,
    height: 220,
    width: '100%',
  },
  retakeButton: {
    alignItems: 'center',
    paddingVertical: spacing.xs,
  },
  retakeLabel: {
    ...typography.caption,
    fontSize: 13,
    fontWeight: '700',
  },
});
```

## FILE: apps/mobile/src/screens/split/GroupsScreen.tsx
```
import { FlatList, Pressable, StyleSheet, Text, View } from 'react-native';

import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useQuery } from '@tanstack/react-query';

import { apiClient } from '../../api/client';
import { financeQueryKeys } from '../../api/queryKeys';
import { useAuth } from '../../auth/AuthProvider';
import { Card, Chip, PrimaryButton, ScreenContainer } from '../../components/ui';
import type { TransactionsStackParamList } from '../../navigation/stacks/TransactionsStack';
import { spacing, typography, useTheme } from '../../theme';
import { apiErrorText } from '../../utils/apiErrorText';

export function GroupsScreen() {
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();

  const groupsQuery = useQuery({
    queryKey: financeQueryKeys.groups.list(),
    queryFn: () => withAuth((token) => apiClient.getGroups(token)),
  });

  const groups = groupsQuery.data?.groups ?? [];

  if (groupsQuery.isLoading) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'}>
          <Text style={[styles.helperText, { color: theme.colors.textMuted }]}>Loading groups...</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (groupsQuery.isError) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.errorCard}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>Could not load groups</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(groupsQuery.error)}</Text>
          <PrimaryButton label="Retry" onPress={() => void groupsQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  return (
    <ScreenContainer dark={mode === 'dark'} scrollable={false} contentStyle={styles.containerContent}>
      <FlatList
        contentContainerStyle={styles.content}
        data={groups}
        keyExtractor={(item) => item.id}
        ListHeaderComponent={
          <View style={styles.header}>
            <Text style={[styles.title, { color: theme.colors.text }]}>Split Groups</Text>
            <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}>Manage shared expenses with friends.</Text>
            <PrimaryButton label="Create group" onPress={() => navigation.navigate('CreateGroup')} />
          </View>
        }
        ListEmptyComponent={
          <Card dark={mode === 'dark'}>
            <Text style={[styles.helperText, { color: theme.colors.textMuted }]}>No groups yet. Create your first split group.</Text>
          </Card>
        }
        ItemSeparatorComponent={() => <View style={styles.separator} />}
        renderItem={({ item }) => (
          <Pressable
            accessibilityRole="button"
            onPress={() => navigation.navigate('GroupDetail', { groupId: item.id })}
          >
            <Card dark={mode === 'dark'} style={styles.groupCard}>
              <Text style={[styles.groupName, { color: theme.colors.text }]}>{item.name}</Text>
              <View style={styles.memberRow}>
                {item.members.slice(0, 4).map((member) => (
                  <Chip key={member.id} label={member.name} dark={mode === 'dark'} />
                ))}
              </View>
              <Text style={[styles.memberCount, { color: theme.colors.textMuted }]}> 
                {item.members.length} member{item.members.length === 1 ? '' : 's'}
              </Text>
            </Card>
          </Pressable>
        )}
        showsVerticalScrollIndicator={false}
      />
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    gap: 0,
    paddingBottom: 0,
    paddingHorizontal: 0,
    paddingTop: 0,
  },
  content: {
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
    paddingBottom: spacing.xl,
  },
  header: {
    gap: spacing.sm,
    marginBottom: spacing.sm,
  },
  title: {
    ...typography.heading,
    fontSize: 24,
  },
  subtitle: {
    ...typography.body,
  },
  groupCard: {
    gap: spacing.xs,
  },
  groupName: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  memberRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  memberCount: {
    ...typography.caption,
    fontSize: 12,
  },
  separator: {
    height: spacing.sm,
  },
  helperText: {
    ...typography.body,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
    fontWeight: '700',
  },
  errorText: {
    ...typography.body,
  },
});
```

## FILE: apps/mobile/src/screens/split/CreateGroupScreen.tsx
```
import { useMemo } from 'react';
import { Alert, StyleSheet, Text, View } from 'react-native';

import { zodResolver } from '@hookform/resolvers/zod';
import { useNavigation } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { Controller, useForm } from 'react-hook-form';
import { z } from 'zod';

import { apiClient } from '../../api/client';
import { financeQueryKeys } from '../../api/queryKeys';
import { useAuth } from '../../auth/AuthProvider';
import { Card, PrimaryButton, ScreenContainer, TextField } from '../../components/ui';
import type { TransactionsStackParamList } from '../../navigation/stacks/TransactionsStack';
import { spacing, typography, useTheme } from '../../theme';
import { apiErrorText } from '../../utils/apiErrorText';

const formSchema = z.object({
  name: z.string().trim().min(1, 'Group name is required').max(120),
  members: z.string().trim().optional(),
});

type FormValues = z.infer<typeof formSchema>;

function parseMembers(value: string) {
  return value
    .split('\n')
    .map((line) => line.trim())
    .filter(Boolean)
    .map((line) => {
      const parts = line.split(',').map((part) => part.trim()).filter(Boolean);

      if (parts.length >= 2) {
        return { name: parts[0], email: parts[1] };
      }

      const email = parts[0] ?? '';
      const name = email.includes('@') ? email.split('@')[0] : email;
      return { name, email };
    })
    .filter((member) => member.name.length > 0 && member.email.length > 0);
}

export function CreateGroupScreen() {
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const queryClient = useQueryClient();
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      members: '',
    },
  });

  const membersValue = form.watch('members') ?? '';
  const membersPreview = useMemo(() => parseMembers(membersValue), [membersValue]);

  const createMutation = useMutation({
    mutationFn: (values: FormValues) =>
      withAuth((token) =>
        apiClient.createGroup(
          {
            name: values.name,
            members: parseMembers(values.members ?? ''),
          },
          token,
        ),
      ),
    onSuccess: async (createdGroup) => {
      await queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.all() });
      navigation.replace('GroupDetail', { groupId: createdGroup.id });
    },
    onError: (error) => {
      Alert.alert('Create group failed', apiErrorText(error));
    },
  });

  return (
    <ScreenContainer dark={mode === 'dark'}>
      <View style={styles.container}>
        <Card dark={mode === 'dark'} style={styles.card}>
          <Text style={[styles.title, { color: theme.colors.text }]}>Create Group</Text>
          <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}> 
            Add members line by line. Use format: Name,email
          </Text>

          <Controller
            control={form.control}
            name="name"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextField
                label="Group Name"
                value={value}
                onBlur={onBlur}
                onChangeText={onChange}
                placeholder="Weekend Trip"
                error={form.formState.errors.name?.message}
              />
            )}
          />

          <Controller
            control={form.control}
            name="members"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextField
                label="Members"
                value={value ?? ''}
                onBlur={onBlur}
                onChangeText={onChange}
                placeholder={'Ali,ali@example.com\nAyse,ayse@example.com'}
                autoCapitalize="none"
                inputStyle={styles.membersInput}
                inputWrapStyle={styles.membersInputWrap}
              />
            )}
          />

          {membersPreview.length > 0 ? (
            <Text style={[styles.previewText, { color: theme.colors.textMuted }]}> 
              {membersPreview.length} member{membersPreview.length === 1 ? '' : 's'} will be added.
            </Text>
          ) : null}

          <PrimaryButton
            disabled={createMutation.isPending}
            label={createMutation.isPending ? 'Creating...' : 'Create group'}
            onPress={form.handleSubmit((values) => createMutation.mutate(values))}
          />
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  card: {
    gap: spacing.sm,
  },
  title: {
    ...typography.heading,
    fontSize: 24,
  },
  subtitle: {
    ...typography.body,
  },
  membersInputWrap: {
    height: 120,
    alignItems: 'stretch',
  },
  membersInput: {
    paddingTop: spacing.sm,
    paddingBottom: spacing.sm,
    minHeight: 100,
    textAlignVertical: 'top',
  },
  previewText: {
    ...typography.caption,
  },
});
```

## FILE: apps/mobile/src/screens/split/GroupDetailScreen.tsx
```
import { useMemo } from 'react';
import { ActivityIndicator, FlatList, Pressable, StyleSheet, Text, View } from 'react-native';

import type { GroupExpense } from '@mintly/shared';
import { useNavigation, useRoute } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import type { RouteProp } from '@react-navigation/native';
import { useQuery } from '@tanstack/react-query';

import { apiClient } from '../../api/client';
import { financeQueryKeys } from '../../api/queryKeys';
import { useAuth } from '../../auth/AuthProvider';
import { Card, Chip, PrimaryButton, ScreenContainer } from '../../components/ui';
import type { TransactionsStackParamList } from '../../navigation/stacks/TransactionsStack';
import { spacing, typography, useTheme } from '../../theme';
import { apiErrorText } from '../../utils/apiErrorText';

function buildBalanceMap(expenses: GroupExpense[]) {
  const map = new Map<string, number>();

  for (const expense of expenses) {
    map.set(expense.paidByMemberId, (map.get(expense.paidByMemberId) ?? 0) + expense.amount);

    for (const split of expense.splits) {
      map.set(split.memberId, (map.get(split.memberId) ?? 0) - split.amount);
    }
  }

  return map;
}

function formatMoney(amount: number, currency: string): string {
  return new Intl.NumberFormat('tr-TR', {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

export function GroupDetailScreen() {
  const route = useRoute<RouteProp<TransactionsStackParamList, 'GroupDetail'>>();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();

  const groupQuery = useQuery({
    queryKey: financeQueryKeys.groups.detail(route.params.groupId),
    queryFn: () => withAuth((token) => apiClient.getGroup(route.params.groupId, token)),
  });

  const expensesQuery = useQuery({
    queryKey: financeQueryKeys.groups.expenses(route.params.groupId),
    queryFn: () => withAuth((token) => apiClient.getGroupExpenses(route.params.groupId, token)),
  });

  if (groupQuery.isLoading || expensesQuery.isLoading) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.loadingCard}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
          <Text style={[styles.helperText, { color: theme.colors.textMuted }]}>Loading group...</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (groupQuery.isError || expensesQuery.isError || !groupQuery.data || !expensesQuery.data) {
    const error = groupQuery.error ?? expensesQuery.error;

    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.errorCard}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>Could not load group details</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(error)}</Text>
          <PrimaryButton
            label="Retry"
            onPress={() => {
              void groupQuery.refetch();
              void expensesQuery.refetch();
            }}
          />
        </Card>
      </ScreenContainer>
    );
  }

  const group = groupQuery.data;
  const expenses = expensesQuery.data.expenses;
  const balanceMap = buildBalanceMap(expenses);

  const currency = expenses[0]?.currency ?? 'TRY';

  const balanceRows = useMemo(
    () =>
      group.members.map((member) => ({
        member,
        balance: balanceMap.get(member.id) ?? 0,
      })),
    [group.members, balanceMap],
  );

  return (
    <ScreenContainer dark={mode === 'dark'} scrollable={false} contentStyle={styles.containerContent}>
      <FlatList
        contentContainerStyle={styles.content}
        data={expenses}
        keyExtractor={(item) => item.id}
        ListHeaderComponent={
          <View style={styles.headerWrap}>
            <Card dark={mode === 'dark'} style={styles.heroCard}>
              <Text style={[styles.groupTitle, { color: theme.colors.text }]}>{group.name}</Text>
              <View style={styles.memberWrap}>
                {group.members.map((member) => (
                  <Chip key={member.id} label={member.name} dark={mode === 'dark'} />
                ))}
              </View>
            </Card>

            <Card dark={mode === 'dark'} style={styles.balanceCard}>
              <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>Balances</Text>
              {balanceRows.map((row) => (
                <View key={row.member.id} style={styles.balanceRow}>
                  <Text style={[styles.balanceName, { color: theme.colors.text }]}>{row.member.name}</Text>
                  <Text
                    style={[
                      styles.balanceValue,
                      { color: row.balance >= 0 ? theme.colors.income : theme.colors.expense },
                    ]}
                  >
                    {row.balance >= 0 ? '+' : '-'}
                    {formatMoney(Math.abs(row.balance), currency)}
                  </Text>
                </View>
              ))}
            </Card>

            <View style={styles.actionRow}>
              <PrimaryButton
                label="Add expense"
                onPress={() => navigation.navigate('AddGroupExpense', { groupId: group.id })}
              />
              <PrimaryButton
                label="Settle up"
                onPress={() => navigation.navigate('SettleUp', { groupId: group.id })}
              />
            </View>

            <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>Expenses</Text>
          </View>
        }
        ListEmptyComponent={
          <Card dark={mode === 'dark'}>
            <Text style={[styles.helperText, { color: theme.colors.textMuted }]}>No group expenses yet.</Text>
          </Card>
        }
        ItemSeparatorComponent={() => <View style={styles.separator} />}
        renderItem={({ item }) => {
          const paidBy = group.members.find((member) => member.id === item.paidByMemberId);

          return (
            <Pressable
              accessibilityRole="button"
              onPress={() => undefined}
            >
              <Card dark={mode === 'dark'} style={styles.expenseCard}>
                <Text style={[styles.expenseTitle, { color: theme.colors.text }]}>{item.title}</Text>
                <Text style={[styles.expenseMeta, { color: theme.colors.textMuted }]}> 
                  Paid by {paidBy?.name ?? 'Unknown'}
                </Text>
                <Text style={[styles.expenseAmount, { color: theme.colors.text }]}> 
                  {formatMoney(item.amount, item.currency)}
                </Text>
                <Text
                  style={[
                    styles.expenseStatus,
                    {
                      color: item.settledAt ? theme.colors.income : theme.colors.primary,
                    },
                  ]}
                >
                  {item.settledAt ? 'Settled' : 'Open'}
                </Text>
              </Card>
            </Pressable>
          );
        }}
        showsVerticalScrollIndicator={false}
      />
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    gap: 0,
    paddingBottom: 0,
    paddingHorizontal: 0,
    paddingTop: 0,
  },
  content: {
    paddingHorizontal: spacing.md,
    paddingTop: spacing.sm,
    paddingBottom: spacing.xl,
  },
  headerWrap: {
    gap: spacing.sm,
    marginBottom: spacing.sm,
  },
  heroCard: {
    gap: spacing.xs,
  },
  groupTitle: {
    ...typography.heading,
    fontSize: 24,
  },
  memberWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  balanceCard: {
    gap: spacing.xs,
  },
  sectionTitle: {
    ...typography.subheading,
    fontSize: 18,
    fontWeight: '700',
  },
  balanceRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  balanceName: {
    ...typography.body,
  },
  balanceValue: {
    ...typography.subheading,
    fontWeight: '700',
  },
  actionRow: {
    gap: spacing.xs,
  },
  expenseCard: {
    gap: spacing.xxs,
  },
  expenseTitle: {
    ...typography.subheading,
    fontWeight: '700',
  },
  expenseMeta: {
    ...typography.caption,
  },
  expenseAmount: {
    ...typography.body,
    fontWeight: '700',
  },
  expenseStatus: {
    ...typography.caption,
    fontWeight: '700',
  },
  separator: {
    height: spacing.sm,
  },
  helperText: {
    ...typography.body,
  },
  loadingCard: {
    alignItems: 'center',
    gap: spacing.sm,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
    fontWeight: '700',
  },
  errorText: {
    ...typography.body,
  },
});
```

## FILE: apps/mobile/src/screens/split/AddGroupExpenseScreen.tsx
```
import { useState } from 'react';
import { Alert, Pressable, StyleSheet, Text, View } from 'react-native';

import { useNavigation, useRoute } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import type { RouteProp } from '@react-navigation/native';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';

import { apiClient } from '../../api/client';
import { financeQueryKeys } from '../../api/queryKeys';
import { useAuth } from '../../auth/AuthProvider';
import { Card, PrimaryButton, ScreenContainer, TextField } from '../../components/ui';
import type { TransactionsStackParamList } from '../../navigation/stacks/TransactionsStack';
import { radius, spacing, typography, useTheme } from '../../theme';
import { apiErrorText } from '../../utils/apiErrorText';

type SplitMode = 'equal' | 'custom';

function formatSplitValue(amount: number): string {
  if (!Number.isFinite(amount)) {
    return '0';
  }

  return amount.toFixed(2);
}

export function AddGroupExpenseScreen() {
  const route = useRoute<RouteProp<TransactionsStackParamList, 'AddGroupExpense'>>();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const queryClient = useQueryClient();
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();

  const [title, setTitle] = useState('');
  const [amount, setAmount] = useState('');
  const [currency, setCurrency] = useState('TRY');
  const [splitMode, setSplitMode] = useState<SplitMode>('equal');
  const [paidByMemberId, setPaidByMemberId] = useState('');
  const [customSplits, setCustomSplits] = useState<Record<string, string>>({});

  const groupQuery = useQuery({
    queryKey: financeQueryKeys.groups.detail(route.params.groupId),
    queryFn: () => withAuth((token) => apiClient.getGroup(route.params.groupId, token)),
  });

  const createMutation = useMutation({
    mutationFn: () =>
      withAuth((token) => {
        const parsedAmount = Number(amount);

        if (!Number.isFinite(parsedAmount) || parsedAmount <= 0) {
          throw new Error('Amount must be a positive number.');
        }

        const members = groupQuery.data?.members ?? [];
        const memberCount = members.length;

        if (!paidByMemberId) {
          throw new Error('Choose who paid for this expense.');
        }

        if (memberCount === 0) {
          throw new Error('Group has no members.');
        }

        const splits =
          splitMode === 'equal'
            ? members.map((member, index) => {
                if (index === memberCount - 1) {
                  const allocated = (memberCount - 1) * (parsedAmount / memberCount);
                  return {
                    memberId: member.id,
                    amount: Number((parsedAmount - allocated).toFixed(2)),
                  };
                }

                return {
                  memberId: member.id,
                  amount: Number((parsedAmount / memberCount).toFixed(2)),
                };
              })
            : members.map((member) => ({
                memberId: member.id,
                amount: Number(customSplits[member.id] ?? '0'),
              }));

        return apiClient.createGroupExpense(
          route.params.groupId,
          {
            paidByMemberId,
            title: title.trim() || 'Group expense',
            amount: parsedAmount,
            currency: currency.trim().toUpperCase(),
            splits,
          },
          token,
        );
      }),
    onSuccess: async () => {
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.detail(route.params.groupId) }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.expenses(route.params.groupId) }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.list() }),
      ]);

      navigation.goBack();
    },
    onError: (error) => {
      Alert.alert('Create expense failed', apiErrorText(error));
    },
  });

  if (groupQuery.isLoading) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'}>
          <Text style={[styles.helperText, { color: theme.colors.textMuted }]}>Loading group members...</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (groupQuery.isError || !groupQuery.data) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.errorCard}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>Could not load group</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(groupQuery.error)}</Text>
          <PrimaryButton label="Retry" onPress={() => void groupQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  const group = groupQuery.data;
  const members = group.members;

  return (
    <ScreenContainer dark={mode === 'dark'}>
      <View style={styles.container}>
        <Card dark={mode === 'dark'} style={styles.card}>
          <Text style={[styles.title, { color: theme.colors.text }]}>Add Group Expense</Text>
          <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}>{group.name}</Text>

          <TextField
            label="Title"
            value={title}
            onChangeText={setTitle}
            placeholder="Dinner"
          />

          <TextField
            label="Amount"
            value={amount}
            onChangeText={setAmount}
            placeholder="0.00"
            keyboardType="decimal-pad"
          />

          <TextField
            label="Currency"
            value={currency}
            onChangeText={setCurrency}
            placeholder="TRY"
            autoCapitalize="characters"
          />

          <Text style={[styles.label, { color: theme.colors.labelMuted }]}>Paid by</Text>
          <View style={styles.memberRow}>
            {members.map((member) => {
              const selected = member.id === paidByMemberId;

              return (
                <Pressable
                  key={member.id}
                  accessibilityRole="button"
                  onPress={() => setPaidByMemberId(member.id)}
                  style={[
                    styles.memberChip,
                    {
                      borderColor: selected ? theme.colors.primary : theme.colors.border,
                      backgroundColor: selected
                        ? mode === 'dark'
                          ? 'rgba(47,107,255,0.2)'
                          : '#EAF0FF'
                        : mode === 'dark'
                          ? '#111728'
                          : '#FFFFFF',
                    },
                  ]}
                >
                  <Text
                    style={[
                      styles.memberChipText,
                      {
                        color: selected ? theme.colors.primary : theme.colors.textMuted,
                      },
                    ]}
                  >
                    {member.name}
                  </Text>
                </Pressable>
              );
            })}
          </View>

          <Text style={[styles.label, { color: theme.colors.labelMuted }]}>Split mode</Text>
          <View style={styles.modeRow}>
            {(['equal', 'custom'] as const).map((modeOption) => {
              const selected = splitMode === modeOption;

              return (
                <Pressable
                  key={modeOption}
                  accessibilityRole="button"
                  onPress={() => setSplitMode(modeOption)}
                  style={[
                    styles.modeChip,
                    {
                      backgroundColor: selected
                        ? theme.colors.primary
                        : mode === 'dark'
                          ? '#111728'
                          : '#EEF2FA',
                    },
                  ]}
                >
                  <Text style={[styles.modeChipText, { color: selected ? '#FFFFFF' : theme.colors.textMuted }]}>
                    {modeOption === 'equal' ? 'Split equally' : 'Custom split'}
                  </Text>
                </Pressable>
              );
            })}
          </View>

          {splitMode === 'equal' ? (
            <View style={styles.equalPreviewWrap}>
              {members.map((member) => (
                <View key={member.id} style={styles.equalPreviewRow}>
                  <Text style={[styles.equalPreviewName, { color: theme.colors.textMuted }]}>{member.name}</Text>
                  <Text style={[styles.equalPreviewValue, { color: theme.colors.text }]}> 
                    {formatSplitValue((Number(amount) || 0) / Math.max(members.length, 1))}
                  </Text>
                </View>
              ))}
            </View>
          ) : (
            <View style={styles.customWrap}>
              {members.map((member) => (
                <TextField
                  key={member.id}
                  label={`Split: ${member.name}`}
                  value={customSplits[member.id] ?? ''}
                  onChangeText={(value) =>
                    setCustomSplits((prev) => ({
                      ...prev,
                      [member.id]: value,
                    }))
                  }
                  placeholder="0.00"
                  keyboardType="decimal-pad"
                />
              ))}
            </View>
          )}

          <PrimaryButton
            disabled={createMutation.isPending}
            label={createMutation.isPending ? 'Saving...' : 'Save expense'}
            onPress={() => createMutation.mutate()}
          />
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  card: {
    gap: spacing.sm,
  },
  title: {
    ...typography.heading,
    fontSize: 24,
  },
  subtitle: {
    ...typography.body,
  },
  label: {
    ...typography.caption,
    fontSize: 12,
    fontWeight: '700',
  },
  memberRow: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  memberChip: {
    borderRadius: radius.full,
    borderWidth: 1,
    minHeight: 34,
    justifyContent: 'center',
    paddingHorizontal: spacing.sm,
  },
  memberChipText: {
    ...typography.caption,
    fontWeight: '700',
  },
  modeRow: {
    flexDirection: 'row',
    gap: spacing.xs,
  },
  modeChip: {
    borderRadius: radius.full,
    minHeight: 34,
    justifyContent: 'center',
    paddingHorizontal: spacing.sm,
  },
  modeChipText: {
    ...typography.caption,
    fontWeight: '700',
  },
  equalPreviewWrap: {
    gap: spacing.xs,
  },
  equalPreviewRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  equalPreviewName: {
    ...typography.body,
  },
  equalPreviewValue: {
    ...typography.subheading,
    fontWeight: '700',
  },
  customWrap: {
    gap: spacing.xs,
  },
  helperText: {
    ...typography.body,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
    fontWeight: '700',
  },
  errorText: {
    ...typography.body,
  },
});
```

## FILE: apps/mobile/src/screens/split/SettleUpScreen.tsx
```
import { Alert, StyleSheet, Text, View } from 'react-native';

import { useNavigation, useRoute } from '@react-navigation/native';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';
import type { RouteProp } from '@react-navigation/native';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';

import { apiClient } from '../../api/client';
import { financeQueryKeys } from '../../api/queryKeys';
import { useAuth } from '../../auth/AuthProvider';
import { Card, PrimaryButton, ScreenContainer } from '../../components/ui';
import type { TransactionsStackParamList } from '../../navigation/stacks/TransactionsStack';
import { spacing, typography, useTheme } from '../../theme';
import { apiErrorText } from '../../utils/apiErrorText';

function formatMoney(amount: number, currency: string): string {
  return new Intl.NumberFormat('tr-TR', {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  }).format(amount);
}

export function SettleUpScreen() {
  const route = useRoute<RouteProp<TransactionsStackParamList, 'SettleUp'>>();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();
  const queryClient = useQueryClient();
  const { withAuth } = useAuth();
  const { theme, mode } = useTheme();

  const expensesQuery = useQuery({
    queryKey: financeQueryKeys.groups.expenses(route.params.groupId),
    queryFn: () => withAuth((token) => apiClient.getGroupExpenses(route.params.groupId, token)),
  });

  const settleMutation = useMutation({
    mutationFn: () => withAuth((token) => apiClient.settleGroup(route.params.groupId, token)),
    onSuccess: async (response) => {
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.expenses(route.params.groupId) }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.detail(route.params.groupId) }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.groups.list() }),
      ]);

      Alert.alert('Settle complete', `${response.settledCount} expense(s) marked as settled.`);
      navigation.goBack();
    },
    onError: (error) => {
      Alert.alert('Settle failed', apiErrorText(error));
    },
  });

  if (expensesQuery.isLoading) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'}>
          <Text style={[styles.helperText, { color: theme.colors.textMuted }]}>Loading unsettled expenses...</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (expensesQuery.isError || !expensesQuery.data) {
    return (
      <ScreenContainer dark={mode === 'dark'}>
        <Card dark={mode === 'dark'} style={styles.errorCard}>
          <Text style={[styles.errorTitle, { color: theme.colors.text }]}>Could not load settle summary</Text>
          <Text style={[styles.errorText, { color: theme.colors.expense }]}>{apiErrorText(expensesQuery.error)}</Text>
          <PrimaryButton label="Retry" onPress={() => void expensesQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  const unsettled = expensesQuery.data.expenses.filter((expense) => !expense.settledAt);
  const unsettledTotal = unsettled.reduce((sum, expense) => sum + expense.amount, 0);
  const currency = unsettled[0]?.currency ?? 'TRY';

  return (
    <ScreenContainer dark={mode === 'dark'}>
      <View style={styles.container}>
        <Card dark={mode === 'dark'} style={styles.card}>
          <Text style={[styles.title, { color: theme.colors.text }]}>Settle Up</Text>
          <Text style={[styles.subtitle, { color: theme.colors.textMuted }]}> 
            This marks all open group expenses as settled.
          </Text>

          <View style={styles.summaryRow}>
            <Text style={[styles.summaryLabel, { color: theme.colors.textMuted }]}>Open expenses</Text>
            <Text style={[styles.summaryValue, { color: theme.colors.text }]}>{unsettled.length}</Text>
          </View>

          <View style={styles.summaryRow}>
            <Text style={[styles.summaryLabel, { color: theme.colors.textMuted }]}>Open amount</Text>
            <Text style={[styles.summaryValue, { color: theme.colors.text }]}> 
              {formatMoney(unsettledTotal, currency)}
            </Text>
          </View>

          <PrimaryButton
            disabled={settleMutation.isPending || unsettled.length === 0}
            label={settleMutation.isPending ? 'Settling...' : 'Mark settled'}
            onPress={() => settleMutation.mutate()}
          />
        </Card>
      </View>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  container: {
    gap: spacing.sm,
  },
  card: {
    gap: spacing.sm,
  },
  title: {
    ...typography.heading,
    fontSize: 24,
  },
  subtitle: {
    ...typography.body,
  },
  summaryRow: {
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  summaryLabel: {
    ...typography.body,
  },
  summaryValue: {
    ...typography.subheading,
    fontWeight: '700',
  },
  helperText: {
    ...typography.body,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
    fontWeight: '700',
  },
  errorText: {
    ...typography.body,
  },
});
```

