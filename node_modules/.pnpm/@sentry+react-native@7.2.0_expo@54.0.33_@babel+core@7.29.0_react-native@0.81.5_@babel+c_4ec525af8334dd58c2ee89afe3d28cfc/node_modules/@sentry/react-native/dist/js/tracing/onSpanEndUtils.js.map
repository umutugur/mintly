{"version":3,"file":"onSpanEndUtils.js","sourceRoot":"","sources":["../../../src/js/tracing/onSpanEndUtils.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAExF,OAAO,EAAE,QAAQ,EAAE,MAAM,cAAc,CAAC;AACxC,OAAO,EAAE,UAAU,EAAE,YAAY,EAAE,MAAM,eAAe,CAAC;AAEzD;;GAEG;AACH,MAAM,UAAU,aAAa,CAAC,MAAc,EAAE,IAAU,EAAE,QAA8B;IACtF,MAAM,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,SAAe,EAAE,EAAE;QACvC,IAAI,IAAI,KAAK,SAAS,EAAE;YACtB,OAAO;SACR;QACD,QAAQ,CAAC,SAAS,CAAC,CAAC;IACtB,CAAC,CAAC,CAAC;AACL,CAAC;AAED,MAAM,CAAC,MAAM,yBAAyB,GAAG,CAAC,MAAc,EAAE,IAAU,EAAE,aAAqB,EAAQ,EAAE;IACnG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;QACrB,KAAK,CAAC,IAAI,CAAC,gFAAgF,CAAC,CAAC;QAC7F,OAAO;KACR;IAED,MAAM,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,SAAe,EAAE,EAAE;QACvC,IAAI,SAAS,KAAK,IAAI,EAAE;YACtB,OAAO;SACR;QAED,MAAM,YAAY,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC;QAChD,MAAM,cAAc,GAAG,UAAU,CAAC,IAAI,CAAC,CAAC,eAAe,CAAC;QACxD,IAAI,CAAC,YAAY,IAAI,CAAC,cAAc,EAAE;YACpC,OAAO;SACR;QAED,MAAM,IAAI,GAAG,YAAY,GAAG,cAAc,CAAC;QAC3C,MAAM,qBAAqB,GAAG,YAAY,IAAI,CAAC,IAAI,GAAG,aAAa,IAAI,IAAI,GAAG,CAAC,CAAC,CAAC;QACjF,IAAI,qBAAqB,EAAE;YACzB,IAAI,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,iBAAiB,EAAE,OAAO,EAAE,mBAAmB,EAAE,CAAC,CAAC;YAC1E,0DAA0D;YAC1D,IAAI,CAAC,YAAY,CAAC,gCAAgC,EAAE,MAAM,CAAC,CAAC;SAC7D;IACH,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,yBAAyB,GAAG,CAAC,MAA0B,EAAE,IAAsB,EAAQ,EAAE;IACpG,IAAI,CAAC,MAAM,EAAE;QACX,KAAK,CAAC,IAAI,CAAC,gEAAgE,CAAC,CAAC;QAC7E,OAAO;KACR;IAED,IAAI,CAAC,IAAI,EAAE;QACT,KAAK,CAAC,IAAI,CAAC,8DAA8D,CAAC,CAAC;QAC3E,OAAO;KACR;IAED,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;QAC5C,KAAK,CAAC,IAAI,CAAC,gFAAgF,CAAC,CAAC;QAC7F,OAAO;KACR;IAED,MAAM,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,SAAe,EAAE,EAAE;;QACvC,IAAI,SAAS,KAAK,IAAI,EAAE;YACtB,OAAO;SACR;QAED,IAAI,CAAC,CAAA,MAAA,UAAU,CAAC,IAAI,CAAC,CAAC,IAAI,0CAAG,qBAAqB,CAAC,CAAA,EAAE;YACnD,OAAO;SACR;QAED,MAAM,QAAQ,GAAG,kBAAkB,CAAC,IAAI,CAAC,CAAC;QAC1C,MAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAC9B,KAAK,CAAC,EAAE,CACN,KAAK,CAAC,WAAW,EAAE,CAAC,MAAM,KAAK,IAAI,CAAC,WAAW,EAAE,CAAC,MAAM;YACxD,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,yBAAyB;YAClD,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,uBAAuB,CACnD,CAAC;QAEF,IAAI,QAAQ,CAAC,MAAM,IAAI,CAAC,EAAE;YACxB,yGAAyG;YACzG,KAAK,CAAC,GAAG,CACP,qIAAqI,CACtI,CAAC;YACF,qDAAqD;YACrD,IAAI,CAAC,UAAU,CAAC,GAAG,KAAK,CAAC;SAC1B;IACH,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,CAAC,MAAM,sBAAsB,GAAG,CAAC,MAAc,EAAE,IAAU,EAAQ,EAAE;IACzE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;QAC5C,KAAK,CAAC,IAAI,CAAC,+EAA+E,CAAC,CAAC;QAC5F,OAAO;KACR;IAED,MAAM,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,SAAe,EAAE,EAAE;QACvC,IAAI,SAAS,KAAK,IAAI,EAAE;YACtB,OAAO;SACR;QAED,MAAM,QAAQ,GAAG,kBAAkB,CAAC,IAAI,CAAC,CAAC;QAE1C,IAAI,QAAQ,CAAC,MAAM,IAAI,CAAC,EAAE;YACxB,4CAA4C;YAC5C,KAAK,CAAC,GAAG,CAAC,mBAAmB,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,kCAAkC,CAAC,CAAC;YACpF,IAAI,CAAC,UAAU,CAAC,GAAG,KAAK,CAAC;SAC1B;IACH,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEF;;GAEG;AACH,MAAM,CAAC,MAAM,kBAAkB,GAAG,CAAC,MAAc,EAAE,IAAU,EAAQ,EAAE;IACrE,MAAM,YAAY,GAAG,QAAQ,CAAC,gBAAgB,CAAC,QAAQ,EAAE,CAAC,QAAwB,EAAE,EAAE;QACpF,IAAI,QAAQ,KAAK,YAAY,EAAE;YAC7B,KAAK,CAAC,GAAG,CAAC,WAAW,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,iEAAiE,CAAC,CAAC;YAC3G,IAAI,CAAC,SAAS,CAAC,EAAE,IAAI,EAAE,iBAAiB,EAAE,OAAO,EAAE,WAAW,EAAE,CAAC,CAAC;YAClE,IAAI,CAAC,GAAG,EAAE,CAAC;SACZ;IACH,CAAC,CAAC,CAAC;IAEH,YAAY;QACV,MAAM,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,SAAe,EAAE,EAAE;;YACvC,IAAI,SAAS,KAAK,IAAI,EAAE;gBACtB,KAAK,CAAC,GAAG,CAAC,kCAAkC,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC;gBAChF,MAAA,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,MAAM,4DAAI,CAAC;aAC1B;QACH,CAAC,CAAC,CAAC;AACP,CAAC,CAAC","sourcesContent":["import type { Client, Span } from '@sentry/core';\nimport { debug, getSpanDescendants, SPAN_STATUS_ERROR, spanToJSON } from '@sentry/core';\nimport type { AppStateStatus } from 'react-native';\nimport { AppState } from 'react-native';\nimport { isRootSpan, isSentrySpan } from '../utils/span';\n\n/**\n * Hooks on span end event to execute a callback when the span ends.\n */\nexport function onThisSpanEnd(client: Client, span: Span, callback: (span: Span) => void): void {\n  client.on('spanEnd', (endedSpan: Span) => {\n    if (span !== endedSpan) {\n      return;\n    }\n    callback(endedSpan);\n  });\n}\n\nexport const adjustTransactionDuration = (client: Client, span: Span, maxDurationMs: number): void => {\n  if (!isRootSpan(span)) {\n    debug.warn('Not sampling empty back spans only works for Sentry Transactions (Root Spans).');\n    return;\n  }\n\n  client.on('spanEnd', (endedSpan: Span) => {\n    if (endedSpan !== span) {\n      return;\n    }\n\n    const endTimestamp = spanToJSON(span).timestamp;\n    const startTimestamp = spanToJSON(span).start_timestamp;\n    if (!endTimestamp || !startTimestamp) {\n      return;\n    }\n\n    const diff = endTimestamp - startTimestamp;\n    const isOutdatedTransaction = endTimestamp && (diff > maxDurationMs || diff < 0);\n    if (isOutdatedTransaction) {\n      span.setStatus({ code: SPAN_STATUS_ERROR, message: 'deadline_exceeded' });\n      // TODO: check where was used, might be possible to delete\n      span.setAttribute('maxTransactionDurationExceeded', 'true');\n    }\n  });\n};\n\nexport const ignoreEmptyBackNavigation = (client: Client | undefined, span: Span | undefined): void => {\n  if (!client) {\n    debug.warn('Could not hook on spanEnd event because client is not defined.');\n    return;\n  }\n\n  if (!span) {\n    debug.warn('Could not hook on spanEnd event because span is not defined.');\n    return;\n  }\n\n  if (!isRootSpan(span) || !isSentrySpan(span)) {\n    debug.warn('Not sampling empty back spans only works for Sentry Transactions (Root Spans).');\n    return;\n  }\n\n  client.on('spanEnd', (endedSpan: Span) => {\n    if (endedSpan !== span) {\n      return;\n    }\n\n    if (!spanToJSON(span).data?.['route.has_been_seen']) {\n      return;\n    }\n\n    const children = getSpanDescendants(span);\n    const filtered = children.filter(\n      child =>\n        child.spanContext().spanId !== span.spanContext().spanId &&\n        spanToJSON(child).op !== 'ui.load.initial_display' &&\n        spanToJSON(child).op !== 'navigation.processing',\n    );\n\n    if (filtered.length <= 0) {\n      // filter children must include at least one span not created by the navigation automatic instrumentation\n      debug.log(\n        'Not sampling transaction as route has been seen before. Pass ignoreEmptyBackNavigationTransactions = false to disable this feature.',\n      );\n      // Route has been seen before and has no child spans.\n      span['_sampled'] = false;\n    }\n  });\n};\n\n/**\n * Idle Transaction callback to only sample transactions with child spans.\n * To avoid side effects of other callbacks this should be hooked as the last callback.\n */\nexport const onlySampleIfChildSpans = (client: Client, span: Span): void => {\n  if (!isRootSpan(span) || !isSentrySpan(span)) {\n    debug.warn('Not sampling childless spans only works for Sentry Transactions (Root Spans).');\n    return;\n  }\n\n  client.on('spanEnd', (endedSpan: Span) => {\n    if (endedSpan !== span) {\n      return;\n    }\n\n    const children = getSpanDescendants(span);\n\n    if (children.length <= 1) {\n      // Span always has at lest one child, itself\n      debug.log(`Not sampling as ${spanToJSON(span).op} transaction has no child spans.`);\n      span['_sampled'] = false;\n    }\n  });\n};\n\n/**\n * Hooks on AppState change to cancel the span if the app goes background.\n */\nexport const cancelInBackground = (client: Client, span: Span): void => {\n  const subscription = AppState.addEventListener('change', (newState: AppStateStatus) => {\n    if (newState === 'background') {\n      debug.log(`Setting ${spanToJSON(span).op} transaction to cancelled because the app is in the background.`);\n      span.setStatus({ code: SPAN_STATUS_ERROR, message: 'cancelled' });\n      span.end();\n    }\n  });\n\n  subscription &&\n    client.on('spanEnd', (endedSpan: Span) => {\n      if (endedSpan === span) {\n        debug.log(`Removing AppState listener for ${spanToJSON(span).op} transaction.`);\n        subscription?.remove?.();\n      }\n    });\n};\n"]}