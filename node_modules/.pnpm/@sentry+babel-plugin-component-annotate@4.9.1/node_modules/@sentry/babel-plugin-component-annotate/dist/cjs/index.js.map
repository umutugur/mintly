{"version":3,"file":"index.js","sources":["../../src/constants.ts","../../src/experimental.ts","../../src/index.ts"],"sourcesContent":["/**\n * MIT License\n *\n * Copyright (c) 2020 Engineering at FullStory\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nexport const KNOWN_INCOMPATIBLE_PLUGINS = [\n  // This module might be causing an issue preventing clicks. For safety, we won't run on this module.\n  \"react-native-testfairy\",\n  // This module checks for unexpected property keys and throws an exception.\n  \"@react-navigation\",\n];\n\nexport const DEFAULT_IGNORED_ELEMENTS = [\n  \"a\",\n  \"abbr\",\n  \"address\",\n  \"area\",\n  \"article\",\n  \"aside\",\n  \"audio\",\n  \"b\",\n  \"base\",\n  \"bdi\",\n  \"bdo\",\n  \"blockquote\",\n  \"body\",\n  \"br\",\n  \"button\",\n  \"canvas\",\n  \"caption\",\n  \"cite\",\n  \"code\",\n  \"col\",\n  \"colgroup\",\n  \"data\",\n  \"datalist\",\n  \"dd\",\n  \"del\",\n  \"details\",\n  \"dfn\",\n  \"dialog\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"em\",\n  \"embed\",\n  \"fieldset\",\n  \"figure\",\n  \"footer\",\n  \"form\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"head\",\n  \"header\",\n  \"hgroup\",\n  \"hr\",\n  \"html\",\n  \"i\",\n  \"iframe\",\n  \"img\",\n  \"input\",\n  \"ins\",\n  \"kbd\",\n  \"keygen\",\n  \"label\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"map\",\n  \"mark\",\n  \"menu\",\n  \"menuitem\",\n  \"meter\",\n  \"nav\",\n  \"noscript\",\n  \"object\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"p\",\n  \"param\",\n  \"pre\",\n  \"progress\",\n  \"q\",\n  \"rb\",\n  \"rp\",\n  \"rt\",\n  \"rtc\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"script\",\n  \"section\",\n  \"select\",\n  \"small\",\n  \"source\",\n  \"span\",\n  \"strong\",\n  \"style\",\n  \"sub\",\n  \"summary\",\n  \"sup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"template\",\n  \"textarea\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"time\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"u\",\n  \"ul\",\n  \"var\",\n  \"video\",\n  \"wbr\",\n];\n","/**\n * MIT License\n *\n * Copyright (c) 2020 Engineering at FullStory\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\n/**\n * The following code is based on the FullStory Babel plugin, but has been modified to work\n * with Sentry products:\n *\n * - Added `sentry` to data properties, i.e `data-sentry-component`\n * - Converted to TypeScript\n * - Code cleanups\n * - Highly modified to inject the data attributes into the root HTML elements of a component.\n */\n\nimport type * as Babel from \"@babel/core\";\nimport type { PluginObj, PluginPass } from \"@babel/core\";\n\nconst REACT_NATIVE_ELEMENTS: string[] = [\n  \"Image\",\n  \"Text\",\n  \"View\",\n  \"ScrollView\",\n  \"TextInput\",\n  \"TouchableOpacity\",\n  \"TouchableHighlight\",\n  \"TouchableWithoutFeedback\",\n  \"FlatList\",\n  \"SectionList\",\n  \"ActivityIndicator\",\n  \"Button\",\n  \"Switch\",\n  \"Modal\",\n  \"SafeAreaView\",\n  \"StatusBar\",\n  \"KeyboardAvoidingView\",\n  \"RefreshControl\",\n  \"Picker\",\n  \"Slider\",\n];\n\ninterface AnnotationOpts {\n  native?: boolean;\n  ignoredComponents?: string[];\n}\n\ninterface FragmentContext {\n  fragmentAliases: Set<string>;\n  reactNamespaceAliases: Set<string>;\n}\n\ninterface AnnotationPluginPass extends PluginPass {\n  opts: AnnotationOpts;\n  sentryFragmentContext?: FragmentContext;\n}\n\ntype AnnotationPlugin = PluginObj<AnnotationPluginPass>;\n\n// Shared context object for all JSX processing functions\ninterface JSXProcessingContext {\n  /** Babel types object */\n  t: typeof Babel.types;\n  /** Name of the React component */\n  componentName: string;\n  /** AAttribute name for the component */\n  attributeName: string;\n  /** Array of component names to ignore */\n  ignoredComponents: string[];\n  /** Fragment context for identifying React fragments */\n  fragmentContext?: FragmentContext;\n}\n\n// We must export the plugin as default, otherwise the Babel loader will not be able to resolve it when configured using its string identifier\nexport function experimentalComponentNameAnnotatePlugin({\n  types: t,\n}: typeof Babel): AnnotationPlugin {\n  return {\n    visitor: {\n      Program: {\n        enter(path, state) {\n          const fragmentContext = collectFragmentContext(path);\n          state.sentryFragmentContext = fragmentContext;\n        },\n      },\n      FunctionDeclaration(path, state) {\n        if (!path.node.id || !path.node.id.name) {\n          return;\n        }\n\n        const context = createJSXProcessingContext(state, t, path.node.id.name);\n        functionBodyPushAttributes(context, path);\n      },\n      ArrowFunctionExpression(path, state) {\n        // We're expecting a `VariableDeclarator` like `const MyComponent =`\n        const parent = path.parent;\n\n        if (\n          !parent ||\n          !(\"id\" in parent) ||\n          !parent.id ||\n          !(\"name\" in parent.id) ||\n          !parent.id.name\n        ) {\n          return;\n        }\n\n        const context = createJSXProcessingContext(state, t, parent.id.name);\n        functionBodyPushAttributes(context, path);\n      },\n      ClassDeclaration(path, state) {\n        const name = path.get(\"id\");\n        const properties = path.get(\"body\").get(\"body\");\n        const render = properties.find((prop) => {\n          return prop.isClassMethod() && prop.get(\"key\").isIdentifier({ name: \"render\" });\n        });\n\n        if (!render || !render.traverse) {\n          return;\n        }\n\n        const context = createJSXProcessingContext(state, t, name.node?.name || \"\");\n\n        render.traverse({\n          ReturnStatement(returnStatement) {\n            const arg = returnStatement.get(\"argument\");\n\n            if (!arg.isJSXElement() && !arg.isJSXFragment()) {\n              return;\n            }\n\n            processJSX(context, arg);\n          },\n        });\n      },\n    },\n  };\n}\n\n/**\n * Checks if an element name represents an HTML element (as opposed to a React component).\n * HTML elements include standard lowercase HTML tags and React Native elements.\n */\nfunction isHtmlElement(elementName: string): boolean {\n  // Unknown elements are not HTML elements\n  if (elementName === UNKNOWN_ELEMENT_NAME) {\n    return false;\n  }\n\n  // Check for lowercase first letter (standard HTML elements)\n  if (elementName.length > 0 && elementName.charAt(0) === elementName.charAt(0).toLowerCase()) {\n    return true;\n  }\n\n  // React Native elements typically start with uppercase but are still \"native\" elements\n  // We consider them HTML-like elements for annotation purposes\n  if (REACT_NATIVE_ELEMENTS.includes(elementName)) {\n    return true;\n  }\n\n  // Otherwise, assume it's a React component (PascalCase)\n  return false;\n}\n\n/**\n * Creates a JSX processing context from the plugin state\n */\nfunction createJSXProcessingContext(\n  state: AnnotationPluginPass,\n  t: typeof Babel.types,\n  componentName: string\n): JSXProcessingContext {\n  return {\n    t,\n    componentName,\n    attributeName: attributeNamesFromState(state),\n    ignoredComponents: state.opts.ignoredComponents ?? [],\n    fragmentContext: state.sentryFragmentContext,\n  };\n}\n\n/**\n * Processes the body of a function to add Sentry tracking attributes to JSX elements.\n * Handles various function body structures including direct JSX returns, conditional expressions,\n * and nested JSX elements.\n */\nfunction functionBodyPushAttributes(\n  context: JSXProcessingContext,\n  path: Babel.NodePath<Babel.types.Function>\n): void {\n  let jsxNode: Babel.NodePath;\n\n  const functionBody = path.get(\"body\").get(\"body\");\n\n  if (\n    !(\"length\" in functionBody) &&\n    functionBody.parent &&\n    (functionBody.parent.type === \"JSXElement\" || functionBody.parent.type === \"JSXFragment\")\n  ) {\n    const maybeJsxNode = functionBody.find((c) => {\n      return c.type === \"JSXElement\" || c.type === \"JSXFragment\";\n    });\n\n    if (!maybeJsxNode) {\n      return;\n    }\n\n    jsxNode = maybeJsxNode;\n  } else {\n    const returnStatement = functionBody.find((c) => {\n      return c.type === \"ReturnStatement\";\n    });\n    if (!returnStatement) {\n      return;\n    }\n\n    const arg = returnStatement.get(\"argument\");\n    if (!arg) {\n      return;\n    }\n\n    if (Array.isArray(arg)) {\n      return;\n    }\n\n    // Handle the case of a function body returning a ternary operation.\n    // `return (maybeTrue ? '' : (<SubComponent />))`\n    if (arg.isConditionalExpression()) {\n      const consequent = arg.get(\"consequent\");\n      if (consequent.isJSXFragment() || consequent.isJSXElement()) {\n        processJSX(context, consequent);\n      }\n      const alternate = arg.get(\"alternate\");\n      if (alternate.isJSXFragment() || alternate.isJSXElement()) {\n        processJSX(context, alternate);\n      }\n      return;\n    }\n\n    if (!arg.isJSXFragment() && !arg.isJSXElement()) {\n      return;\n    }\n\n    jsxNode = arg;\n  }\n\n  if (!jsxNode) {\n    return;\n  }\n\n  processJSX(context, jsxNode);\n}\n\n/**\n * Recursively processes JSX elements to add Sentry tracking attributes.\n * Handles both JSX elements and fragments, applying appropriate attributes\n * based on configuration and component context.\n */\nfunction processJSX(context: JSXProcessingContext, jsxNode: Babel.NodePath): void {\n  if (!jsxNode) {\n    return;\n  }\n\n  // NOTE: I don't know of a case where `openingElement` would have more than one item,\n  // but it's safer to always iterate\n  const paths = jsxNode.get(\"openingElement\");\n  const openingElements = Array.isArray(paths) ? paths : [paths];\n\n  const hasInjectedAttributes = openingElements.reduce(\n    (prev, openingElement) =>\n      prev ||\n      applyAttributes(\n        context,\n        openingElement as Babel.NodePath<Babel.types.JSXOpeningElement>,\n        context.componentName\n      ),\n    false\n  );\n\n  if (hasInjectedAttributes) {\n    return;\n  }\n\n  let children = jsxNode.get(\"children\");\n  // TODO: See why `Array.isArray` doesn't have correct behaviour here\n  if (children && !(\"length\" in children)) {\n    // A single child was found, maybe a bit of static text\n    children = [children];\n  }\n\n  children.forEach((child) => {\n    // Happens for some node types like plain text\n    if (!child.node) {\n      return;\n    }\n\n    // If the current element is a fragment, children are still considered at root level\n    // Otherwise, children are not at root level\n    const openingElement = child.get(\"openingElement\");\n    // TODO: Improve this. We never expect to have multiple opening elements\n    // but if it's possible, this should work\n    if (Array.isArray(openingElement)) {\n      return;\n    }\n\n    processJSX(context, child);\n  });\n}\n\n/**\n * Applies Sentry tracking attributes to a JSX opening element.\n * Adds component name, element name, and source file attributes while\n * respecting ignore lists and fragment detection.\n */\nfunction applyAttributes(\n  context: JSXProcessingContext,\n  openingElement: Babel.NodePath<Babel.types.JSXOpeningElement>,\n  componentName: string\n): boolean {\n  const { t, attributeName: componentAttributeName, ignoredComponents, fragmentContext } = context;\n\n  // e.g., Raw JSX text like the `A` in `<h1>a</h1>`\n  if (!openingElement.node) {\n    return false;\n  }\n\n  // Check if this is a React fragment - if so, skip attribute addition entirely\n  const isFragment = isReactFragment(t, openingElement, fragmentContext);\n  if (isFragment) {\n    return false;\n  }\n\n  if (!openingElement.node.attributes) {\n    openingElement.node.attributes = [];\n  }\n\n  const elementName = getPathName(t, openingElement);\n\n  if (!isHtmlElement(elementName)) {\n    return false;\n  }\n\n  const isAnIgnoredComponent = ignoredComponents.some(\n    (ignoredComponent) => ignoredComponent === componentName || ignoredComponent === elementName\n  );\n\n  // Add a stable attribute for the component name (only for root elements)\n  if (!isAnIgnoredComponent && !hasAttributeWithName(openingElement, componentAttributeName)) {\n    if (componentAttributeName) {\n      openingElement.node.attributes.push(\n        t.jSXAttribute(t.jSXIdentifier(componentAttributeName), t.stringLiteral(componentName))\n      );\n    }\n  }\n\n  return true;\n}\n\nfunction attributeNamesFromState(state: AnnotationPluginPass): string {\n  if (state.opts.native) {\n    return \"dataSentryComponent\";\n  }\n\n  return \"data-sentry-component\";\n}\n\nfunction collectFragmentContext(programPath: Babel.NodePath): FragmentContext {\n  const fragmentAliases = new Set<string>();\n  const reactNamespaceAliases = new Set<string>([\"React\"]); // Default React namespace\n\n  programPath.traverse({\n    ImportDeclaration(importPath) {\n      const source = importPath.node.source.value;\n\n      // Handle React imports\n      if (source === \"react\" || source === \"React\") {\n        importPath.node.specifiers.forEach((spec) => {\n          if (spec.type === \"ImportSpecifier\" && spec.imported.type === \"Identifier\") {\n            // Detect aliased React.Fragment imports (e.g., `Fragment as F`)\n            // so we can later identify <F> as a fragment in JSX.\n            if (spec.imported.name === \"Fragment\") {\n              fragmentAliases.add(spec.local.name);\n            }\n          } else if (\n            spec.type === \"ImportDefaultSpecifier\" ||\n            spec.type === \"ImportNamespaceSpecifier\"\n          ) {\n            // import React from 'react' -> React OR\n            // import * as React from 'react' -> React\n            reactNamespaceAliases.add(spec.local.name);\n          }\n        });\n      }\n    },\n\n    // Handle simple variable assignments only (avoid complex cases)\n    VariableDeclarator(varPath) {\n      if (varPath.node.init) {\n        const init = varPath.node.init;\n\n        // Handle identifier assignments: const MyFragment = Fragment\n        if (varPath.node.id.type === \"Identifier\") {\n          // Handle: const MyFragment = Fragment (only if Fragment is a known alias)\n          if (init.type === \"Identifier\" && fragmentAliases.has(init.name)) {\n            fragmentAliases.add(varPath.node.id.name);\n          }\n\n          // Handle: const MyFragment = React.Fragment (only for known React namespaces)\n          if (\n            init.type === \"MemberExpression\" &&\n            init.object.type === \"Identifier\" &&\n            init.property.type === \"Identifier\" &&\n            init.property.name === \"Fragment\" &&\n            reactNamespaceAliases.has(init.object.name)\n          ) {\n            fragmentAliases.add(varPath.node.id.name);\n          }\n        }\n\n        // Handle destructuring assignments: const { Fragment } = React\n        if (varPath.node.id.type === \"ObjectPattern\") {\n          if (init.type === \"Identifier\" && reactNamespaceAliases.has(init.name)) {\n            const properties = varPath.node.id.properties;\n\n            for (const prop of properties) {\n              if (\n                prop.type === \"ObjectProperty\" &&\n                prop.key &&\n                prop.key.type === \"Identifier\" &&\n                prop.value &&\n                prop.value.type === \"Identifier\" &&\n                prop.key.name === \"Fragment\"\n              ) {\n                fragmentAliases.add(prop.value.name);\n              }\n            }\n          }\n        }\n      }\n    },\n  });\n\n  return { fragmentAliases, reactNamespaceAliases };\n}\n\nfunction isReactFragment(\n  t: typeof Babel.types,\n  openingElement: Babel.NodePath,\n  context?: FragmentContext // Add this optional parameter\n): boolean {\n  // Handle JSX fragments (<>)\n  if (openingElement.isJSXFragment()) {\n    return true;\n  }\n\n  const elementName = getPathName(t, openingElement);\n\n  // Direct fragment references\n  if (elementName === \"Fragment\" || elementName === \"React.Fragment\") {\n    return true;\n  }\n\n  // TODO: All these objects are typed as unknown, maybe an oversight in Babel types?\n\n  // Check if the element name is a known fragment alias\n  if (context && elementName && context.fragmentAliases.has(elementName)) {\n    return true;\n  }\n\n  // Handle JSXMemberExpression\n  if (\n    openingElement.node &&\n    \"name\" in openingElement.node &&\n    openingElement.node.name &&\n    typeof openingElement.node.name === \"object\" &&\n    \"type\" in openingElement.node.name &&\n    openingElement.node.name.type === \"JSXMemberExpression\"\n  ) {\n    const nodeName = openingElement.node.name;\n    if (typeof nodeName !== \"object\" || !nodeName) {\n      return false;\n    }\n\n    if (\"object\" in nodeName && \"property\" in nodeName) {\n      const nodeNameObject = nodeName.object;\n      const nodeNameProperty = nodeName.property;\n\n      if (typeof nodeNameObject !== \"object\" || typeof nodeNameProperty !== \"object\") {\n        return false;\n      }\n\n      if (!nodeNameObject || !nodeNameProperty) {\n        return false;\n      }\n\n      const objectName = \"name\" in nodeNameObject && nodeNameObject.name;\n      const propertyName = \"name\" in nodeNameProperty && nodeNameProperty.name;\n\n      // React.Fragment check\n      if (objectName === \"React\" && propertyName === \"Fragment\") {\n        return true;\n      }\n\n      // Enhanced checks using context\n      if (context) {\n        // Check React.Fragment pattern with known React namespaces\n        if (\n          context.reactNamespaceAliases.has(objectName as string) &&\n          propertyName === \"Fragment\"\n        ) {\n          return true;\n        }\n\n        // Check MyFragment.Fragment pattern\n        if (context.fragmentAliases.has(objectName as string) && propertyName === \"Fragment\") {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction hasAttributeWithName(\n  openingElement: Babel.NodePath<Babel.types.JSXOpeningElement>,\n  name: string | undefined | null\n): boolean {\n  if (!name) {\n    return false;\n  }\n\n  return openingElement.node.attributes.some((node) => {\n    if (node.type === \"JSXAttribute\") {\n      return node.name.name === name;\n    }\n\n    return false;\n  });\n}\n\nfunction getPathName(t: typeof Babel.types, path: Babel.NodePath): string {\n  if (!path.node) return UNKNOWN_ELEMENT_NAME;\n  if (!(\"name\" in path.node)) {\n    return UNKNOWN_ELEMENT_NAME;\n  }\n\n  const name = path.node.name;\n\n  if (typeof name === \"string\") {\n    return name;\n  }\n\n  if (t.isIdentifier(name) || t.isJSXIdentifier(name)) {\n    return name.name;\n  }\n\n  if (t.isJSXNamespacedName(name)) {\n    return name.name.name;\n  }\n\n  // Handle JSX member expressions like Tab.Group\n  if (t.isJSXMemberExpression(name)) {\n    const objectName = getJSXMemberExpressionObjectName(t, name.object);\n    const propertyName = name.property.name;\n    return `${objectName}.${propertyName}`;\n  }\n\n  return UNKNOWN_ELEMENT_NAME;\n}\n\n// Recursively handle nested member expressions (e.g. Components.UI.Header)\nfunction getJSXMemberExpressionObjectName(\n  t: typeof Babel.types,\n  object: Babel.types.JSXMemberExpression | Babel.types.JSXIdentifier\n): string {\n  if (t.isJSXIdentifier(object)) {\n    return object.name;\n  }\n  if (t.isJSXMemberExpression(object)) {\n    const objectName = getJSXMemberExpressionObjectName(t, object.object);\n    return `${objectName}.${object.property.name}`;\n  }\n\n  return UNKNOWN_ELEMENT_NAME;\n}\n\nconst UNKNOWN_ELEMENT_NAME = \"unknown\";\n","/**\n * MIT License\n *\n * Copyright (c) 2020 Engineering at FullStory\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\n/**\n * The following code is based on the FullStory Babel plugin, but has been modified to work\n * with Sentry products:\n *\n * - Added `sentry` to data properties, i.e `data-sentry-component`\n * - Converted to TypeScript\n * - Code cleanups\n */\n\nimport type * as Babel from \"@babel/core\";\nimport type { PluginObj, PluginPass } from \"@babel/core\";\n\nimport { DEFAULT_IGNORED_ELEMENTS, KNOWN_INCOMPATIBLE_PLUGINS } from \"./constants\";\n\nconst webComponentName = \"data-sentry-component\";\nconst webElementName = \"data-sentry-element\";\nconst webSourceFileName = \"data-sentry-source-file\";\n\nconst nativeComponentName = \"dataSentryComponent\";\nconst nativeElementName = \"dataSentryElement\";\nconst nativeSourceFileName = \"dataSentrySourceFile\";\n\ninterface AnnotationOpts {\n  native?: boolean;\n  \"annotate-fragments\"?: boolean;\n  ignoredComponents?: string[];\n}\n\ninterface FragmentContext {\n  fragmentAliases: Set<string>;\n  reactNamespaceAliases: Set<string>;\n}\n\ninterface AnnotationPluginPass extends PluginPass {\n  opts: AnnotationOpts;\n  sentryFragmentContext?: FragmentContext;\n}\n\ntype AnnotationPlugin = PluginObj<AnnotationPluginPass>;\n\n// Shared context object for all JSX processing functions\ninterface JSXProcessingContext {\n  /** Whether to annotate React fragments */\n  annotateFragments: boolean;\n  /** Babel types object */\n  t: typeof Babel.types;\n  /** Name of the React component */\n  componentName: string;\n  /** Source file name (optional) */\n  sourceFileName?: string;\n  /** Array of attribute names [component, element, sourceFile] */\n  attributeNames: string[];\n  /** Array of component names to ignore */\n  ignoredComponents: string[];\n  /** Fragment context for identifying React fragments */\n  fragmentContext?: FragmentContext;\n}\n\nexport { experimentalComponentNameAnnotatePlugin } from \"./experimental\";\n\n// We must export the plugin as default, otherwise the Babel loader will not be able to resolve it when configured using its string identifier\nexport default function componentNameAnnotatePlugin({ types: t }: typeof Babel): AnnotationPlugin {\n  return {\n    visitor: {\n      Program: {\n        enter(path, state) {\n          const fragmentContext = collectFragmentContext(path);\n          state.sentryFragmentContext = fragmentContext;\n        },\n      },\n      FunctionDeclaration(path, state) {\n        if (!path.node.id || !path.node.id.name) {\n          return;\n        }\n        if (isKnownIncompatiblePluginFromState(state)) {\n          return;\n        }\n\n        const context = createJSXProcessingContext(state, t, path.node.id.name);\n        functionBodyPushAttributes(context, path);\n      },\n      ArrowFunctionExpression(path, state) {\n        // We're expecting a `VariableDeclarator` like `const MyComponent =`\n        const parent = path.parent;\n\n        if (\n          !parent ||\n          !(\"id\" in parent) ||\n          !parent.id ||\n          !(\"name\" in parent.id) ||\n          !parent.id.name\n        ) {\n          return;\n        }\n\n        if (isKnownIncompatiblePluginFromState(state)) {\n          return;\n        }\n\n        const context = createJSXProcessingContext(state, t, parent.id.name);\n        functionBodyPushAttributes(context, path);\n      },\n      ClassDeclaration(path, state) {\n        const name = path.get(\"id\");\n        const properties = path.get(\"body\").get(\"body\");\n        const render = properties.find((prop) => {\n          return prop.isClassMethod() && prop.get(\"key\").isIdentifier({ name: \"render\" });\n        });\n\n        if (!render || !render.traverse || isKnownIncompatiblePluginFromState(state)) {\n          return;\n        }\n\n        const context = createJSXProcessingContext(state, t, name.node?.name || \"\");\n\n        render.traverse({\n          ReturnStatement(returnStatement) {\n            const arg = returnStatement.get(\"argument\");\n\n            if (!arg.isJSXElement() && !arg.isJSXFragment()) {\n              return;\n            }\n\n            processJSX(context, arg);\n          },\n        });\n      },\n    },\n  };\n}\n\n/**\n * Creates a JSX processing context from the plugin state\n */\nfunction createJSXProcessingContext(\n  state: AnnotationPluginPass,\n  t: typeof Babel.types,\n  componentName: string\n): JSXProcessingContext {\n  return {\n    annotateFragments: state.opts[\"annotate-fragments\"] === true,\n    t,\n    componentName,\n    sourceFileName: sourceFileNameFromState(state),\n    attributeNames: attributeNamesFromState(state),\n    ignoredComponents: state.opts.ignoredComponents ?? [],\n    fragmentContext: state.sentryFragmentContext,\n  };\n}\n\n/**\n * Processes the body of a function to add Sentry tracking attributes to JSX elements.\n * Handles various function body structures including direct JSX returns, conditional expressions,\n * and nested JSX elements.\n */\nfunction functionBodyPushAttributes(\n  context: JSXProcessingContext,\n  path: Babel.NodePath<Babel.types.Function>\n): void {\n  let jsxNode: Babel.NodePath;\n\n  const functionBody = path.get(\"body\").get(\"body\");\n\n  if (\n    !(\"length\" in functionBody) &&\n    functionBody.parent &&\n    (functionBody.parent.type === \"JSXElement\" || functionBody.parent.type === \"JSXFragment\")\n  ) {\n    const maybeJsxNode = functionBody.find((c) => {\n      return c.type === \"JSXElement\" || c.type === \"JSXFragment\";\n    });\n\n    if (!maybeJsxNode) {\n      return;\n    }\n\n    jsxNode = maybeJsxNode;\n  } else {\n    const returnStatement = functionBody.find((c) => {\n      return c.type === \"ReturnStatement\";\n    });\n    if (!returnStatement) {\n      return;\n    }\n\n    const arg = returnStatement.get(\"argument\");\n    if (!arg) {\n      return;\n    }\n\n    if (Array.isArray(arg)) {\n      return;\n    }\n\n    // Handle the case of a function body returning a ternary operation.\n    // `return (maybeTrue ? '' : (<SubComponent />))`\n    if (arg.isConditionalExpression()) {\n      const consequent = arg.get(\"consequent\");\n      if (consequent.isJSXFragment() || consequent.isJSXElement()) {\n        processJSX(context, consequent);\n      }\n      const alternate = arg.get(\"alternate\");\n      if (alternate.isJSXFragment() || alternate.isJSXElement()) {\n        processJSX(context, alternate);\n      }\n      return;\n    }\n\n    if (!arg.isJSXFragment() && !arg.isJSXElement()) {\n      return;\n    }\n\n    jsxNode = arg;\n  }\n\n  if (!jsxNode) {\n    return;\n  }\n\n  processJSX(context, jsxNode);\n}\n\n/**\n * Recursively processes JSX elements to add Sentry tracking attributes.\n * Handles both JSX elements and fragments, applying appropriate attributes\n * based on configuration and component context.\n */\nfunction processJSX(\n  context: JSXProcessingContext,\n  jsxNode: Babel.NodePath,\n  componentName?: string\n): void {\n  if (!jsxNode) {\n    return;\n  }\n\n  // Use provided componentName or fall back to context componentName\n  const currentComponentName = componentName ?? context.componentName;\n\n  // NOTE: I don't know of a case where `openingElement` would have more than one item,\n  // but it's safer to always iterate\n  const paths = jsxNode.get(\"openingElement\");\n  const openingElements = Array.isArray(paths) ? paths : [paths];\n\n  openingElements.forEach((openingElement) => {\n    applyAttributes(\n      context,\n      openingElement as Babel.NodePath<Babel.types.JSXOpeningElement>,\n      currentComponentName\n    );\n  });\n\n  let children = jsxNode.get(\"children\");\n  // TODO: See why `Array.isArray` doesn't have correct behaviour here\n  if (children && !(\"length\" in children)) {\n    // A single child was found, maybe a bit of static text\n    children = [children];\n  }\n\n  let shouldSetComponentName = context.annotateFragments;\n\n  children.forEach((child) => {\n    // Happens for some node types like plain text\n    if (!child.node) {\n      return;\n    }\n\n    // Children don't receive the data-component attribute so we pass null for componentName unless it's the first child of a Fragment with a node and `annotateFragments` is true\n    const openingElement = child.get(\"openingElement\");\n    // TODO: Improve this. We never expect to have multiple opening elements\n    // but if it's possible, this should work\n    if (Array.isArray(openingElement)) {\n      return;\n    }\n\n    if (shouldSetComponentName && openingElement && openingElement.node) {\n      shouldSetComponentName = false;\n      processJSX(context, child, currentComponentName);\n    } else {\n      processJSX(context, child, \"\");\n    }\n  });\n}\n\n/**\n * Applies Sentry tracking attributes to a JSX opening element.\n * Adds component name, element name, and source file attributes while\n * respecting ignore lists and fragment detection.\n */\nfunction applyAttributes(\n  context: JSXProcessingContext,\n  openingElement: Babel.NodePath<Babel.types.JSXOpeningElement>,\n  componentName: string\n): void {\n  const { t, attributeNames, ignoredComponents, fragmentContext, sourceFileName } = context;\n  const [componentAttributeName, elementAttributeName, sourceFileAttributeName] = attributeNames;\n\n  // e.g., Raw JSX text like the `A` in `<h1>a</h1>`\n  if (!openingElement.node) {\n    return;\n  }\n\n  // Check if this is a React fragment - if so, skip attribute addition entirely\n  const isFragment = isReactFragment(t, openingElement, fragmentContext);\n  if (isFragment) {\n    return;\n  }\n\n  if (!openingElement.node.attributes) openingElement.node.attributes = [];\n  const elementName = getPathName(t, openingElement);\n\n  const isAnIgnoredComponent = ignoredComponents.some(\n    (ignoredComponent) => ignoredComponent === componentName || ignoredComponent === elementName\n  );\n\n  // Add a stable attribute for the element name but only for non-DOM names\n  let isAnIgnoredElement = false;\n  if (!isAnIgnoredComponent && !hasAttributeWithName(openingElement, elementAttributeName)) {\n    if (DEFAULT_IGNORED_ELEMENTS.includes(elementName)) {\n      isAnIgnoredElement = true;\n    } else {\n      // Always add element attribute for non-ignored elements\n      if (elementAttributeName) {\n        openingElement.node.attributes.push(\n          t.jSXAttribute(t.jSXIdentifier(elementAttributeName), t.stringLiteral(elementName))\n        );\n      }\n    }\n  }\n\n  // Add a stable attribute for the component name (absent for non-root elements)\n  if (\n    componentName &&\n    !isAnIgnoredComponent &&\n    !hasAttributeWithName(openingElement, componentAttributeName)\n  ) {\n    if (componentAttributeName) {\n      openingElement.node.attributes.push(\n        t.jSXAttribute(t.jSXIdentifier(componentAttributeName), t.stringLiteral(componentName))\n      );\n    }\n  }\n\n  // Add a stable attribute for the source file name\n  // Updated condition: add source file for elements that have either:\n  // 1. A component name (root elements), OR\n  // 2. An element name that's not ignored (child elements)\n  if (\n    sourceFileName &&\n    !isAnIgnoredComponent &&\n    (componentName || !isAnIgnoredElement) &&\n    !hasAttributeWithName(openingElement, sourceFileAttributeName)\n  ) {\n    if (sourceFileAttributeName) {\n      openingElement.node.attributes.push(\n        t.jSXAttribute(t.jSXIdentifier(sourceFileAttributeName), t.stringLiteral(sourceFileName))\n      );\n    }\n  }\n}\n\nfunction sourceFileNameFromState(state: AnnotationPluginPass): string | undefined {\n  const name = fullSourceFileNameFromState(state);\n  if (!name) {\n    return undefined;\n  }\n\n  if (name.indexOf(\"/\") !== -1) {\n    return name.split(\"/\").pop();\n  } else if (name.indexOf(\"\\\\\") !== -1) {\n    return name.split(\"\\\\\").pop();\n  } else {\n    return name;\n  }\n}\n\nfunction fullSourceFileNameFromState(state: AnnotationPluginPass): string | null {\n  // @ts-expect-error This type is incorrect in Babel, `sourceFileName` is the correct type\n  const name = state.file.opts.parserOpts?.sourceFileName as unknown;\n\n  if (typeof name === \"string\") {\n    return name;\n  }\n\n  return null;\n}\n\nfunction isKnownIncompatiblePluginFromState(state: AnnotationPluginPass): boolean {\n  const fullSourceFileName = fullSourceFileNameFromState(state);\n\n  if (!fullSourceFileName) {\n    return false;\n  }\n\n  return KNOWN_INCOMPATIBLE_PLUGINS.some((pluginName) => {\n    if (\n      fullSourceFileName.includes(`/node_modules/${pluginName}/`) ||\n      fullSourceFileName.includes(`\\\\node_modules\\\\${pluginName}\\\\`)\n    ) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nfunction attributeNamesFromState(state: AnnotationPluginPass): [string, string, string] {\n  if (state.opts.native) {\n    return [nativeComponentName, nativeElementName, nativeSourceFileName];\n  }\n\n  return [webComponentName, webElementName, webSourceFileName];\n}\n\nfunction collectFragmentContext(programPath: Babel.NodePath): FragmentContext {\n  const fragmentAliases = new Set<string>();\n  const reactNamespaceAliases = new Set<string>([\"React\"]); // Default React namespace\n\n  programPath.traverse({\n    ImportDeclaration(importPath) {\n      const source = importPath.node.source.value;\n\n      // Handle React imports\n      if (source === \"react\" || source === \"React\") {\n        importPath.node.specifiers.forEach((spec) => {\n          if (spec.type === \"ImportSpecifier\" && spec.imported.type === \"Identifier\") {\n            // Detect aliased React.Fragment imports (e.g., `Fragment as F`)\n            // so we can later identify <F> as a fragment in JSX.\n            if (spec.imported.name === \"Fragment\") {\n              fragmentAliases.add(spec.local.name);\n            }\n          } else if (\n            spec.type === \"ImportDefaultSpecifier\" ||\n            spec.type === \"ImportNamespaceSpecifier\"\n          ) {\n            // import React from 'react' -> React OR\n            // import * as React from 'react' -> React\n            reactNamespaceAliases.add(spec.local.name);\n          }\n        });\n      }\n    },\n\n    // Handle simple variable assignments only (avoid complex cases)\n    VariableDeclarator(varPath) {\n      if (varPath.node.init) {\n        const init = varPath.node.init;\n\n        // Handle identifier assignments: const MyFragment = Fragment\n        if (varPath.node.id.type === \"Identifier\") {\n          // Handle: const MyFragment = Fragment (only if Fragment is a known alias)\n          if (init.type === \"Identifier\" && fragmentAliases.has(init.name)) {\n            fragmentAliases.add(varPath.node.id.name);\n          }\n\n          // Handle: const MyFragment = React.Fragment (only for known React namespaces)\n          if (\n            init.type === \"MemberExpression\" &&\n            init.object.type === \"Identifier\" &&\n            init.property.type === \"Identifier\" &&\n            init.property.name === \"Fragment\" &&\n            reactNamespaceAliases.has(init.object.name)\n          ) {\n            fragmentAliases.add(varPath.node.id.name);\n          }\n        }\n\n        // Handle destructuring assignments: const { Fragment } = React\n        if (varPath.node.id.type === \"ObjectPattern\") {\n          if (init.type === \"Identifier\" && reactNamespaceAliases.has(init.name)) {\n            const properties = varPath.node.id.properties;\n\n            for (const prop of properties) {\n              if (\n                prop.type === \"ObjectProperty\" &&\n                prop.key &&\n                prop.key.type === \"Identifier\" &&\n                prop.value &&\n                prop.value.type === \"Identifier\" &&\n                prop.key.name === \"Fragment\"\n              ) {\n                fragmentAliases.add(prop.value.name);\n              }\n            }\n          }\n        }\n      }\n    },\n  });\n\n  return { fragmentAliases, reactNamespaceAliases };\n}\n\nfunction isReactFragment(\n  t: typeof Babel.types,\n  openingElement: Babel.NodePath,\n  context?: FragmentContext // Add this optional parameter\n): boolean {\n  // Handle JSX fragments (<>)\n  if (openingElement.isJSXFragment()) {\n    return true;\n  }\n\n  const elementName = getPathName(t, openingElement);\n\n  // Direct fragment references\n  if (elementName === \"Fragment\" || elementName === \"React.Fragment\") {\n    return true;\n  }\n\n  // TODO: All these objects are typed as unknown, maybe an oversight in Babel types?\n\n  // Check if the element name is a known fragment alias\n  if (context && elementName && context.fragmentAliases.has(elementName)) {\n    return true;\n  }\n\n  // Handle JSXMemberExpression\n  if (\n    openingElement.node &&\n    \"name\" in openingElement.node &&\n    openingElement.node.name &&\n    typeof openingElement.node.name === \"object\" &&\n    \"type\" in openingElement.node.name &&\n    openingElement.node.name.type === \"JSXMemberExpression\"\n  ) {\n    const nodeName = openingElement.node.name;\n    if (typeof nodeName !== \"object\" || !nodeName) {\n      return false;\n    }\n\n    if (\"object\" in nodeName && \"property\" in nodeName) {\n      const nodeNameObject = nodeName.object;\n      const nodeNameProperty = nodeName.property;\n\n      if (typeof nodeNameObject !== \"object\" || typeof nodeNameProperty !== \"object\") {\n        return false;\n      }\n\n      if (!nodeNameObject || !nodeNameProperty) {\n        return false;\n      }\n\n      const objectName = \"name\" in nodeNameObject && nodeNameObject.name;\n      const propertyName = \"name\" in nodeNameProperty && nodeNameProperty.name;\n\n      // React.Fragment check\n      if (objectName === \"React\" && propertyName === \"Fragment\") {\n        return true;\n      }\n\n      // Enhanced checks using context\n      if (context) {\n        // Check React.Fragment pattern with known React namespaces\n        if (\n          context.reactNamespaceAliases.has(objectName as string) &&\n          propertyName === \"Fragment\"\n        ) {\n          return true;\n        }\n\n        // Check MyFragment.Fragment pattern\n        if (context.fragmentAliases.has(objectName as string) && propertyName === \"Fragment\") {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction hasAttributeWithName(\n  openingElement: Babel.NodePath<Babel.types.JSXOpeningElement>,\n  name: string | undefined | null\n): boolean {\n  if (!name) {\n    return false;\n  }\n\n  return openingElement.node.attributes.some((node) => {\n    if (node.type === \"JSXAttribute\") {\n      return node.name.name === name;\n    }\n\n    return false;\n  });\n}\n\nfunction getPathName(t: typeof Babel.types, path: Babel.NodePath): string {\n  if (!path.node) return UNKNOWN_ELEMENT_NAME;\n  if (!(\"name\" in path.node)) {\n    return UNKNOWN_ELEMENT_NAME;\n  }\n\n  const name = path.node.name;\n\n  if (typeof name === \"string\") {\n    return name;\n  }\n\n  if (t.isIdentifier(name) || t.isJSXIdentifier(name)) {\n    return name.name;\n  }\n\n  if (t.isJSXNamespacedName(name)) {\n    return name.name.name;\n  }\n\n  // Handle JSX member expressions like Tab.Group\n  if (t.isJSXMemberExpression(name)) {\n    const objectName = getJSXMemberExpressionObjectName(t, name.object);\n    const propertyName = name.property.name;\n    return `${objectName}.${propertyName}`;\n  }\n\n  return UNKNOWN_ELEMENT_NAME;\n}\n\n// Recursively handle nested member expressions (e.g. Components.UI.Header)\nfunction getJSXMemberExpressionObjectName(\n  t: typeof Babel.types,\n  object: Babel.types.JSXMemberExpression | Babel.types.JSXIdentifier\n): string {\n  if (t.isJSXIdentifier(object)) {\n    return object.name;\n  }\n  if (t.isJSXMemberExpression(object)) {\n    const objectName = getJSXMemberExpressionObjectName(t, object.object);\n    return `${objectName}.${object.property.name}`;\n  }\n\n  return UNKNOWN_ELEMENT_NAME;\n}\n\nconst UNKNOWN_ELEMENT_NAME = \"unknown\";\n"],"names":["KNOWN_INCOMPATIBLE_PLUGINS","DEFAULT_IGNORED_ELEMENTS","REACT_NATIVE_ELEMENTS","experimentalComponentNameAnnotatePlugin","_ref","t","types","visitor","Program","enter","path","state","fragmentContext","collectFragmentContext","sentryFragmentContext","FunctionDeclaration","node","id","name","context","createJSXProcessingContext","functionBodyPushAttributes","ArrowFunctionExpression","parent","ClassDeclaration","_name$node","get","properties","render","find","prop","isClassMethod","isIdentifier","traverse","ReturnStatement","returnStatement","arg","isJSXElement","isJSXFragment","processJSX","isHtmlElement","elementName","UNKNOWN_ELEMENT_NAME","length","charAt","toLowerCase","includes","componentName","_state$opts$ignoredCo","attributeName","attributeNamesFromState","ignoredComponents","opts","jsxNode","functionBody","type","maybeJsxNode","c","Array","isArray","isConditionalExpression","consequent","alternate","paths","openingElements","hasInjectedAttributes","reduce","prev","openingElement","applyAttributes","children","forEach","child","componentAttributeName","isFragment","isReactFragment","attributes","getPathName","isAnIgnoredComponent","some","ignoredComponent","hasAttributeWithName","push","jSXAttribute","jSXIdentifier","stringLiteral","programPath","fragmentAliases","Set","reactNamespaceAliases","ImportDeclaration","importPath","source","value","specifiers","spec","imported","add","local","VariableDeclarator","varPath","init","has","object","property","_iterator","_createForOfIteratorHelper","_step","s","n","done","key","err","e","f","_typeof","nodeName","nodeNameObject","nodeNameProperty","objectName","propertyName","isJSXIdentifier","isJSXNamespacedName","isJSXMemberExpression","getJSXMemberExpressionObjectName","concat","webComponentName","webElementName","webSourceFileName","nativeComponentName","nativeElementName","nativeSourceFileName","componentNameAnnotatePlugin","isKnownIncompatiblePluginFromState","annotateFragments","sourceFileName","sourceFileNameFromState","attributeNames","currentComponentName","shouldSetComponentName","_attributeNames","_slicedToArray","elementAttributeName","sourceFileAttributeName","isAnIgnoredElement","fullSourceFileNameFromState","undefined","indexOf","split","pop","_state$file$opts$pars","file","parserOpts","fullSourceFileName","pluginName"],"mappings":"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"}