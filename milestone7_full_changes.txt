### /Users/umutugur/finsight/packages/shared/src/schemas.ts
import { z } from 'zod';

const emailSchema = z.string().trim().email().max(320);
const passwordSchema = z.string().min(8).max(128);
const currencySchema = z
  .string()
  .trim()
  .toUpperCase()
  .regex(/^[A-Z]{3}$/, 'Currency must be a 3-letter ISO code');
const monthStringSchema = z
  .string()
  .trim()
  .regex(/^\d{4}-(0[1-9]|1[0-2])$/, 'Month must be YYYY-MM');
const dateTimeStringSchema = z
  .string()
  .refine((value) => !Number.isNaN(Date.parse(value)), 'Invalid datetime');

export const healthResponseSchema = z.object({
  ok: z.literal(true),
  name: z.literal('FinSight API'),
});

export const registerInputSchema = z.object({
  email: emailSchema,
  password: passwordSchema,
  name: z.string().trim().min(1).max(120).optional(),
});

export const loginInputSchema = z.object({
  email: emailSchema,
  password: z.string().min(1).max(128),
});

export const refreshInputSchema = z.object({
  refreshToken: z.string().min(1),
});

export const logoutInputSchema = z.object({
  refreshToken: z.string().min(1),
});

export const authUserSchema = z.object({
  id: z.string().min(1),
  email: emailSchema,
  name: z.string().nullable(),
});

export const authResponseSchema = z.object({
  accessToken: z.string().min(1),
  refreshToken: z.string().min(1),
  user: authUserSchema,
});

export const meResponseSchema = z.object({
  user: authUserSchema.extend({
    baseCurrency: currencySchema.nullable(),
  }),
});

export const logoutResponseSchema = z.object({
  ok: z.literal(true),
});

export const accountTypeSchema = z.enum(['cash', 'bank', 'credit']);
export const categoryTypeSchema = z.enum(['income', 'expense']);
export const transactionTypeSchema = z.enum(['income', 'expense']);
export const transactionKindSchema = z.enum(['normal', 'transfer']);
export const transferDirectionSchema = z.enum(['out', 'in']);
export const recurringCadenceSchema = z.enum(['weekly', 'monthly']);
export const recurringKindSchema = z.enum(['normal', 'transfer']);

export const accountSchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1).max(120),
  type: accountTypeSchema,
  currency: currencySchema,
  createdAt: dateTimeStringSchema,
  updatedAt: dateTimeStringSchema,
});

export const accountListResponseSchema = z.object({
  accounts: z.array(accountSchema),
});

export const accountCreateInputSchema = z.object({
  name: z.string().trim().min(1).max(120),
  type: accountTypeSchema,
  currency: currencySchema,
});

export const accountUpdateInputSchema = z
  .object({
    name: z.string().trim().min(1).max(120).optional(),
    type: accountTypeSchema.optional(),
    currency: currencySchema.optional(),
  })
  .refine((value) => Object.keys(value).length > 0, {
    message: 'At least one field must be provided',
  });

export const categorySchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1).max(120),
  type: categoryTypeSchema,
  color: z.string().regex(/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/, 'Invalid color hex'),
  icon: z.string().min(1).max(64).nullable(),
  isSystem: z.boolean(),
  createdAt: dateTimeStringSchema,
  updatedAt: dateTimeStringSchema,
});

export const categoryListResponseSchema = z.object({
  categories: z.array(categorySchema),
});

export const categoryCreateInputSchema = z.object({
  name: z.string().trim().min(1).max(120),
  type: categoryTypeSchema,
  color: z.string().regex(/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/, 'Invalid color hex'),
  icon: z.string().trim().min(1).max(64).optional(),
});

export const transactionSchema = z.object({
  id: z.string().min(1),
  accountId: z.string().min(1),
  categoryId: z.string().min(1).nullable(),
  type: transactionTypeSchema,
  kind: transactionKindSchema,
  transferGroupId: z.string().min(1).nullable(),
  transferDirection: transferDirectionSchema.nullable(),
  relatedAccountId: z.string().min(1).nullable(),
  amount: z.number().positive(),
  currency: currencySchema,
  description: z.string().max(500).nullable(),
  occurredAt: dateTimeStringSchema,
  createdAt: dateTimeStringSchema,
  updatedAt: dateTimeStringSchema,
});

export const transactionCreateInputSchema = z.object({
  accountId: z.string().trim().min(1),
  categoryId: z.string().trim().min(1),
  type: transactionTypeSchema,
  amount: z.number().positive(),
  currency: currencySchema,
  description: z.string().trim().max(500).optional(),
  occurredAt: dateTimeStringSchema,
});

export const transactionUpdateInputSchema = z
  .object({
    accountId: z.string().trim().min(1).optional(),
    categoryId: z.string().trim().min(1).optional(),
    type: transactionTypeSchema.optional(),
    amount: z.number().positive().optional(),
    currency: currencySchema.optional(),
    description: z.string().trim().max(500).nullable().optional(),
    occurredAt: dateTimeStringSchema.optional(),
  })
  .refine((value) => Object.keys(value).length > 0, {
    message: 'At least one field must be provided',
  });

export const transactionListQuerySchema = z
  .object({
    page: z.coerce.number().int().min(1).default(1),
    limit: z.coerce.number().int().min(1).max(100).default(20),
    accountId: z.string().trim().min(1).optional(),
    categoryId: z.string().trim().min(1).optional(),
    type: transactionTypeSchema.optional(),
    kind: transactionKindSchema.optional(),
    currency: currencySchema.optional(),
    from: dateTimeStringSchema.optional(),
    to: dateTimeStringSchema.optional(),
    search: z.string().trim().min(1).max(120).optional(),
    includeDeleted: z.coerce.boolean().default(false),
  })
  .refine(
    (value) => {
      if (!value.from || !value.to) {
        return true;
      }

      return new Date(value.from).getTime() <= new Date(value.to).getTime();
    },
    {
      message: '`from` must be less than or equal to `to`',
      path: ['from'],
    },
  );

export const transactionListResponseSchema = z.object({
  transactions: z.array(transactionSchema),
  pagination: z.object({
    page: z.number().int().min(1),
    limit: z.number().int().min(1),
    total: z.number().int().min(0),
    totalPages: z.number().int().min(0),
  }),
});

export const accountBalanceSchema = z.object({
  accountId: z.string().min(1),
  name: z.string().min(1).max(120),
  type: accountTypeSchema,
  currency: currencySchema,
  balance: z.number(),
});

export const dashboardRecentResponseSchema = z.object({
  recentTransactions: z.array(transactionSchema),
  totalBalance: z.number(),
  balances: z.array(accountBalanceSchema),
});

export const transferCreateInputSchema = z
  .object({
    fromAccountId: z.string().trim().min(1),
    toAccountId: z.string().trim().min(1),
    amount: z.number().positive(),
    occurredAt: dateTimeStringSchema,
    description: z.string().trim().max(500).optional(),
  })
  .refine((value) => value.fromAccountId !== value.toAccountId, {
    message: '`fromAccountId` and `toAccountId` must differ',
    path: ['toAccountId'],
  });

export const transferCreateResponseSchema = z.object({
  groupId: z.string().min(1),
  fromTransactionId: z.string().min(1),
  toTransactionId: z.string().min(1),
});

export const analyticsSummaryQuerySchema = z.object({
  month: monthStringSchema,
});

export const analyticsTopCategorySchema = z.object({
  categoryId: z.string().min(1),
  name: z.string().min(1).max(120),
  type: categoryTypeSchema,
  total: z.number().min(0),
  percent: z.number().min(0),
});

export const analyticsSummaryResponseSchema = z.object({
  month: monthStringSchema,
  currency: currencySchema.nullable(),
  incomeTotal: z.number().min(0),
  expenseTotal: z.number().min(0),
  netTotal: z.number(),
  transactionCount: z.number().int().min(0),
  topCategories: z.array(analyticsTopCategorySchema),
});

export const analyticsByCategoryQuerySchema = z.object({
  month: monthStringSchema,
  type: categoryTypeSchema,
});

export const analyticsByCategoryItemSchema = z.object({
  categoryId: z.string().min(1),
  name: z.string().min(1).max(120),
  total: z.number().min(0),
  count: z.number().int().min(0),
});

export const analyticsByCategoryResponseSchema = z.object({
  month: monthStringSchema,
  type: categoryTypeSchema,
  currency: currencySchema.nullable(),
  categories: z.array(analyticsByCategoryItemSchema),
});

export const analyticsTrendQuerySchema = z
  .object({
    from: monthStringSchema,
    to: monthStringSchema,
  })
  .refine((value) => value.from <= value.to, {
    message: '`from` must be less than or equal to `to`',
    path: ['from'],
  });

export const analyticsTrendPointSchema = z.object({
  month: monthStringSchema,
  incomeTotal: z.number().min(0),
  expenseTotal: z.number().min(0),
  netTotal: z.number(),
});

export const analyticsTrendResponseSchema = z.object({
  currency: currencySchema.nullable(),
  points: z.array(analyticsTrendPointSchema),
});

export const budgetSchema = z.object({
  id: z.string().min(1),
  categoryId: z.string().min(1),
  month: monthStringSchema,
  limitAmount: z.number().positive(),
  createdAt: dateTimeStringSchema,
  updatedAt: dateTimeStringSchema,
});

export const budgetListQuerySchema = z.object({
  month: monthStringSchema,
  includeDeleted: z.coerce.boolean().default(false),
});

export const budgetListItemSchema = z.object({
  id: z.string().min(1),
  categoryId: z.string().min(1),
  categoryName: z.string().min(1).max(120),
  month: monthStringSchema,
  limitAmount: z.number().positive(),
  spentAmount: z.number().min(0),
  remainingAmount: z.number(),
  percentUsed: z.number().min(0),
});

export const budgetListResponseSchema = z.object({
  budgets: z.array(budgetListItemSchema),
});

export const budgetCreateInputSchema = z.object({
  categoryId: z.string().trim().min(1),
  month: monthStringSchema,
  limitAmount: z.number().positive(),
});

export const budgetUpdateInputSchema = z.object({
  limitAmount: z.number().positive(),
});

export const recurringRuleSchema = z.object({
  id: z.string().min(1),
  kind: recurringKindSchema,
  accountId: z.string().min(1).nullable(),
  categoryId: z.string().min(1).nullable(),
  type: transactionTypeSchema.nullable(),
  fromAccountId: z.string().min(1).nullable(),
  toAccountId: z.string().min(1).nullable(),
  amount: z.number().positive(),
  description: z.string().max(500).nullable(),
  cadence: recurringCadenceSchema,
  dayOfWeek: z.number().int().min(0).max(6).nullable(),
  dayOfMonth: z.number().int().min(1).max(28).nullable(),
  startAt: dateTimeStringSchema,
  endAt: dateTimeStringSchema.nullable(),
  nextRunAt: dateTimeStringSchema,
  lastRunAt: dateTimeStringSchema.nullable(),
  isPaused: z.boolean(),
  deletedAt: dateTimeStringSchema.nullable(),
  createdAt: dateTimeStringSchema,
  updatedAt: dateTimeStringSchema,
});

const recurringScheduleFieldsSchema = z
  .object({
    cadence: recurringCadenceSchema,
    dayOfWeek: z.number().int().min(0).max(6).optional(),
    dayOfMonth: z.number().int().min(1).max(28).optional(),
  })
  .superRefine((value, ctx) => {
    if (value.cadence === 'weekly') {
      if (value.dayOfWeek === undefined) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: '`dayOfWeek` is required for weekly cadence',
          path: ['dayOfWeek'],
        });
      }
      return;
    }

    if (value.dayOfMonth === undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: '`dayOfMonth` is required for monthly cadence',
        path: ['dayOfMonth'],
      });
    }
  });

const recurringBaseCreateSchema = z.object({
  cadence: recurringCadenceSchema,
  dayOfWeek: z.number().int().min(0).max(6).optional(),
  dayOfMonth: z.number().int().min(1).max(28).optional(),
  startAt: dateTimeStringSchema,
  endAt: dateTimeStringSchema.optional(),
  amount: z.number().positive(),
  description: z.string().trim().max(500).optional(),
});

export const recurringCreateInputSchema = z
  .discriminatedUnion('kind', [
    recurringBaseCreateSchema.extend({
      kind: z.literal('normal'),
      accountId: z.string().trim().min(1),
      categoryId: z.string().trim().min(1),
      type: transactionTypeSchema,
    }),
    recurringBaseCreateSchema.extend({
      kind: z.literal('transfer'),
      fromAccountId: z.string().trim().min(1),
      toAccountId: z.string().trim().min(1),
    }),
  ])
  .and(recurringScheduleFieldsSchema);

export const recurringUpdateInputSchema = z
  .object({
    amount: z.number().positive().optional(),
    description: z.string().trim().max(500).nullable().optional(),
    isPaused: z.boolean().optional(),
    cadence: recurringCadenceSchema.optional(),
    dayOfWeek: z.number().int().min(0).max(6).optional(),
    dayOfMonth: z.number().int().min(1).max(28).optional(),
    endAt: dateTimeStringSchema.nullable().optional(),
  })
  .refine((value) => Object.keys(value).length > 0, {
    message: 'At least one field must be provided',
  })
  .superRefine((value, ctx) => {
    const cadence = value.cadence;
    if (cadence === 'weekly' && value.dayOfWeek === undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: '`dayOfWeek` is required when setting weekly cadence',
        path: ['dayOfWeek'],
      });
    }
    if (cadence === 'monthly' && value.dayOfMonth === undefined) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: '`dayOfMonth` is required when setting monthly cadence',
        path: ['dayOfMonth'],
      });
    }
  });

export const recurringListQuerySchema = z.object({
  month: monthStringSchema.optional(),
  includeDeleted: z.coerce.boolean().default(false),
});

export const recurringListResponseSchema = z.object({
  rules: z.array(recurringRuleSchema),
});

export const recurringRunDueResponseSchema = z.object({
  processedRules: z.number().int().min(0),
  processedRuns: z.number().int().min(0),
  generatedTransactions: z.number().int().min(0),
});

export const exportTransactionsQuerySchema = z
  .object({
    from: dateTimeStringSchema.optional(),
    to: dateTimeStringSchema.optional(),
    accountId: z.string().trim().min(1).optional(),
    type: transactionTypeSchema.optional(),
    kind: transactionKindSchema.optional(),
  })
  .refine(
    (value) => {
      if (!value.from || !value.to) {
        return true;
      }
      return new Date(value.from).getTime() <= new Date(value.to).getTime();
    },
    {
      message: '`from` must be less than or equal to `to`',
      path: ['from'],
    },
  );

export const exportTransactionsCsvResponseSchema = z.string();

export const apiErrorSchema = z.object({
  error: z.object({
    code: z.string(),
    message: z.string(),
    details: z.unknown().optional(),
  }),
});

export type HealthResponse = z.infer<typeof healthResponseSchema>;
export type RegisterInput = z.infer<typeof registerInputSchema>;
export type LoginInput = z.infer<typeof loginInputSchema>;
export type RefreshInput = z.infer<typeof refreshInputSchema>;
export type LogoutInput = z.infer<typeof logoutInputSchema>;
export type AuthUser = z.infer<typeof authUserSchema>;
export type AuthResponse = z.infer<typeof authResponseSchema>;
export type MeResponse = z.infer<typeof meResponseSchema>;
export type LogoutResponse = z.infer<typeof logoutResponseSchema>;
export type AccountType = z.infer<typeof accountTypeSchema>;
export type CategoryType = z.infer<typeof categoryTypeSchema>;
export type TransactionType = z.infer<typeof transactionTypeSchema>;
export type TransactionKind = z.infer<typeof transactionKindSchema>;
export type TransferDirection = z.infer<typeof transferDirectionSchema>;
export type RecurringCadence = z.infer<typeof recurringCadenceSchema>;
export type RecurringKind = z.infer<typeof recurringKindSchema>;
export type Account = z.infer<typeof accountSchema>;
export type AccountListResponse = z.infer<typeof accountListResponseSchema>;
export type AccountCreateInput = z.infer<typeof accountCreateInputSchema>;
export type AccountUpdateInput = z.infer<typeof accountUpdateInputSchema>;
export type Category = z.infer<typeof categorySchema>;
export type CategoryListResponse = z.infer<typeof categoryListResponseSchema>;
export type CategoryCreateInput = z.infer<typeof categoryCreateInputSchema>;
export type Transaction = z.infer<typeof transactionSchema>;
export type TransactionCreateInput = z.infer<typeof transactionCreateInputSchema>;
export type TransactionUpdateInput = z.infer<typeof transactionUpdateInputSchema>;
export type TransactionListQuery = z.infer<typeof transactionListQuerySchema>;
export type TransactionListResponse = z.infer<typeof transactionListResponseSchema>;
export type AccountBalance = z.infer<typeof accountBalanceSchema>;
export type DashboardRecentResponse = z.infer<typeof dashboardRecentResponseSchema>;
export type TransferCreateInput = z.infer<typeof transferCreateInputSchema>;
export type TransferCreateResponse = z.infer<typeof transferCreateResponseSchema>;
export type AnalyticsSummaryQuery = z.infer<typeof analyticsSummaryQuerySchema>;
export type AnalyticsTopCategory = z.infer<typeof analyticsTopCategorySchema>;
export type AnalyticsSummaryResponse = z.infer<typeof analyticsSummaryResponseSchema>;
export type AnalyticsByCategoryQuery = z.infer<typeof analyticsByCategoryQuerySchema>;
export type AnalyticsByCategoryItem = z.infer<typeof analyticsByCategoryItemSchema>;
export type AnalyticsByCategoryResponse = z.infer<typeof analyticsByCategoryResponseSchema>;
export type AnalyticsTrendQuery = z.infer<typeof analyticsTrendQuerySchema>;
export type AnalyticsTrendPoint = z.infer<typeof analyticsTrendPointSchema>;
export type AnalyticsTrendResponse = z.infer<typeof analyticsTrendResponseSchema>;
export type Budget = z.infer<typeof budgetSchema>;
export type BudgetListQuery = z.infer<typeof budgetListQuerySchema>;
export type BudgetListItem = z.infer<typeof budgetListItemSchema>;
export type BudgetListResponse = z.infer<typeof budgetListResponseSchema>;
export type BudgetCreateInput = z.infer<typeof budgetCreateInputSchema>;
export type BudgetUpdateInput = z.infer<typeof budgetUpdateInputSchema>;
export type RecurringRule = z.infer<typeof recurringRuleSchema>;
export type RecurringCreateInput = z.infer<typeof recurringCreateInputSchema>;
export type RecurringUpdateInput = z.infer<typeof recurringUpdateInputSchema>;
export type RecurringListQuery = z.infer<typeof recurringListQuerySchema>;
export type RecurringListResponse = z.infer<typeof recurringListResponseSchema>;
export type RecurringRunDueResponse = z.infer<typeof recurringRunDueResponseSchema>;
export type ExportTransactionsQuery = z.infer<typeof exportTransactionsQuerySchema>;
export type ExportTransactionsCsvResponse = z.infer<typeof exportTransactionsCsvResponseSchema>;
export type ApiErrorResponse = z.infer<typeof apiErrorSchema>;

### /Users/umutugur/finsight/packages/shared/src/index.ts
export {
  ApiClient,
  ApiClientError,
  createApiClient,
  normalizeApiError,
  type NormalizedApiError,
} from './client';
export {
  accountBalanceSchema,
  accountCreateInputSchema,
  accountListResponseSchema,
  accountSchema,
  accountTypeSchema,
  accountUpdateInputSchema,
  analyticsByCategoryItemSchema,
  analyticsByCategoryQuerySchema,
  analyticsByCategoryResponseSchema,
  analyticsSummaryQuerySchema,
  analyticsSummaryResponseSchema,
  analyticsTopCategorySchema,
  analyticsTrendPointSchema,
  analyticsTrendQuerySchema,
  analyticsTrendResponseSchema,
  apiErrorSchema,
  authResponseSchema,
  authUserSchema,
  budgetCreateInputSchema,
  budgetListItemSchema,
  budgetListQuerySchema,
  budgetListResponseSchema,
  budgetSchema,
  budgetUpdateInputSchema,
  categoryCreateInputSchema,
  categoryListResponseSchema,
  categorySchema,
  categoryTypeSchema,
  dashboardRecentResponseSchema,
  exportTransactionsCsvResponseSchema,
  exportTransactionsQuerySchema,
  healthResponseSchema,
  loginInputSchema,
  logoutInputSchema,
  logoutResponseSchema,
  meResponseSchema,
  recurringCadenceSchema,
  recurringCreateInputSchema,
  recurringKindSchema,
  recurringListQuerySchema,
  recurringListResponseSchema,
  recurringRuleSchema,
  recurringRunDueResponseSchema,
  recurringUpdateInputSchema,
  refreshInputSchema,
  registerInputSchema,
  transferCreateInputSchema,
  transferCreateResponseSchema,
  transferDirectionSchema,
  transactionCreateInputSchema,
  transactionKindSchema,
  transactionListQuerySchema,
  transactionListResponseSchema,
  transactionSchema,
  transactionTypeSchema,
  transactionUpdateInputSchema,
} from './schemas';
export type {
  Account,
  AccountBalance,
  AccountCreateInput,
  AccountListResponse,
  AccountType,
  AccountUpdateInput,
  AnalyticsByCategoryItem,
  AnalyticsByCategoryQuery,
  AnalyticsByCategoryResponse,
  AnalyticsSummaryQuery,
  AnalyticsSummaryResponse,
  AnalyticsTopCategory,
  AnalyticsTrendPoint,
  AnalyticsTrendQuery,
  AnalyticsTrendResponse,
  ApiErrorResponse,
  AuthResponse,
  AuthUser,
  Budget,
  BudgetCreateInput,
  BudgetListItem,
  BudgetListQuery,
  BudgetListResponse,
  BudgetUpdateInput,
  Category,
  CategoryCreateInput,
  CategoryListResponse,
  CategoryType,
  DashboardRecentResponse,
  ExportTransactionsCsvResponse,
  ExportTransactionsQuery,
  HealthResponse,
  LoginInput,
  LogoutInput,
  LogoutResponse,
  MeResponse,
  RecurringCadence,
  RecurringCreateInput,
  RecurringKind,
  RecurringListQuery,
  RecurringListResponse,
  RecurringRule,
  RecurringRunDueResponse,
  RecurringUpdateInput,
  RefreshInput,
  RegisterInput,
  TransferCreateInput,
  TransferCreateResponse,
  TransferDirection,
  Transaction,
  TransactionCreateInput,
  TransactionKind,
  TransactionListQuery,
  TransactionListResponse,
  TransactionType,
  TransactionUpdateInput,
} from './schemas';

### /Users/umutugur/finsight/packages/shared/src/client.ts
import { z } from 'zod';

import {
  accountCreateInputSchema,
  accountListResponseSchema,
  accountSchema,
  accountUpdateInputSchema,
  analyticsByCategoryQuerySchema,
  analyticsByCategoryResponseSchema,
  analyticsSummaryQuerySchema,
  analyticsSummaryResponseSchema,
  analyticsTrendQuerySchema,
  analyticsTrendResponseSchema,
  apiErrorSchema,
  authResponseSchema,
  budgetCreateInputSchema,
  budgetListQuerySchema,
  budgetListResponseSchema,
  budgetSchema,
  budgetUpdateInputSchema,
  categoryCreateInputSchema,
  categoryListResponseSchema,
  categorySchema,
  dashboardRecentResponseSchema,
  exportTransactionsCsvResponseSchema,
  exportTransactionsQuerySchema,
  healthResponseSchema,
  logoutResponseSchema,
  meResponseSchema,
  recurringCreateInputSchema,
  recurringListQuerySchema,
  recurringListResponseSchema,
  recurringRuleSchema,
  recurringRunDueResponseSchema,
  recurringUpdateInputSchema,
  transferCreateInputSchema,
  transferCreateResponseSchema,
  transactionCreateInputSchema,
  transactionListQuerySchema,
  transactionListResponseSchema,
  transactionSchema,
  transactionUpdateInputSchema,
  type Account,
  type AccountCreateInput,
  type AccountListResponse,
  type AccountUpdateInput,
  type AnalyticsByCategoryQuery,
  type AnalyticsByCategoryResponse,
  type AnalyticsSummaryQuery,
  type AnalyticsSummaryResponse,
  type AnalyticsTrendQuery,
  type AnalyticsTrendResponse,
  type AuthResponse,
  type Budget,
  type BudgetCreateInput,
  type BudgetListQuery,
  type BudgetListResponse,
  type BudgetUpdateInput,
  type Category,
  type CategoryCreateInput,
  type CategoryListResponse,
  type DashboardRecentResponse,
  type ExportTransactionsCsvResponse,
  type ExportTransactionsQuery,
  type HealthResponse,
  type LoginInput,
  type LogoutInput,
  type MeResponse,
  type RecurringCreateInput,
  type RecurringListQuery,
  type RecurringListResponse,
  type RecurringRule,
  type RecurringRunDueResponse,
  type RecurringUpdateInput,
  type RefreshInput,
  type RegisterInput,
  type TransferCreateInput,
  type TransferCreateResponse,
  type Transaction,
  type TransactionCreateInput,
  type TransactionListQuery,
  type TransactionListResponse,
  type TransactionUpdateInput,
} from './schemas';

type FetchLike = (input: string, init?: RequestInit) => Promise<Response>;

export interface ApiClientOptions {
  baseUrl?: string;
  fetchImpl?: FetchLike;
}

export interface NormalizedApiError {
  code: string;
  message: string;
  details?: unknown;
  status?: number;
}

interface RequestOptions {
  method?: 'GET' | 'POST' | 'PATCH' | 'DELETE';
  body?: unknown;
  accessToken?: string;
  query?: Record<string, unknown>;
}

export class ApiClientError extends Error {
  public readonly code: string;
  public readonly details?: unknown;
  public readonly status: number;

  constructor(params: { code: string; message: string; status: number; details?: unknown }) {
    super(params.message);
    this.code = params.code;
    this.details = params.details;
    this.status = params.status;
    this.name = 'ApiClientError';
  }
}

type ProcessLike = {
  env?: Record<string, string | undefined>;
};

function readEnv(): Record<string, string | undefined> {
  const processLike = (globalThis as { process?: ProcessLike }).process;
  return processLike?.env ?? {};
}

function trimTrailingSlash(value: string): string {
  return value.replace(/\/+$/, '');
}

function resolveBaseUrl(baseUrl?: string): string {
  if (baseUrl && baseUrl.trim()) {
    return trimTrailingSlash(baseUrl.trim());
  }

  const env = readEnv();
  const resolved = env.EXPO_PUBLIC_API_BASE_URL ?? env.API_BASE_URL ?? 'http://localhost:4000';
  return trimTrailingSlash(resolved);
}

async function readPayload(response: Response): Promise<unknown> {
  const text = await response.text();
  if (!text) {
    return null;
  }

  try {
    return JSON.parse(text);
  } catch {
    return text;
  }
}

function parseApiError(response: Response, payload: unknown): ApiClientError {
  const parsed = apiErrorSchema.safeParse(payload);

  if (parsed.success) {
    return new ApiClientError({
      code: parsed.data.error.code,
      message: parsed.data.error.message,
      details: parsed.data.error.details,
      status: response.status,
    });
  }

  return new ApiClientError({
    code: 'API_REQUEST_FAILED',
    message: `Request failed with status ${response.status}`,
    details: payload,
    status: response.status,
  });
}

function buildPathWithQuery(path: string, query?: Record<string, unknown>): string {
  if (!query) {
    return path;
  }

  const searchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(query)) {
    if (value === undefined || value === null) {
      continue;
    }

    if (Array.isArray(value)) {
      for (const entry of value) {
        searchParams.append(key, String(entry));
      }
      continue;
    }

    searchParams.append(key, String(value));
  }

  const queryString = searchParams.toString();
  if (!queryString) {
    return path;
  }

  return `${path}?${queryString}`;
}

export function normalizeApiError(error: unknown): NormalizedApiError {
  if (error instanceof ApiClientError) {
    return {
      code: error.code,
      message: error.message,
      details: error.details,
      status: error.status,
    };
  }

  if (error instanceof Error) {
    return {
      code: 'UNKNOWN_ERROR',
      message: error.message,
    };
  }

  return {
    code: 'UNKNOWN_ERROR',
    message: 'Unexpected error',
  };
}

export class ApiClient {
  private readonly baseUrl: string;
  private readonly fetchImpl: FetchLike;

  constructor(options: ApiClientOptions = {}) {
    this.baseUrl = resolveBaseUrl(options.baseUrl);
    this.fetchImpl = options.fetchImpl ?? ((input, init) => fetch(input, init));
  }

  async getHealth(): Promise<HealthResponse> {
    return this.request('/health', healthResponseSchema);
  }

  async register(input: RegisterInput): Promise<AuthResponse> {
    return this.request('/auth/register', authResponseSchema, {
      method: 'POST',
      body: input,
    });
  }

  async login(input: LoginInput): Promise<AuthResponse> {
    return this.request('/auth/login', authResponseSchema, {
      method: 'POST',
      body: input,
    });
  }

  async refresh(input: RefreshInput): Promise<AuthResponse> {
    return this.request('/auth/refresh', authResponseSchema, {
      method: 'POST',
      body: input,
    });
  }

  async logout(input: LogoutInput): Promise<void> {
    await this.request('/auth/logout', logoutResponseSchema, {
      method: 'POST',
      body: input,
    });
  }

  async getMe(accessToken: string): Promise<MeResponse> {
    return this.request('/me', meResponseSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async getAccounts(accessToken: string): Promise<AccountListResponse> {
    return this.request('/accounts', accountListResponseSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async createAccount(input: AccountCreateInput, accessToken: string): Promise<Account> {
    return this.request('/accounts', accountSchema, {
      method: 'POST',
      accessToken,
      body: accountCreateInputSchema.parse(input),
    });
  }

  async updateAccount(id: string, input: AccountUpdateInput, accessToken: string): Promise<Account> {
    return this.request(`/accounts/${encodeURIComponent(id)}`, accountSchema, {
      method: 'PATCH',
      accessToken,
      body: accountUpdateInputSchema.parse(input),
    });
  }

  async deleteAccount(id: string, accessToken: string): Promise<void> {
    await this.request(`/accounts/${encodeURIComponent(id)}`, logoutResponseSchema, {
      method: 'DELETE',
      accessToken,
    });
  }

  async getCategories(accessToken: string): Promise<CategoryListResponse> {
    return this.request('/categories', categoryListResponseSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async createCategory(input: CategoryCreateInput, accessToken: string): Promise<Category> {
    return this.request('/categories', categorySchema, {
      method: 'POST',
      accessToken,
      body: categoryCreateInputSchema.parse(input),
    });
  }

  async listTransactions(
    query: Partial<TransactionListQuery> = {},
    accessToken: string,
  ): Promise<TransactionListResponse> {
    return this.request('/transactions', transactionListResponseSchema, {
      method: 'GET',
      accessToken,
      query: transactionListQuerySchema.parse(query),
    });
  }

  async createTransfer(input: TransferCreateInput, accessToken: string): Promise<TransferCreateResponse> {
    return this.request('/transfers', transferCreateResponseSchema, {
      method: 'POST',
      accessToken,
      body: transferCreateInputSchema.parse(input),
    });
  }

  async createTransaction(input: TransactionCreateInput, accessToken: string): Promise<Transaction> {
    return this.request('/transactions', transactionSchema, {
      method: 'POST',
      accessToken,
      body: transactionCreateInputSchema.parse(input),
    });
  }

  async getTransaction(id: string, accessToken: string): Promise<Transaction> {
    return this.request(`/transactions/${encodeURIComponent(id)}`, transactionSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async updateTransaction(
    id: string,
    input: TransactionUpdateInput,
    accessToken: string,
  ): Promise<Transaction> {
    return this.request(`/transactions/${encodeURIComponent(id)}`, transactionSchema, {
      method: 'PATCH',
      accessToken,
      body: transactionUpdateInputSchema.parse(input),
    });
  }

  async deleteTransaction(id: string, accessToken: string): Promise<void> {
    await this.request(`/transactions/${encodeURIComponent(id)}`, logoutResponseSchema, {
      method: 'DELETE',
      accessToken,
    });
  }

  async getDashboardRecent(accessToken: string): Promise<DashboardRecentResponse> {
    return this.request('/dashboard/recent', dashboardRecentResponseSchema, {
      method: 'GET',
      accessToken,
    });
  }

  async getAnalyticsSummary(
    query: AnalyticsSummaryQuery,
    accessToken: string,
  ): Promise<AnalyticsSummaryResponse> {
    return this.request('/analytics/summary', analyticsSummaryResponseSchema, {
      method: 'GET',
      accessToken,
      query: analyticsSummaryQuerySchema.parse(query),
    });
  }

  async getAnalyticsByCategory(
    query: AnalyticsByCategoryQuery,
    accessToken: string,
  ): Promise<AnalyticsByCategoryResponse> {
    return this.request('/analytics/by-category', analyticsByCategoryResponseSchema, {
      method: 'GET',
      accessToken,
      query: analyticsByCategoryQuerySchema.parse(query),
    });
  }

  async getAnalyticsTrend(query: AnalyticsTrendQuery, accessToken: string): Promise<AnalyticsTrendResponse> {
    return this.request('/analytics/trend', analyticsTrendResponseSchema, {
      method: 'GET',
      accessToken,
      query: analyticsTrendQuerySchema.parse(query),
    });
  }

  async listBudgets(
    query: Partial<BudgetListQuery> = {},
    accessToken: string,
  ): Promise<BudgetListResponse> {
    return this.request('/budgets', budgetListResponseSchema, {
      method: 'GET',
      accessToken,
      query: budgetListQuerySchema.parse(query),
    });
  }

  async createBudget(input: BudgetCreateInput, accessToken: string): Promise<Budget> {
    return this.request('/budgets', budgetSchema, {
      method: 'POST',
      accessToken,
      body: budgetCreateInputSchema.parse(input),
    });
  }

  async updateBudget(id: string, input: BudgetUpdateInput, accessToken: string): Promise<Budget> {
    return this.request(`/budgets/${encodeURIComponent(id)}`, budgetSchema, {
      method: 'PATCH',
      accessToken,
      body: budgetUpdateInputSchema.parse(input),
    });
  }

  async deleteBudget(id: string, accessToken: string): Promise<void> {
    await this.request(`/budgets/${encodeURIComponent(id)}`, logoutResponseSchema, {
      method: 'DELETE',
      accessToken,
    });
  }

  async listRecurring(
    query: Partial<RecurringListQuery> = {},
    accessToken: string,
  ): Promise<RecurringListResponse> {
    return this.request('/recurring', recurringListResponseSchema, {
      method: 'GET',
      accessToken,
      query: recurringListQuerySchema.parse(query),
    });
  }

  async createRecurring(input: RecurringCreateInput, accessToken: string): Promise<RecurringRule> {
    return this.request('/recurring', recurringRuleSchema, {
      method: 'POST',
      accessToken,
      body: recurringCreateInputSchema.parse(input),
    });
  }

  async updateRecurring(
    id: string,
    input: RecurringUpdateInput,
    accessToken: string,
  ): Promise<RecurringRule> {
    return this.request(`/recurring/${encodeURIComponent(id)}`, recurringRuleSchema, {
      method: 'PATCH',
      accessToken,
      body: recurringUpdateInputSchema.parse(input),
    });
  }

  async deleteRecurring(id: string, accessToken: string): Promise<void> {
    await this.request(`/recurring/${encodeURIComponent(id)}`, logoutResponseSchema, {
      method: 'DELETE',
      accessToken,
    });
  }

  async runRecurringDue(cronSecret: string): Promise<RecurringRunDueResponse> {
    return this.request(
      '/recurring/run-due',
      recurringRunDueResponseSchema,
      {
        method: 'POST',
      },
      {
        'x-cron-secret': cronSecret,
      },
    );
  }

  async exportTransactionsCsv(
    query: Partial<ExportTransactionsQuery> = {},
    accessToken: string,
  ): Promise<ExportTransactionsCsvResponse> {
    return this.request('/export/transactions.csv', exportTransactionsCsvResponseSchema, {
      method: 'GET',
      accessToken,
      query: exportTransactionsQuerySchema.parse(query),
    });
  }

  private async request<T>(
    path: string,
    schema: z.ZodSchema<T>,
    options: RequestOptions = {},
    extraHeaders?: Record<string, string>,
  ): Promise<T> {
    const method = options.method ?? 'GET';
    const resolvedPath = buildPathWithQuery(path, options.query);
    const headers: Record<string, string> = {
      Accept: 'application/json',
    };

    if (options.body !== undefined) {
      headers['Content-Type'] = 'application/json';
    }

    if (options.accessToken) {
      headers.Authorization = `Bearer ${options.accessToken}`;
    }
    if (extraHeaders) {
      Object.assign(headers, extraHeaders);
    }

    const response = await this.fetchImpl(`${this.baseUrl}${resolvedPath}`, {
      method,
      headers,
      body: options.body !== undefined ? JSON.stringify(options.body) : undefined,
    });

    const payload = await readPayload(response);

    if (!response.ok) {
      throw parseApiError(response, payload);
    }

    const parsedPayload = schema.safeParse(payload);
    if (!parsedPayload.success) {
      throw new ApiClientError({
        code: 'INVALID_RESPONSE_PAYLOAD',
        message: 'Received invalid response payload from API',
        details: parsedPayload.error.flatten(),
        status: response.status,
      });
    }

    return parsedPayload.data;
  }
}

export function createApiClient(options: ApiClientOptions = {}): ApiClient {
  return new ApiClient(options);
}

### /Users/umutugur/finsight/apps/api/src/models/Account.ts
import mongoose, { type HydratedDocument, type InferSchemaType, type Types } from 'mongoose';

const { Schema, model } = mongoose;

const accountSchema = new Schema(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      index: true,
    },
    name: {
      type: String,
      required: true,
      trim: true,
      maxlength: 120,
    },
    type: {
      type: String,
      enum: ['cash', 'bank', 'credit'],
      required: true,
    },
    currency: {
      type: String,
      required: true,
      trim: true,
      uppercase: true,
      minlength: 3,
      maxlength: 3,
    },
    deletedAt: {
      type: Date,
      required: false,
      default: null,
      index: true,
    },
  },
  {
    timestamps: true,
    versionKey: false,
  },
);

accountSchema.index({ userId: 1, deletedAt: 1, createdAt: -1 });

export interface Account extends InferSchemaType<typeof accountSchema> {
  userId: Types.ObjectId;
}

export type AccountDocument = HydratedDocument<Account>;

export const AccountModel = mongoose.models.Account || model<Account>('Account', accountSchema);

### /Users/umutugur/finsight/apps/api/src/models/Category.ts
import mongoose, { type HydratedDocument, type InferSchemaType, type Types } from 'mongoose';

const { Schema, model } = mongoose;

const categorySchema = new Schema(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: false,
      index: true,
      default: null,
    },
    name: {
      type: String,
      required: true,
      trim: true,
      maxlength: 120,
    },
    type: {
      type: String,
      enum: ['income', 'expense'],
      required: true,
    },
    color: {
      type: String,
      required: true,
      trim: true,
      match: /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/,
    },
    icon: {
      type: String,
      required: false,
      trim: true,
      maxlength: 64,
      default: null,
    },
    isSystem: {
      type: Boolean,
      required: true,
      default: false,
    },
    deletedAt: {
      type: Date,
      required: false,
      default: null,
      index: true,
    },
  },
  {
    timestamps: true,
    versionKey: false,
  },
);

categorySchema.index({ userId: 1, deletedAt: 1, type: 1, name: 1 });

export interface Category extends InferSchemaType<typeof categorySchema> {
  userId: Types.ObjectId | null;
}

export type CategoryDocument = HydratedDocument<Category>;

export const CategoryModel = mongoose.models.Category || model<Category>('Category', categorySchema);

### /Users/umutugur/finsight/apps/api/src/models/Transaction.ts
import mongoose, { type HydratedDocument, type InferSchemaType, type Types } from 'mongoose';

const { Schema, model } = mongoose;

const transactionSchema = new Schema(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      index: true,
    },
    accountId: {
      type: Schema.Types.ObjectId,
      ref: 'Account',
      required: true,
      index: true,
    },
    categoryId: {
      type: Schema.Types.ObjectId,
      ref: 'Category',
      required: false,
      default: null,
      index: true,
    },
    type: {
      type: String,
      enum: ['income', 'expense'],
      required: true,
    },
    kind: {
      type: String,
      enum: ['normal', 'transfer'],
      required: true,
      default: 'normal',
      index: true,
    },
    transferGroupId: {
      type: Schema.Types.ObjectId,
      required: false,
      default: null,
      index: true,
    },
    transferDirection: {
      type: String,
      enum: ['out', 'in'],
      required: false,
      default: null,
    },
    relatedAccountId: {
      type: Schema.Types.ObjectId,
      ref: 'Account',
      required: false,
      default: null,
      index: true,
    },
    amount: {
      type: Number,
      required: true,
      min: 0,
    },
    currency: {
      type: String,
      required: true,
      trim: true,
      uppercase: true,
      minlength: 3,
      maxlength: 3,
    },
    description: {
      type: String,
      required: false,
      trim: true,
      maxlength: 500,
      default: null,
    },
    occurredAt: {
      type: Date,
      required: true,
      index: true,
    },
    deletedAt: {
      type: Date,
      required: false,
      default: null,
      index: true,
    },
  },
  {
    timestamps: true,
    versionKey: false,
  },
);

transactionSchema.index({ userId: 1, deletedAt: 1, occurredAt: -1 });
transactionSchema.index({ userId: 1, deletedAt: 1, accountId: 1, occurredAt: -1 });
transactionSchema.index({ userId: 1, deletedAt: 1, categoryId: 1, occurredAt: -1 });
transactionSchema.index({ userId: 1, deletedAt: 1, kind: 1, occurredAt: -1 });

export interface Transaction extends InferSchemaType<typeof transactionSchema> {
  userId: Types.ObjectId;
  accountId: Types.ObjectId;
  categoryId: Types.ObjectId | null;
  transferGroupId: Types.ObjectId | null;
  relatedAccountId: Types.ObjectId | null;
}

export type TransactionDocument = HydratedDocument<Transaction>;

export const TransactionModel =
  mongoose.models.Transaction || model<Transaction>('Transaction', transactionSchema);

### /Users/umutugur/finsight/apps/api/src/models/Budget.ts
import mongoose, { type HydratedDocument, type InferSchemaType, type Types } from 'mongoose';

const { Schema, model } = mongoose;

const budgetSchema = new Schema(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      index: true,
    },
    categoryId: {
      type: Schema.Types.ObjectId,
      ref: 'Category',
      required: true,
      index: true,
    },
    month: {
      type: String,
      required: true,
      trim: true,
      match: /^\d{4}-(0[1-9]|1[0-2])$/,
      index: true,
    },
    limitAmount: {
      type: Number,
      required: true,
      min: 0,
    },
    deletedAt: {
      type: Date,
      required: false,
      default: null,
      index: true,
    },
  },
  {
    timestamps: true,
    versionKey: false,
  },
);

budgetSchema.index({ userId: 1, deletedAt: 1, month: 1 });
budgetSchema.index(
  { userId: 1, categoryId: 1, month: 1 },
  { unique: true, partialFilterExpression: { deletedAt: null } },
);

export interface Budget extends InferSchemaType<typeof budgetSchema> {
  userId: Types.ObjectId;
  categoryId: Types.ObjectId;
}

export type BudgetDocument = HydratedDocument<Budget>;

export const BudgetModel = mongoose.models.Budget || model<Budget>('Budget', budgetSchema);

### /Users/umutugur/finsight/apps/api/src/models/RecurringRule.ts
import mongoose, { type HydratedDocument, type InferSchemaType, type Types } from 'mongoose';

const { Schema, model } = mongoose;

const recurringRuleSchema = new Schema(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      index: true,
    },
    kind: {
      type: String,
      enum: ['normal', 'transfer'],
      required: true,
    },
    accountId: {
      type: Schema.Types.ObjectId,
      ref: 'Account',
      required: false,
      default: null,
    },
    categoryId: {
      type: Schema.Types.ObjectId,
      ref: 'Category',
      required: false,
      default: null,
    },
    type: {
      type: String,
      enum: ['income', 'expense'],
      required: false,
      default: null,
    },
    fromAccountId: {
      type: Schema.Types.ObjectId,
      ref: 'Account',
      required: false,
      default: null,
    },
    toAccountId: {
      type: Schema.Types.ObjectId,
      ref: 'Account',
      required: false,
      default: null,
    },
    amount: {
      type: Number,
      required: true,
      min: 0,
    },
    description: {
      type: String,
      required: false,
      trim: true,
      maxlength: 500,
      default: null,
    },
    cadence: {
      type: String,
      enum: ['weekly', 'monthly'],
      required: true,
    },
    dayOfWeek: {
      type: Number,
      required: false,
      min: 0,
      max: 6,
      default: null,
    },
    dayOfMonth: {
      type: Number,
      required: false,
      min: 1,
      max: 28,
      default: null,
    },
    startAt: {
      type: Date,
      required: true,
    },
    endAt: {
      type: Date,
      required: false,
      default: null,
    },
    nextRunAt: {
      type: Date,
      required: true,
      index: true,
    },
    lastRunAt: {
      type: Date,
      required: false,
      default: null,
    },
    isPaused: {
      type: Boolean,
      required: true,
      default: false,
    },
    deletedAt: {
      type: Date,
      required: false,
      default: null,
      index: true,
    },
  },
  {
    timestamps: true,
    versionKey: false,
  },
);

recurringRuleSchema.index({ userId: 1, deletedAt: 1, nextRunAt: 1 });
recurringRuleSchema.index({ userId: 1, deletedAt: 1, cadence: 1 });

export interface RecurringRule extends InferSchemaType<typeof recurringRuleSchema> {
  userId: Types.ObjectId;
  accountId: Types.ObjectId | null;
  categoryId: Types.ObjectId | null;
  fromAccountId: Types.ObjectId | null;
  toAccountId: Types.ObjectId | null;
}

export type RecurringRuleDocument = HydratedDocument<RecurringRule>;

export const RecurringRuleModel =
  mongoose.models.RecurringRule || model<RecurringRule>('RecurringRule', recurringRuleSchema);

### /Users/umutugur/finsight/apps/api/src/models/RecurringRunLog.ts
import mongoose, { type HydratedDocument, type InferSchemaType, type Types } from 'mongoose';

const { Schema, model } = mongoose;

const recurringRunLogSchema = new Schema(
  {
    ruleId: {
      type: Schema.Types.ObjectId,
      ref: 'RecurringRule',
      required: true,
      index: true,
    },
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      index: true,
    },
    scheduledFor: {
      type: Date,
      required: true,
      index: true,
    },
    generatedTransactionIds: {
      type: [Schema.Types.ObjectId],
      required: true,
      default: [],
    },
  },
  {
    timestamps: true,
    versionKey: false,
  },
);

recurringRunLogSchema.index({ ruleId: 1, scheduledFor: 1 }, { unique: true });
recurringRunLogSchema.index({ userId: 1, scheduledFor: -1 });

export interface RecurringRunLog extends InferSchemaType<typeof recurringRunLogSchema> {
  ruleId: Types.ObjectId;
  userId: Types.ObjectId;
  generatedTransactionIds: Types.ObjectId[];
}

export type RecurringRunLogDocument = HydratedDocument<RecurringRunLog>;

export const RecurringRunLogModel =
  mongoose.models.RecurringRunLog || model<RecurringRunLog>('RecurringRunLog', recurringRunLogSchema);

### /Users/umutugur/finsight/apps/api/src/lib/transaction-dto.ts
import type { Transaction } from '@finsight/shared';

import type { TransactionDocument } from '../models/Transaction.js';

export function toTransactionDto(transaction: TransactionDocument): Transaction {
  const stamped = transaction as TransactionDocument & { createdAt: Date; updatedAt: Date };

  return {
    id: transaction.id,
    accountId: transaction.accountId.toString(),
    categoryId: transaction.categoryId ? transaction.categoryId.toString() : null,
    type: transaction.type,
    kind: transaction.kind,
    transferGroupId: transaction.transferGroupId ? transaction.transferGroupId.toString() : null,
    transferDirection: transaction.transferDirection ?? null,
    relatedAccountId: transaction.relatedAccountId ? transaction.relatedAccountId.toString() : null,
    amount: transaction.amount,
    currency: transaction.currency,
    description: transaction.description ?? null,
    occurredAt: transaction.occurredAt.toISOString(),
    createdAt: stamped.createdAt.toISOString(),
    updatedAt: stamped.updatedAt.toISOString(),
  };
}

### /Users/umutugur/finsight/apps/api/src/lib/ledger.ts
import type { TransactionType } from '@finsight/shared';
import { Types } from 'mongoose';

import { ApiError } from '../errors.js';
import { AccountModel, type AccountDocument } from '../models/Account.js';
import { CategoryModel, type CategoryDocument } from '../models/Category.js';
import { TransactionModel, type TransactionDocument } from '../models/Transaction.js';

interface CreateNormalTransactionInput {
  userId: Types.ObjectId;
  accountId: Types.ObjectId;
  categoryId: Types.ObjectId;
  type: TransactionType;
  amount: number;
  currency: string;
  description?: string | null;
  occurredAt: Date;
}

interface CreateTransferInput {
  userId: Types.ObjectId;
  fromAccountId: Types.ObjectId;
  toAccountId: Types.ObjectId;
  amount: number;
  occurredAt: Date;
  description?: string | null;
}

export async function resolveActiveAccount(
  userId: Types.ObjectId,
  accountId: Types.ObjectId,
): Promise<AccountDocument> {
  const account = await AccountModel.findOne({
    _id: accountId,
    userId,
    deletedAt: null,
  });

  if (!account) {
    throw new ApiError({
      code: 'ACCOUNT_NOT_FOUND',
      message: 'Account not found',
      statusCode: 404,
    });
  }

  return account;
}

export async function resolveActiveCategory(
  userId: Types.ObjectId,
  categoryId: Types.ObjectId,
): Promise<CategoryDocument> {
  const category = await CategoryModel.findOne({
    _id: categoryId,
    deletedAt: null,
    $or: [{ userId }, { userId: null }],
  });

  if (!category) {
    throw new ApiError({
      code: 'CATEGORY_NOT_FOUND',
      message: 'Category not found',
      statusCode: 404,
    });
  }

  return category;
}

export function validateCurrency(accountCurrency: string, transactionCurrency: string): void {
  if (accountCurrency !== transactionCurrency) {
    throw new ApiError({
      code: 'CURRENCY_MISMATCH',
      message: 'Transaction currency must match account currency',
      statusCode: 400,
    });
  }
}

export function validateTransactionType(
  categoryType: 'income' | 'expense',
  transactionType: 'income' | 'expense',
): void {
  if (categoryType !== transactionType) {
    throw new ApiError({
      code: 'CATEGORY_TYPE_MISMATCH',
      message: 'Transaction type must match category type',
      statusCode: 400,
    });
  }
}

export async function createNormalTransaction(
  input: CreateNormalTransactionInput,
): Promise<TransactionDocument> {
  return TransactionModel.create({
    userId: input.userId,
    accountId: input.accountId,
    categoryId: input.categoryId,
    type: input.type,
    kind: 'normal',
    transferGroupId: null,
    transferDirection: null,
    relatedAccountId: null,
    amount: input.amount,
    currency: input.currency,
    description: input.description ?? null,
    occurredAt: input.occurredAt,
    deletedAt: null,
  });
}

export async function createTransferPair(input: CreateTransferInput): Promise<{
  groupId: Types.ObjectId;
  fromTransaction: TransactionDocument;
  toTransaction: TransactionDocument;
}> {
  if (input.fromAccountId.toString() === input.toAccountId.toString()) {
    throw new ApiError({
      code: 'TRANSFER_ACCOUNT_CONFLICT',
      message: '`fromAccountId` and `toAccountId` must differ',
      statusCode: 400,
    });
  }

  const [fromAccount, toAccount] = await Promise.all([
    resolveActiveAccount(input.userId, input.fromAccountId),
    resolveActiveAccount(input.userId, input.toAccountId),
  ]);

  if (fromAccount.currency !== toAccount.currency) {
    throw new ApiError({
      code: 'TRANSFER_CURRENCY_MISMATCH',
      message: 'Transfer accounts must have matching currencies',
      statusCode: 400,
    });
  }

  const groupId = new Types.ObjectId();

  const [fromTransaction, toTransaction] = await Promise.all([
    TransactionModel.create({
      userId: input.userId,
      accountId: fromAccount._id,
      categoryId: null,
      type: 'expense',
      kind: 'transfer',
      transferGroupId: groupId,
      transferDirection: 'out',
      relatedAccountId: toAccount._id,
      amount: input.amount,
      currency: fromAccount.currency,
      description: input.description ?? null,
      occurredAt: input.occurredAt,
      deletedAt: null,
    }),
    TransactionModel.create({
      userId: input.userId,
      accountId: toAccount._id,
      categoryId: null,
      type: 'income',
      kind: 'transfer',
      transferGroupId: groupId,
      transferDirection: 'in',
      relatedAccountId: fromAccount._id,
      amount: input.amount,
      currency: toAccount.currency,
      description: input.description ?? null,
      occurredAt: input.occurredAt,
      deletedAt: null,
    }),
  ]);

  return {
    groupId,
    fromTransaction,
    toTransaction,
  };
}

### /Users/umutugur/finsight/apps/api/src/config.ts
export interface RuntimeConfig {
  apiName: string;
  port: number;
  mongoUri: string;
  jwtAccessSecret: string;
  jwtRefreshSecret: string;
  accessTtlMin: number;
  refreshTtlDays: number;
  cronSecret: string | null;
}

function parsePositiveInt(value: string | undefined, fallback: number): number {
  if (!value) {
    return fallback;
  }

  const parsed = Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    return fallback;
  }

  return Math.floor(parsed);
}

export function getConfig(): RuntimeConfig {
  const mongoUri = process.env.MONGODB_URI;
  if (!mongoUri) {
    throw new Error('MONGODB_URI is required');
  }

  return {
    apiName: 'FinSight API',
    port: parsePositiveInt(process.env.PORT, 4000),
    mongoUri,
    jwtAccessSecret: process.env.JWT_ACCESS_SECRET ?? 'dev-access-secret-change-me',
    jwtRefreshSecret: process.env.JWT_REFRESH_SECRET ?? 'dev-refresh-secret-change-me',
    accessTtlMin: parsePositiveInt(process.env.ACCESS_TTL_MIN, 15),
    refreshTtlDays: parsePositiveInt(process.env.REFRESH_TTL_DAYS, 30),
    cronSecret: process.env.CRON_SECRET?.trim() || null,
  };
}

### /Users/umutugur/finsight/apps/api/src/server.ts
import cors from '@fastify/cors';
import rateLimit from '@fastify/rate-limit';
import { healthResponseSchema } from '@finsight/shared';
import Fastify, { type FastifyError, type FastifyInstance } from 'fastify';

import { getConfig } from './config.js';
import { connectMongo, disconnectMongo } from './db/mongo.js';
import { ApiError, toErrorPayload } from './errors.js';
import { registerAccountRoutes } from './routes/accounts.js';
import { registerAnalyticsRoutes } from './routes/analytics.js';
import { registerAuthRoutes } from './routes/auth.js';
import { registerBudgetRoutes } from './routes/budgets.js';
import { registerCategoryRoutes } from './routes/categories.js';
import { registerDashboardRoutes } from './routes/dashboard.js';
import { registerExportRoutes } from './routes/export.js';
import { registerMeRoute } from './routes/me.js';
import { registerRecurringRoutes } from './routes/recurring.js';
import { registerTransactionRoutes } from './routes/transactions.js';
import { registerTransferRoutes } from './routes/transfers.js';

interface BuildServerOptions {
  logger?: boolean;
}

export function buildServer(options: BuildServerOptions = {}): FastifyInstance {
  const app = Fastify({
    logger: options.logger ?? true,
  });

  app.register(cors, {
    origin: true,
  });

  app.register(rateLimit, {
    global: false,
    max: 100,
    timeWindow: '1 minute',
    errorResponseBuilder: (_request, context) => {
      return {
        error: {
          code: 'RATE_LIMITED',
          message: `Too many requests. Retry in ${Math.ceil(context.ttl / 1000)}s`,
        },
      };
    },
  });

  app.addHook('onReady', async () => {
    const config = getConfig();
    await connectMongo(config.mongoUri);
  });

  app.addHook('onClose', async () => {
    await disconnectMongo();
  });

  app.setErrorHandler((error: FastifyError, _request, reply) => {
    if (error instanceof ApiError) {
      reply
        .status(error.statusCode)
        .send(toErrorPayload({ code: error.code, message: error.message, details: error.details }));
      return;
    }

    if (typeof error.statusCode === 'number' && error.statusCode >= 400 && error.statusCode < 500) {
      reply
        .status(error.statusCode)
        .send(toErrorPayload({ code: 'REQUEST_ERROR', message: error.message }));
      return;
    }

    reply.status(500).send(
      toErrorPayload({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Unexpected server error',
      }),
    );
  });

  app.get('/health', async () => {
    const config = getConfig();
    return healthResponseSchema.parse({
      ok: true,
      name: config.apiName,
    });
  });

  registerAuthRoutes(app);
  registerMeRoute(app);
  registerAccountRoutes(app);
  registerCategoryRoutes(app);
  registerTransactionRoutes(app);
  registerTransferRoutes(app);
  registerRecurringRoutes(app);
  registerDashboardRoutes(app);
  registerAnalyticsRoutes(app);
  registerBudgetRoutes(app);
  registerExportRoutes(app);

  return app;
}

### /Users/umutugur/finsight/apps/api/src/routes/accounts.ts
import {
  accountCreateInputSchema,
  accountListResponseSchema,
  accountSchema,
  accountUpdateInputSchema,
  logoutResponseSchema,
  type Account,
  type AccountCreateInput,
  type AccountUpdateInput,
} from '@finsight/shared';
import type { FastifyInstance } from 'fastify';
import type { Types } from 'mongoose';
import { z } from 'zod';

import { authenticate } from '../auth/middleware.js';
import { ApiError } from '../errors.js';
import { AccountModel, type AccountDocument } from '../models/Account.js';
import { UserModel } from '../models/User.js';

import { parseBody, parseObjectId, parseQuery, requireUser } from './utils.js';

const accountListQuerySchema = z.object({
  includeDeleted: z.coerce.boolean().default(false),
});

function toAccountDto(account: AccountDocument): Account {
  const stamped = account as AccountDocument & { createdAt: Date; updatedAt: Date };

  return {
    id: account.id,
    name: account.name,
    type: account.type,
    currency: account.currency,
    createdAt: stamped.createdAt.toISOString(),
    updatedAt: stamped.updatedAt.toISOString(),
  };
}

async function enforceBaseCurrency(userId: Types.ObjectId, inputCurrency: string): Promise<void> {
  const user = await UserModel.findById(userId);
  if (!user) {
    throw new ApiError({
      code: 'UNAUTHORIZED',
      message: 'User not found',
      statusCode: 401,
    });
  }

  if (!user.baseCurrency) {
    user.baseCurrency = inputCurrency;
    await user.save();
    return;
  }

  if (user.baseCurrency !== inputCurrency) {
    throw new ApiError({
      code: 'BASE_CURRENCY_MISMATCH',
      message: 'Account currency must match your base currency',
      statusCode: 400,
    });
  }
}

export function registerAccountRoutes(app: FastifyInstance): void {
  app.get('/accounts', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const query = parseQuery(accountListQuerySchema, request.query);

    const filter = query.includeDeleted ? { userId } : { userId, deletedAt: null };
    const accounts = await AccountModel.find(filter).sort({ createdAt: -1 });

    return accountListResponseSchema.parse({
      accounts: accounts.map((account) => toAccountDto(account)),
    });
  });

  app.post('/accounts', { preHandler: authenticate }, async (request, reply) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const input = parseBody<AccountCreateInput>(accountCreateInputSchema, request.body);

    await enforceBaseCurrency(userId, input.currency);

    const account = await AccountModel.create({
      userId,
      name: input.name,
      type: input.type,
      currency: input.currency,
      deletedAt: null,
    });

    reply.status(201);
    return accountSchema.parse(toAccountDto(account));
  });

  app.patch('/accounts/:id', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const accountId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');
    const input = parseBody<AccountUpdateInput>(accountUpdateInputSchema, request.body);

    const account = await AccountModel.findOne({ _id: accountId, userId, deletedAt: null });
    if (!account) {
      throw new ApiError({
        code: 'ACCOUNT_NOT_FOUND',
        message: 'Account not found',
        statusCode: 404,
      });
    }

    if (input.name !== undefined) {
      account.name = input.name;
    }
    if (input.type !== undefined) {
      account.type = input.type;
    }
    if (input.currency !== undefined) {
      await enforceBaseCurrency(userId, input.currency);
      account.currency = input.currency;
    }

    await account.save();

    return accountSchema.parse(toAccountDto(account));
  });

  app.delete('/accounts/:id', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const accountId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');

    const account = await AccountModel.findOne({ _id: accountId, userId, deletedAt: null });
    if (!account) {
      throw new ApiError({
        code: 'ACCOUNT_NOT_FOUND',
        message: 'Account not found',
        statusCode: 404,
      });
    }

    account.deletedAt = new Date();
    await account.save();

    return logoutResponseSchema.parse({ ok: true });
  });
}

### /Users/umutugur/finsight/apps/api/src/routes/categories.ts
import {
  categoryCreateInputSchema,
  categoryListResponseSchema,
  categorySchema,
  logoutResponseSchema,
  type Category,
  type CategoryCreateInput,
} from '@finsight/shared';
import type { FastifyInstance } from 'fastify';
import { z } from 'zod';

import { authenticate } from '../auth/middleware.js';
import { ApiError } from '../errors.js';
import { CategoryModel, type CategoryDocument } from '../models/Category.js';

import { parseBody, parseObjectId, parseQuery, requireUser } from './utils.js';

const categoryListQuerySchema = z.object({
  includeDeleted: z.coerce.boolean().default(false),
});

function toCategoryDto(category: CategoryDocument): Category {
  const stamped = category as CategoryDocument & { createdAt: Date; updatedAt: Date };

  return {
    id: category.id,
    name: category.name,
    type: category.type,
    color: category.color,
    icon: category.icon ?? null,
    isSystem: category.isSystem,
    createdAt: stamped.createdAt.toISOString(),
    updatedAt: stamped.updatedAt.toISOString(),
  };
}

export function registerCategoryRoutes(app: FastifyInstance): void {
  app.get('/categories', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const query = parseQuery(categoryListQuerySchema, request.query);

    const categories = await CategoryModel.find({
      $or: [
        { userId: null, deletedAt: null },
        query.includeDeleted ? { userId } : { userId, deletedAt: null },
      ],
    }).sort({ isSystem: -1, name: 1, createdAt: -1 });

    return categoryListResponseSchema.parse({
      categories: categories.map((category) => toCategoryDto(category)),
    });
  });

  app.post('/categories', { preHandler: authenticate }, async (request, reply) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const input = parseBody<CategoryCreateInput>(categoryCreateInputSchema, request.body);

    const category = await CategoryModel.create({
      userId,
      name: input.name,
      type: input.type,
      color: input.color,
      icon: input.icon ?? null,
      isSystem: false,
      deletedAt: null,
    });

    reply.status(201);
    return categorySchema.parse(toCategoryDto(category));
  });

  app.delete('/categories/:id', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const categoryId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');

    const category = await CategoryModel.findOne({
      _id: categoryId,
      userId,
      isSystem: false,
      deletedAt: null,
    });

    if (!category) {
      throw new ApiError({
        code: 'CATEGORY_NOT_FOUND',
        message: 'Category not found',
        statusCode: 404,
      });
    }

    category.deletedAt = new Date();
    await category.save();

    return logoutResponseSchema.parse({ ok: true });
  });
}

### /Users/umutugur/finsight/apps/api/src/routes/transactions.ts
import {
  logoutResponseSchema,
  transactionCreateInputSchema,
  transactionListQuerySchema,
  transactionListResponseSchema,
  transactionSchema,
  transactionUpdateInputSchema,
  type TransactionCreateInput,
  type TransactionListQuery,
  type TransactionUpdateInput,
} from '@finsight/shared';
import type { FastifyInstance } from 'fastify';
import { type FilterQuery } from 'mongoose';

import { authenticate } from '../auth/middleware.js';
import { ApiError } from '../errors.js';
import {
  createNormalTransaction,
  resolveActiveAccount,
  resolveActiveCategory,
  validateCurrency,
  validateTransactionType,
} from '../lib/ledger.js';
import { toTransactionDto } from '../lib/transaction-dto.js';
import { TransactionModel, type TransactionDocument } from '../models/Transaction.js';

import { parseBody, parseObjectId, parseQuery, requireUser } from './utils.js';

function escapeRegex(input: string): string {
  return input.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

export function registerTransactionRoutes(app: FastifyInstance): void {
  app.get('/transactions', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const query = parseQuery<TransactionListQuery>(transactionListQuerySchema, request.query);

    const filter: FilterQuery<TransactionDocument> = { userId };

    if (!query.includeDeleted) {
      filter.deletedAt = null;
    }
    if (query.accountId) {
      filter.accountId = parseObjectId(query.accountId, 'accountId');
    }
    if (query.categoryId) {
      filter.categoryId = parseObjectId(query.categoryId, 'categoryId');
    }
    if (query.type) {
      filter.type = query.type;
    }
    if (query.kind) {
      filter.kind = query.kind;
    }
    if (query.currency) {
      filter.currency = query.currency;
    }
    if (query.from || query.to) {
      const occurredAtFilter: { $gte?: Date; $lte?: Date } = {};
      if (query.from) {
        occurredAtFilter.$gte = new Date(query.from);
      }
      if (query.to) {
        occurredAtFilter.$lte = new Date(query.to);
      }
      filter.occurredAt = occurredAtFilter;
    }
    if (query.search) {
      filter.description = { $regex: escapeRegex(query.search), $options: 'i' };
    }

    const skip = (query.page - 1) * query.limit;

    const [transactions, total] = await Promise.all([
      TransactionModel.find(filter).sort({ occurredAt: -1, _id: -1 }).skip(skip).limit(query.limit),
      TransactionModel.countDocuments(filter),
    ]);

    const totalPages = total === 0 ? 0 : Math.ceil(total / query.limit);

    return transactionListResponseSchema.parse({
      transactions: transactions.map((transaction) => toTransactionDto(transaction)),
      pagination: {
        page: query.page,
        limit: query.limit,
        total,
        totalPages,
      },
    });
  });

  app.post('/transactions', { preHandler: authenticate }, async (request, reply) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const input = parseBody<TransactionCreateInput>(transactionCreateInputSchema, request.body);

    const accountId = parseObjectId(input.accountId, 'accountId');
    const categoryId = parseObjectId(input.categoryId, 'categoryId');

    const [account, category] = await Promise.all([
      resolveActiveAccount(userId, accountId),
      resolveActiveCategory(userId, categoryId),
    ]);

    validateCurrency(account.currency, input.currency);
    validateTransactionType(category.type, input.type);

    const transaction = await createNormalTransaction({
      userId,
      accountId: account._id,
      categoryId: category._id,
      type: input.type,
      amount: input.amount,
      currency: input.currency,
      description: input.description ?? null,
      occurredAt: new Date(input.occurredAt),
    });

    reply.status(201);
    return transactionSchema.parse(toTransactionDto(transaction));
  });

  app.get('/transactions/:id', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const transactionId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');

    const transaction = await TransactionModel.findOne({
      _id: transactionId,
      userId,
      deletedAt: null,
    });

    if (!transaction) {
      throw new ApiError({
        code: 'TRANSACTION_NOT_FOUND',
        message: 'Transaction not found',
        statusCode: 404,
      });
    }

    return transactionSchema.parse(toTransactionDto(transaction));
  });

  app.patch('/transactions/:id', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const transactionId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');
    const input = parseBody<TransactionUpdateInput>(transactionUpdateInputSchema, request.body);

    const transaction = await TransactionModel.findOne({
      _id: transactionId,
      userId,
      deletedAt: null,
    });

    if (!transaction) {
      throw new ApiError({
        code: 'TRANSACTION_NOT_FOUND',
        message: 'Transaction not found',
        statusCode: 404,
      });
    }

    if (transaction.kind === 'transfer') {
      throw new ApiError({
        code: 'TRANSFER_TRANSACTION_READ_ONLY',
        message: 'Transfer transactions cannot be edited directly',
        statusCode: 400,
      });
    }

    const accountId =
      input.accountId !== undefined ? parseObjectId(input.accountId, 'accountId') : transaction.accountId;
    const categoryId =
      input.categoryId !== undefined
        ? parseObjectId(input.categoryId, 'categoryId')
        : transaction.categoryId;

    if (!categoryId) {
      throw new ApiError({
        code: 'CATEGORY_NOT_FOUND',
        message: 'Category not found',
        statusCode: 404,
      });
    }

    const [account, category] = await Promise.all([
      resolveActiveAccount(userId, accountId),
      resolveActiveCategory(userId, categoryId),
    ]);

    const nextType = input.type ?? transaction.type;
    const nextCurrency = input.currency ?? transaction.currency;

    validateCurrency(account.currency, nextCurrency);
    validateTransactionType(category.type, nextType);

    transaction.accountId = account._id;
    transaction.categoryId = category._id;
    transaction.type = nextType;

    if (input.amount !== undefined) {
      transaction.amount = input.amount;
    }
    transaction.currency = nextCurrency;
    if (input.description !== undefined) {
      transaction.description = input.description && input.description.length > 0 ? input.description : null;
    }
    if (input.occurredAt !== undefined) {
      transaction.occurredAt = new Date(input.occurredAt);
    }

    await transaction.save();

    return transactionSchema.parse(toTransactionDto(transaction));
  });

  app.delete('/transactions/:id', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const transactionId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');

    const transaction = await TransactionModel.findOne({
      _id: transactionId,
      userId,
      deletedAt: null,
    });

    if (!transaction) {
      throw new ApiError({
        code: 'TRANSACTION_NOT_FOUND',
        message: 'Transaction not found',
        statusCode: 404,
      });
    }

    transaction.deletedAt = new Date();
    await transaction.save();

    return logoutResponseSchema.parse({ ok: true });
  });
}

### /Users/umutugur/finsight/apps/api/src/routes/dashboard.ts
import { dashboardRecentResponseSchema, type DashboardRecentResponse } from '@finsight/shared';
import type { FastifyInstance } from 'fastify';
import { Types } from 'mongoose';

import { authenticate } from '../auth/middleware.js';
import { toTransactionDto } from '../lib/transaction-dto.js';
import { AccountModel, type AccountDocument } from '../models/Account.js';
import { TransactionModel } from '../models/Transaction.js';

import { parseObjectId, requireUser } from './utils.js';

function toAccountBalance(
  account: AccountDocument,
  balanceByAccountId: Map<string, number>,
): DashboardRecentResponse['balances'][number] {
  return {
    accountId: account.id,
    name: account.name,
    type: account.type,
    currency: account.currency,
    balance: balanceByAccountId.get(account.id) ?? 0,
  };
}

export function registerDashboardRoutes(app: FastifyInstance): void {
  app.get('/dashboard/recent', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');

    const [recentTransactions, accounts, aggregatedBalances] = await Promise.all([
      TransactionModel.find({ userId, deletedAt: null }).sort({ occurredAt: -1, _id: -1 }).limit(10),
      AccountModel.find({ userId, deletedAt: null }).sort({ createdAt: -1 }),
      TransactionModel.aggregate<{
        _id: Types.ObjectId;
        balance: number;
      }>([
        { $match: { userId, deletedAt: null } },
        {
          $group: {
            _id: '$accountId',
            income: {
              $sum: {
                $cond: [{ $eq: ['$type', 'income'] }, '$amount', 0],
              },
            },
            expense: {
              $sum: {
                $cond: [{ $eq: ['$type', 'expense'] }, '$amount', 0],
              },
            },
          },
        },
        {
          $project: {
            balance: { $subtract: ['$income', '$expense'] },
          },
        },
      ]),
    ]);

    const balanceByAccountId = new Map<string, number>(
      aggregatedBalances.map((entry) => [entry._id.toString(), entry.balance]),
    );

    const balances = accounts.map((account) => toAccountBalance(account, balanceByAccountId));
    const totalBalance = balances.reduce((sum, accountBalance) => sum + accountBalance.balance, 0);

    return dashboardRecentResponseSchema.parse({
      recentTransactions: recentTransactions.map((transaction) => toTransactionDto(transaction)),
      totalBalance,
      balances,
    });
  });
}

### /Users/umutugur/finsight/apps/api/src/routes/analytics.ts
import {
  analyticsByCategoryQuerySchema,
  analyticsByCategoryResponseSchema,
  analyticsSummaryQuerySchema,
  analyticsSummaryResponseSchema,
  analyticsTrendQuerySchema,
  analyticsTrendResponseSchema,
  type AnalyticsByCategoryQuery,
  type AnalyticsSummaryQuery,
  type AnalyticsTrendQuery,
} from '@finsight/shared';
import type { FastifyInstance } from 'fastify';
import type { Types } from 'mongoose';

import { authenticate } from '../auth/middleware.js';
import { ApiError } from '../errors.js';
import { getMonthBoundaries, enumerateMonths } from '../lib/month.js';
import { TransactionModel } from '../models/Transaction.js';
import { UserModel } from '../models/User.js';

import { parseObjectId, parseQuery, requireUser } from './utils.js';

interface TotalsAggregate {
  incomeTotal: number;
  expenseTotal: number;
  transactionCount: number;
}

interface TopCategoryAggregate {
  categoryId: Types.ObjectId;
  name: string;
  type: 'income' | 'expense';
  total: number;
}

interface TrendAggregate {
  month: string;
  incomeTotal: number;
  expenseTotal: number;
  netTotal: number;
}

async function getUserBaseCurrency(userId: Types.ObjectId): Promise<string | null> {
  const user = await UserModel.findById(userId).select('baseCurrency');

  if (!user) {
    throw new ApiError({
      code: 'UNAUTHORIZED',
      message: 'User not found',
      statusCode: 401,
    });
  }

  return user.baseCurrency ?? null;
}

export function registerAnalyticsRoutes(app: FastifyInstance): void {
  app.get('/analytics/summary', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const query = parseQuery<AnalyticsSummaryQuery>(analyticsSummaryQuerySchema, request.query);
    const { start, endExclusive } = getMonthBoundaries(query.month, 'month');

    const match = {
      userId,
      deletedAt: null,
      kind: 'normal',
      occurredAt: {
        $gte: start,
        $lt: endExclusive,
      },
    };

    const [currency, totalsRows, topRows] = await Promise.all([
      getUserBaseCurrency(userId),
      TransactionModel.aggregate<TotalsAggregate>([
        { $match: match },
        {
          $group: {
            _id: null,
            incomeTotal: {
              $sum: {
                $cond: [{ $eq: ['$type', 'income'] }, '$amount', 0],
              },
            },
            expenseTotal: {
              $sum: {
                $cond: [{ $eq: ['$type', 'expense'] }, '$amount', 0],
              },
            },
            transactionCount: { $sum: 1 },
          },
        },
        {
          $project: {
            _id: 0,
            incomeTotal: 1,
            expenseTotal: 1,
            transactionCount: 1,
          },
        },
      ]),
      TransactionModel.aggregate<TopCategoryAggregate>([
        { $match: match },
        {
          $group: {
            _id: {
              categoryId: '$categoryId',
              type: '$type',
            },
            total: { $sum: '$amount' },
          },
        },
        { $sort: { total: -1 } },
        {
          $lookup: {
            from: 'categories',
            localField: '_id.categoryId',
            foreignField: '_id',
            as: 'categoryDocs',
          },
        },
        {
          $unwind: {
            path: '$categoryDocs',
            preserveNullAndEmptyArrays: true,
          },
        },
        {
          $project: {
            _id: 0,
            categoryId: '$_id.categoryId',
            type: '$_id.type',
            total: 1,
            name: { $ifNull: ['$categoryDocs.name', 'Unknown'] },
          },
        },
      ]),
    ]);

    const totals = totalsRows[0] ?? {
      incomeTotal: 0,
      expenseTotal: 0,
      transactionCount: 0,
    };

    const topCategories = topRows.map((entry) => {
      const denominator = entry.type === 'expense' ? totals.expenseTotal : totals.incomeTotal;
      const percent = denominator > 0 ? (entry.total / denominator) * 100 : 0;

      return {
        categoryId: entry.categoryId.toString(),
        name: entry.name,
        type: entry.type,
        total: entry.total,
        percent,
      };
    });

    return analyticsSummaryResponseSchema.parse({
      month: query.month,
      currency,
      incomeTotal: totals.incomeTotal,
      expenseTotal: totals.expenseTotal,
      netTotal: totals.incomeTotal - totals.expenseTotal,
      transactionCount: totals.transactionCount,
      topCategories,
    });
  });

  app.get('/analytics/by-category', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const query = parseQuery<AnalyticsByCategoryQuery>(analyticsByCategoryQuerySchema, request.query);
    const { start, endExclusive } = getMonthBoundaries(query.month, 'month');

    const [currency, rows] = await Promise.all([
      getUserBaseCurrency(userId),
      TransactionModel.aggregate<{
        categoryId: Types.ObjectId;
        name: string;
        total: number;
        count: number;
      }>([
        {
          $match: {
            userId,
            deletedAt: null,
            kind: 'normal',
            type: query.type,
            occurredAt: {
              $gte: start,
              $lt: endExclusive,
            },
          },
        },
        {
          $group: {
            _id: '$categoryId',
            total: { $sum: '$amount' },
            count: { $sum: 1 },
          },
        },
        { $sort: { total: -1 } },
        {
          $lookup: {
            from: 'categories',
            localField: '_id',
            foreignField: '_id',
            as: 'categoryDocs',
          },
        },
        {
          $unwind: {
            path: '$categoryDocs',
            preserveNullAndEmptyArrays: true,
          },
        },
        {
          $project: {
            _id: 0,
            categoryId: '$_id',
            name: { $ifNull: ['$categoryDocs.name', 'Unknown'] },
            total: 1,
            count: 1,
          },
        },
      ]),
    ]);

    return analyticsByCategoryResponseSchema.parse({
      month: query.month,
      type: query.type,
      currency,
      categories: rows.map((row) => ({
        categoryId: row.categoryId.toString(),
        name: row.name,
        total: row.total,
        count: row.count,
      })),
    });
  });

  app.get('/analytics/trend', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const query = parseQuery<AnalyticsTrendQuery>(analyticsTrendQuerySchema, request.query);

    const months = enumerateMonths(query.from, query.to);
    const fromBoundary = getMonthBoundaries(query.from, 'from');
    const toBoundary = getMonthBoundaries(query.to, 'to');

    const [currency, rows] = await Promise.all([
      getUserBaseCurrency(userId),
      TransactionModel.aggregate<TrendAggregate>([
        {
          $match: {
            userId,
            deletedAt: null,
            kind: 'normal',
            occurredAt: {
              $gte: fromBoundary.start,
              $lt: toBoundary.endExclusive,
            },
          },
        },
        {
          $project: {
            month: {
              $dateToString: {
                format: '%Y-%m',
                date: '$occurredAt',
                timezone: 'UTC',
              },
            },
            type: 1,
            amount: 1,
          },
        },
        {
          $group: {
            _id: '$month',
            incomeTotal: {
              $sum: {
                $cond: [{ $eq: ['$type', 'income'] }, '$amount', 0],
              },
            },
            expenseTotal: {
              $sum: {
                $cond: [{ $eq: ['$type', 'expense'] }, '$amount', 0],
              },
            },
          },
        },
        {
          $project: {
            _id: 0,
            month: '$_id',
            incomeTotal: 1,
            expenseTotal: 1,
            netTotal: { $subtract: ['$incomeTotal', '$expenseTotal'] },
          },
        },
        { $sort: { month: 1 } },
      ]),
    ]);

    const byMonth = new Map(rows.map((row) => [row.month, row]));

    return analyticsTrendResponseSchema.parse({
      currency,
      points: months.map((month) => {
        const row = byMonth.get(month);

        if (!row) {
          return {
            month,
            incomeTotal: 0,
            expenseTotal: 0,
            netTotal: 0,
          };
        }

        return row;
      }),
    });
  });
}

### /Users/umutugur/finsight/apps/api/src/routes/budgets.ts
import {
  budgetCreateInputSchema,
  budgetListQuerySchema,
  budgetListResponseSchema,
  budgetSchema,
  budgetUpdateInputSchema,
  logoutResponseSchema,
  type Budget,
  type BudgetCreateInput,
  type BudgetListQuery,
  type BudgetUpdateInput,
} from '@finsight/shared';
import type { FastifyInstance } from 'fastify';
import { Types } from 'mongoose';

import { authenticate } from '../auth/middleware.js';
import { ApiError } from '../errors.js';
import { getMonthBoundaries } from '../lib/month.js';
import { BudgetModel, type BudgetDocument } from '../models/Budget.js';
import { CategoryModel } from '../models/Category.js';
import { TransactionModel } from '../models/Transaction.js';

import { parseBody, parseObjectId, parseQuery, requireUser } from './utils.js';

function toBudgetDto(budget: BudgetDocument): Budget {
  const stamped = budget as BudgetDocument & { createdAt: Date; updatedAt: Date };

  return {
    id: budget.id,
    categoryId: budget.categoryId.toString(),
    month: budget.month,
    limitAmount: budget.limitAmount,
    createdAt: stamped.createdAt.toISOString(),
    updatedAt: stamped.updatedAt.toISOString(),
  };
}

async function validateExpenseCategory(userId: Types.ObjectId, categoryId: Types.ObjectId) {
  const category = await CategoryModel.findOne({
    _id: categoryId,
    type: 'expense',
    deletedAt: null,
    $or: [{ userId }, { userId: null }],
  });

  if (!category) {
    throw new ApiError({
      code: 'INVALID_BUDGET_CATEGORY',
      message: 'Category must be an expense category',
      statusCode: 400,
    });
  }

  return category;
}

export function registerBudgetRoutes(app: FastifyInstance): void {
  app.get('/budgets', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const query = parseQuery<BudgetListQuery>(budgetListQuerySchema, request.query);
    const { start, endExclusive } = getMonthBoundaries(query.month, 'month');

    const budgets = await BudgetModel.find({
      userId,
      month: query.month,
      ...(query.includeDeleted ? {} : { deletedAt: null }),
    }).sort({ createdAt: -1 });

    if (budgets.length === 0) {
      return budgetListResponseSchema.parse({ budgets: [] });
    }

    const activeBudgets = budgets.filter((budget) => budget.deletedAt === null);
    if (activeBudgets.length === 0) {
      return budgetListResponseSchema.parse({ budgets: [] });
    }

    const categoryIds = activeBudgets.map((budget) => budget.categoryId);

    const [categories, spentRows] = await Promise.all([
      CategoryModel.find({
        _id: { $in: categoryIds },
        deletedAt: null,
        $or: [{ userId }, { userId: null }],
      }).select('_id name'),
      TransactionModel.aggregate<{
        _id: Types.ObjectId;
        spentAmount: number;
      }>([
        {
          $match: {
            userId,
            deletedAt: null,
            kind: 'normal',
            type: 'expense',
            categoryId: { $in: categoryIds },
            occurredAt: {
              $gte: start,
              $lt: endExclusive,
            },
          },
        },
        {
          $group: {
            _id: '$categoryId',
            spentAmount: { $sum: '$amount' },
          },
        },
      ]),
    ]);

    const categoryNameById = new Map(categories.map((category) => [category.id, category.name]));
    const spentAmountByCategoryId = new Map(
      spentRows.map((row) => [row._id.toString(), row.spentAmount]),
    );

    return budgetListResponseSchema.parse({
      budgets: activeBudgets.map((budget) => {
        const categoryId = budget.categoryId.toString();
        const spentAmount = spentAmountByCategoryId.get(categoryId) ?? 0;
        const remainingAmount = budget.limitAmount - spentAmount;
        const percentUsed = budget.limitAmount > 0 ? (spentAmount / budget.limitAmount) * 100 : 0;

        return {
          id: budget.id,
          categoryId,
          categoryName: categoryNameById.get(categoryId) ?? 'Unknown',
          month: budget.month,
          limitAmount: budget.limitAmount,
          spentAmount,
          remainingAmount,
          percentUsed,
        };
      }),
    });
  });

  app.post('/budgets', { preHandler: authenticate }, async (request, reply) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const input = parseBody<BudgetCreateInput>(budgetCreateInputSchema, request.body);
    const categoryId = parseObjectId(input.categoryId, 'categoryId');

    await validateExpenseCategory(userId, categoryId);

    try {
      const budget = await BudgetModel.create({
        userId,
        categoryId,
        month: input.month,
        limitAmount: input.limitAmount,
        deletedAt: null,
      });

      reply.status(201);
      return budgetSchema.parse(toBudgetDto(budget));
    } catch (error) {
      if ((error as { code?: number }).code === 11000) {
        throw new ApiError({
          code: 'BUDGET_ALREADY_EXISTS',
          message: 'Budget already exists for this category and month',
          statusCode: 409,
        });
      }

      throw error;
    }
  });

  app.patch('/budgets/:id', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const budgetId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');
    const input = parseBody<BudgetUpdateInput>(budgetUpdateInputSchema, request.body);

    const budget = await BudgetModel.findOne({ _id: budgetId, userId, deletedAt: null });
    if (!budget) {
      throw new ApiError({
        code: 'BUDGET_NOT_FOUND',
        message: 'Budget not found',
        statusCode: 404,
      });
    }

    budget.limitAmount = input.limitAmount;
    await budget.save();

    return budgetSchema.parse(toBudgetDto(budget));
  });

  app.delete('/budgets/:id', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const budgetId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');

    const budget = await BudgetModel.findOne({
      _id: budgetId,
      userId,
      deletedAt: null,
    });

    if (!budget) {
      throw new ApiError({
        code: 'BUDGET_NOT_FOUND',
        message: 'Budget not found',
        statusCode: 404,
      });
    }

    budget.deletedAt = new Date();
    await budget.save();

    return logoutResponseSchema.parse({ ok: true });
  });
}

### /Users/umutugur/finsight/apps/api/src/routes/transfers.ts
import {
  transferCreateInputSchema,
  transferCreateResponseSchema,
  type TransferCreateInput,
} from '@finsight/shared';
import type { FastifyInstance } from 'fastify';

import { authenticate } from '../auth/middleware.js';
import { createTransferPair } from '../lib/ledger.js';

import { parseBody, parseObjectId, requireUser } from './utils.js';

export function registerTransferRoutes(app: FastifyInstance): void {
  app.post('/transfers', { preHandler: authenticate }, async (request, reply) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const input = parseBody<TransferCreateInput>(transferCreateInputSchema, request.body);

    const result = await createTransferPair({
      userId,
      fromAccountId: parseObjectId(input.fromAccountId, 'fromAccountId'),
      toAccountId: parseObjectId(input.toAccountId, 'toAccountId'),
      amount: input.amount,
      occurredAt: new Date(input.occurredAt),
      description: input.description ?? null,
    });

    reply.status(201);
    return transferCreateResponseSchema.parse({
      groupId: result.groupId.toString(),
      fromTransactionId: result.fromTransaction.id,
      toTransactionId: result.toTransaction.id,
    });
  });
}

### /Users/umutugur/finsight/apps/api/src/routes/recurring.ts
import {
  logoutResponseSchema,
  recurringCreateInputSchema,
  recurringListQuerySchema,
  recurringListResponseSchema,
  recurringRuleSchema,
  recurringRunDueResponseSchema,
  recurringUpdateInputSchema,
  type RecurringCreateInput,
  type RecurringListQuery,
  type RecurringRule,
  type RecurringUpdateInput,
} from '@finsight/shared';
import type { FastifyInstance, FastifyRequest } from 'fastify';
import type { FilterQuery, Types } from 'mongoose';

import { authenticate } from '../auth/middleware.js';
import { getConfig } from '../config.js';
import { ApiError } from '../errors.js';
import {
  createNormalTransaction,
  createTransferPair,
  resolveActiveAccount,
  resolveActiveCategory,
  validateTransactionType,
} from '../lib/ledger.js';
import { getMonthBoundaries } from '../lib/month.js';
import { RecurringRunLogModel } from '../models/RecurringRunLog.js';
import { RecurringRuleModel, type RecurringRuleDocument } from '../models/RecurringRule.js';

import { parseBody, parseObjectId, parseQuery, requireUser } from './utils.js';

function toRecurringDto(rule: RecurringRuleDocument): RecurringRule {
  const stamped = rule as RecurringRuleDocument & { createdAt: Date; updatedAt: Date };

  return {
    id: rule.id,
    kind: rule.kind,
    accountId: rule.accountId ? rule.accountId.toString() : null,
    categoryId: rule.categoryId ? rule.categoryId.toString() : null,
    type: rule.type ?? null,
    fromAccountId: rule.fromAccountId ? rule.fromAccountId.toString() : null,
    toAccountId: rule.toAccountId ? rule.toAccountId.toString() : null,
    amount: rule.amount,
    description: rule.description ?? null,
    cadence: rule.cadence,
    dayOfWeek: rule.dayOfWeek ?? null,
    dayOfMonth: rule.dayOfMonth ?? null,
    startAt: rule.startAt.toISOString(),
    endAt: rule.endAt ? rule.endAt.toISOString() : null,
    nextRunAt: rule.nextRunAt.toISOString(),
    lastRunAt: rule.lastRunAt ? rule.lastRunAt.toISOString() : null,
    isPaused: rule.isPaused,
    deletedAt: rule.deletedAt ? rule.deletedAt.toISOString() : null,
    createdAt: stamped.createdAt.toISOString(),
    updatedAt: stamped.updatedAt.toISOString(),
  };
}

function ensureScheduleFields(
  cadence: 'weekly' | 'monthly',
  dayOfWeek: number | null | undefined,
  dayOfMonth: number | null | undefined,
): void {
  if (cadence === 'weekly' && (dayOfWeek === null || dayOfWeek === undefined)) {
    throw new ApiError({
      code: 'VALIDATION_ERROR',
      message: '`dayOfWeek` is required for weekly cadence',
      statusCode: 400,
    });
  }

  if (cadence === 'monthly' && (dayOfMonth === null || dayOfMonth === undefined)) {
    throw new ApiError({
      code: 'VALIDATION_ERROR',
      message: '`dayOfMonth` is required for monthly cadence',
      statusCode: 400,
    });
  }
}

function scheduleAtDay(
  year: number,
  month: number,
  day: number,
  anchor: Date,
): Date {
  return new Date(
    Date.UTC(
      year,
      month,
      day,
      anchor.getUTCHours(),
      anchor.getUTCMinutes(),
      anchor.getUTCSeconds(),
      anchor.getUTCMilliseconds(),
    ),
  );
}

function calculateInitialNextRun(
  cadence: 'weekly' | 'monthly',
  dayOfWeek: number | null,
  dayOfMonth: number | null,
  startAt: Date,
): Date {
  ensureScheduleFields(cadence, dayOfWeek, dayOfMonth);

  if (cadence === 'weekly') {
    const targetDow = dayOfWeek as number;
    const candidate = new Date(startAt);
    const diff = (targetDow - candidate.getUTCDay() + 7) % 7;
    candidate.setUTCDate(candidate.getUTCDate() + diff);

    if (candidate.getTime() < startAt.getTime()) {
      candidate.setUTCDate(candidate.getUTCDate() + 7);
    }

    return candidate;
  }

  const targetDom = dayOfMonth as number;
  let candidate = scheduleAtDay(startAt.getUTCFullYear(), startAt.getUTCMonth(), targetDom, startAt);

  if (candidate.getTime() < startAt.getTime()) {
    candidate = scheduleAtDay(
      startAt.getUTCFullYear(),
      startAt.getUTCMonth() + 1,
      targetDom,
      startAt,
    );
  }

  return candidate;
}

function advanceNextRun(
  current: Date,
  cadence: 'weekly' | 'monthly',
  dayOfWeek: number | null,
  dayOfMonth: number | null,
): Date {
  ensureScheduleFields(cadence, dayOfWeek, dayOfMonth);

  if (cadence === 'weekly') {
    const next = new Date(current);
    next.setUTCDate(next.getUTCDate() + 7);
    return next;
  }

  const targetDom = dayOfMonth as number;
  return scheduleAtDay(current.getUTCFullYear(), current.getUTCMonth() + 1, targetDom, current);
}

function calculateNextFromNow(rule: RecurringRuleDocument): Date {
  const now = new Date();
  let candidate = calculateInitialNextRun(
    rule.cadence,
    rule.dayOfWeek ?? null,
    rule.dayOfMonth ?? null,
    now,
  );

  // Keep advancing until next slot is strictly in the future.
  while (candidate.getTime() <= now.getTime()) {
    candidate = advanceNextRun(
      candidate,
      rule.cadence,
      rule.dayOfWeek ?? null,
      rule.dayOfMonth ?? null,
    );
  }

  return candidate;
}

async function executeRecurringRun(
  rule: RecurringRuleDocument,
  scheduledFor: Date,
): Promise<Types.ObjectId[]> {
  if (rule.kind === 'normal') {
    if (!rule.accountId || !rule.categoryId || !rule.type) {
      throw new ApiError({
        code: 'RECURRING_RULE_INVALID',
        message: 'Recurring normal rule is missing account/category/type',
        statusCode: 400,
      });
    }

    const [account, category] = await Promise.all([
      resolveActiveAccount(rule.userId, rule.accountId),
      resolveActiveCategory(rule.userId, rule.categoryId),
    ]);

    validateTransactionType(category.type, rule.type);

    const transaction = await createNormalTransaction({
      userId: rule.userId,
      accountId: account._id,
      categoryId: category._id,
      type: rule.type,
      amount: rule.amount,
      currency: account.currency,
      description: rule.description ?? null,
      occurredAt: scheduledFor,
    });

    return [transaction._id];
  }

  if (!rule.fromAccountId || !rule.toAccountId) {
    throw new ApiError({
      code: 'RECURRING_RULE_INVALID',
      message: 'Recurring transfer rule is missing from/to account',
      statusCode: 400,
    });
  }

  const transfer = await createTransferPair({
    userId: rule.userId,
    fromAccountId: rule.fromAccountId,
    toAccountId: rule.toAccountId,
    amount: rule.amount,
    occurredAt: scheduledFor,
    description: rule.description ?? null,
  });

  return [transfer.fromTransaction._id, transfer.toTransaction._id];
}

function readCronSecret(request: FastifyRequest): string | null {
  const raw = request.headers['x-cron-secret'];
  if (Array.isArray(raw)) {
    return raw[0] ?? null;
  }
  return typeof raw === 'string' ? raw : null;
}

function requireCronAuth(request: FastifyRequest): void {
  const config = getConfig();
  if (!config.cronSecret) {
    throw new ApiError({
      code: 'CRON_SECRET_NOT_CONFIGURED',
      message: 'CRON_SECRET is not configured',
      statusCode: 503,
    });
  }

  const provided = readCronSecret(request);
  if (!provided || provided !== config.cronSecret) {
    throw new ApiError({
      code: 'FORBIDDEN',
      message: 'Invalid cron secret',
      statusCode: 403,
    });
  }
}

export function registerRecurringRoutes(app: FastifyInstance): void {
  app.get('/recurring', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const query = parseQuery<RecurringListQuery>(recurringListQuerySchema, request.query);

    const filter: FilterQuery<RecurringRuleDocument> = {
      userId,
      ...(query.includeDeleted ? {} : { deletedAt: null }),
    };

    if (query.month) {
      const { start, endExclusive } = getMonthBoundaries(query.month, 'month');
      filter.nextRunAt = {
        $gte: start,
        $lt: endExclusive,
      };
    }

    const rules = await RecurringRuleModel.find(filter).sort({ nextRunAt: 1, _id: -1 });

    return recurringListResponseSchema.parse({
      rules: rules.map((rule) => toRecurringDto(rule)),
    });
  });

  app.post('/recurring', { preHandler: authenticate }, async (request, reply) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const input = parseBody<RecurringCreateInput>(recurringCreateInputSchema, request.body);

    if (input.kind === 'normal') {
      const account = await resolveActiveAccount(userId, parseObjectId(input.accountId, 'accountId'));
      const category = await resolveActiveCategory(userId, parseObjectId(input.categoryId, 'categoryId'));
      validateTransactionType(category.type, input.type);
      if (account.deletedAt !== null) {
        throw new ApiError({
          code: 'ACCOUNT_NOT_FOUND',
          message: 'Account not found',
          statusCode: 404,
        });
      }
    } else {
      if (input.fromAccountId === input.toAccountId) {
        throw new ApiError({
          code: 'TRANSFER_ACCOUNT_CONFLICT',
          message: '`fromAccountId` and `toAccountId` must differ',
          statusCode: 400,
        });
      }

      const [fromAccount, toAccount] = await Promise.all([
        resolveActiveAccount(userId, parseObjectId(input.fromAccountId, 'fromAccountId')),
        resolveActiveAccount(userId, parseObjectId(input.toAccountId, 'toAccountId')),
      ]);

      if (fromAccount.currency !== toAccount.currency) {
        throw new ApiError({
          code: 'TRANSFER_CURRENCY_MISMATCH',
          message: 'Transfer accounts must have matching currencies',
          statusCode: 400,
        });
      }
    }

    const startAt = new Date(input.startAt);
    const nextRunAt = calculateInitialNextRun(
      input.cadence,
      input.dayOfWeek ?? null,
      input.dayOfMonth ?? null,
      startAt,
    );

    const recurringRule = await RecurringRuleModel.create({
      userId,
      kind: input.kind,
      accountId: input.kind === 'normal' ? parseObjectId(input.accountId, 'accountId') : null,
      categoryId: input.kind === 'normal' ? parseObjectId(input.categoryId, 'categoryId') : null,
      type: input.kind === 'normal' ? input.type : null,
      fromAccountId:
        input.kind === 'transfer' ? parseObjectId(input.fromAccountId, 'fromAccountId') : null,
      toAccountId: input.kind === 'transfer' ? parseObjectId(input.toAccountId, 'toAccountId') : null,
      amount: input.amount,
      description: input.description ?? null,
      cadence: input.cadence,
      dayOfWeek: input.dayOfWeek ?? null,
      dayOfMonth: input.dayOfMonth ?? null,
      startAt,
      endAt: input.endAt ? new Date(input.endAt) : null,
      nextRunAt,
      lastRunAt: null,
      isPaused: false,
      deletedAt: null,
    });

    reply.status(201);
    return recurringRuleSchema.parse(toRecurringDto(recurringRule));
  });

  app.patch('/recurring/:id', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const recurringId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');
    const input = parseBody<RecurringUpdateInput>(recurringUpdateInputSchema, request.body);

    const rule = await RecurringRuleModel.findOne({
      _id: recurringId,
      userId,
      deletedAt: null,
    });

    if (!rule) {
      throw new ApiError({
        code: 'RECURRING_RULE_NOT_FOUND',
        message: 'Recurring rule not found',
        statusCode: 404,
      });
    }

    if (input.amount !== undefined) {
      rule.amount = input.amount;
    }
    if (input.description !== undefined) {
      rule.description = input.description && input.description.length > 0 ? input.description : null;
    }
    if (input.endAt !== undefined) {
      rule.endAt = input.endAt ? new Date(input.endAt) : null;
    }
    if (input.isPaused !== undefined) {
      rule.isPaused = input.isPaused;
    }

    const scheduleChanged =
      input.cadence !== undefined || input.dayOfWeek !== undefined || input.dayOfMonth !== undefined;

    if (input.cadence !== undefined) {
      rule.cadence = input.cadence;
    }
    if (input.dayOfWeek !== undefined) {
      rule.dayOfWeek = input.dayOfWeek;
    }
    if (input.dayOfMonth !== undefined) {
      rule.dayOfMonth = input.dayOfMonth;
    }

    ensureScheduleFields(rule.cadence, rule.dayOfWeek, rule.dayOfMonth);

    if (scheduleChanged || (input.isPaused === false && rule.nextRunAt.getTime() <= Date.now())) {
      rule.nextRunAt = calculateNextFromNow(rule);
    }

    if (rule.endAt && rule.nextRunAt.getTime() > rule.endAt.getTime()) {
      rule.isPaused = true;
    }

    await rule.save();

    return recurringRuleSchema.parse(toRecurringDto(rule));
  });

  app.delete('/recurring/:id', { preHandler: authenticate }, async (request) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const recurringId = parseObjectId((request.params as { id?: string }).id ?? '', 'id');

    const rule = await RecurringRuleModel.findOne({
      _id: recurringId,
      userId,
      deletedAt: null,
    });

    if (!rule) {
      throw new ApiError({
        code: 'RECURRING_RULE_NOT_FOUND',
        message: 'Recurring rule not found',
        statusCode: 404,
      });
    }

    rule.deletedAt = new Date();
    await rule.save();

    return logoutResponseSchema.parse({ ok: true });
  });

  app.post('/recurring/run-due', async (request) => {
    requireCronAuth(request);

    const now = new Date();
    const dueRules = await RecurringRuleModel.find({
      deletedAt: null,
      isPaused: false,
      nextRunAt: { $lte: now },
    }).sort({ nextRunAt: 1, _id: 1 });

    let processedRules = 0;
    let processedRuns = 0;
    let generatedTransactions = 0;

    for (const rule of dueRules) {
      processedRules += 1;

      let cursor = new Date(rule.nextRunAt);
      let lastRunAt = rule.lastRunAt ? new Date(rule.lastRunAt) : null;
      let shouldPause = rule.isPaused;

      while (!shouldPause && cursor.getTime() <= now.getTime()) {
        if (rule.endAt && cursor.getTime() > rule.endAt.getTime()) {
          shouldPause = true;
          break;
        }

        let logId: Types.ObjectId | null = null;

        try {
          const runLog = await RecurringRunLogModel.create({
            ruleId: rule._id,
            userId: rule.userId,
            scheduledFor: cursor,
            generatedTransactionIds: [],
          });
          logId = runLog._id;
        } catch (error) {
          if ((error as { code?: number }).code === 11000) {
            lastRunAt = new Date(cursor);
            cursor = advanceNextRun(
              cursor,
              rule.cadence,
              rule.dayOfWeek ?? null,
              rule.dayOfMonth ?? null,
            );
            continue;
          }
          throw error;
        }

        try {
          const generatedIds = await executeRecurringRun(rule, cursor);

          await RecurringRunLogModel.updateOne(
            { _id: logId },
            { $set: { generatedTransactionIds: generatedIds } },
          );

          processedRuns += 1;
          generatedTransactions += generatedIds.length;
          lastRunAt = new Date(cursor);
          cursor = advanceNextRun(
            cursor,
            rule.cadence,
            rule.dayOfWeek ?? null,
            rule.dayOfMonth ?? null,
          );
        } catch (error) {
          if (logId) {
            await RecurringRunLogModel.deleteOne({ _id: logId });
          }
          throw error;
        }

        if (rule.endAt && cursor.getTime() > rule.endAt.getTime()) {
          shouldPause = true;
        }
      }

      const hasLastRunChanged =
        (lastRunAt?.getTime() ?? 0) !== (rule.lastRunAt ? rule.lastRunAt.getTime() : 0);

      if (
        cursor.getTime() !== rule.nextRunAt.getTime() ||
        shouldPause !== rule.isPaused ||
        hasLastRunChanged
      ) {
        rule.nextRunAt = cursor;
        rule.isPaused = shouldPause;
        rule.lastRunAt = lastRunAt;
        await rule.save();
      }
    }

    return recurringRunDueResponseSchema.parse({
      processedRules,
      processedRuns,
      generatedTransactions,
    });
  });
}

### /Users/umutugur/finsight/apps/api/src/routes/export.ts
import {
  exportTransactionsCsvResponseSchema,
  exportTransactionsQuerySchema,
  type ExportTransactionsQuery,
} from '@finsight/shared';
import type { FastifyInstance } from 'fastify';
import type { FilterQuery } from 'mongoose';

import { authenticate } from '../auth/middleware.js';
import { AccountModel } from '../models/Account.js';
import { CategoryModel } from '../models/Category.js';
import { TransactionModel, type TransactionDocument } from '../models/Transaction.js';

import { parseObjectId, parseQuery, requireUser } from './utils.js';

function escapeCsvField(value: string): string {
  if (value.includes('"')) {
    value = value.replace(/"/g, '""');
  }

  if (value.includes(',') || value.includes('\n') || value.includes('\r') || value.includes('"')) {
    return `"${value}"`;
  }

  return value;
}

function toCsvLine(fields: Array<string | number>): string {
  return fields.map((field) => escapeCsvField(String(field))).join(',');
}

export function registerExportRoutes(app: FastifyInstance): void {
  app.get('/export/transactions.csv', { preHandler: authenticate }, async (request, reply) => {
    const user = requireUser(request);
    const userId = parseObjectId(user.id, 'userId');
    const query = parseQuery<ExportTransactionsQuery>(exportTransactionsQuerySchema, request.query);

    const filter: FilterQuery<TransactionDocument> = {
      userId,
      deletedAt: null,
    };

    if (query.accountId) {
      filter.accountId = parseObjectId(query.accountId, 'accountId');
    }
    if (query.type) {
      filter.type = query.type;
    }
    if (query.kind) {
      filter.kind = query.kind;
    }
    if (query.from || query.to) {
      filter.occurredAt = {
        ...(query.from ? { $gte: new Date(query.from) } : {}),
        ...(query.to ? { $lte: new Date(query.to) } : {}),
      };
    }

    const transactions = await TransactionModel.find(filter).sort({ occurredAt: 1, _id: 1 });

    const accountIds = [...new Set(transactions.map((transaction) => transaction.accountId.toString()))].map(
      (id) => parseObjectId(id, 'accountId'),
    );
    const categoryIds = [
      ...new Set(
        transactions
          .map((transaction) => transaction.categoryId?.toString())
          .filter((categoryId): categoryId is string => Boolean(categoryId)),
      ),
    ].map((id) => parseObjectId(id, 'categoryId'));

    const [accounts, categories] = await Promise.all([
      accountIds.length > 0
        ? AccountModel.find({ _id: { $in: accountIds }, userId }).select('_id name')
        : Promise.resolve([]),
      categoryIds.length > 0
        ? CategoryModel.find({
            _id: { $in: categoryIds },
            $or: [{ userId }, { userId: null }],
          }).select('_id name')
        : Promise.resolve([]),
    ]);

    const accountNameById = new Map(accounts.map((account) => [account.id, account.name]));
    const categoryNameById = new Map(categories.map((category) => [category.id, category.name]));

    const lines = [
      toCsvLine([
        'occurredAt',
        'type',
        'kind',
        'accountName',
        'categoryName',
        'amount',
        'currency',
        'description',
      ]),
      ...transactions.map((transaction) =>
        toCsvLine([
          transaction.occurredAt.toISOString(),
          transaction.type,
          transaction.kind,
          accountNameById.get(transaction.accountId.toString()) ?? 'Unknown',
          transaction.categoryId ? categoryNameById.get(transaction.categoryId.toString()) ?? '' : '',
          transaction.amount,
          transaction.currency,
          transaction.description ?? '',
        ]),
      ),
    ];

    const csv = lines.join('\n');

    reply
      .header('Content-Type', 'text/csv; charset=utf-8')
      .header('Content-Disposition', 'attachment; filename="transactions.csv"');

    return exportTransactionsCsvResponseSchema.parse(csv);
  });
}

### /Users/umutugur/finsight/apps/api/test/auth.e2e.test.ts
import { MongoMemoryServer } from 'mongodb-memory-server';
import request from 'supertest';
import { afterAll, beforeAll, beforeEach, describe, expect, it } from 'vitest';

import { AccountModel } from '../src/models/Account.js';
import { BudgetModel } from '../src/models/Budget.js';
import { CategoryModel } from '../src/models/Category.js';
import { RefreshTokenModel } from '../src/models/RefreshToken.js';
import { RecurringRunLogModel } from '../src/models/RecurringRunLog.js';
import { RecurringRuleModel } from '../src/models/RecurringRule.js';
import { TransactionModel } from '../src/models/Transaction.js';
import { UserModel } from '../src/models/User.js';
import { buildServer } from '../src/server.js';

describe('Auth + Finance API', () => {
  let mongo: MongoMemoryServer;
  let app!: ReturnType<typeof buildServer>;

  beforeAll(async () => {
    mongo = await MongoMemoryServer.create();

    process.env.MONGODB_URI = mongo.getUri();
    process.env.JWT_ACCESS_SECRET = 'test-access-secret';
    process.env.JWT_REFRESH_SECRET = 'test-refresh-secret';
    process.env.ACCESS_TTL_MIN = '15';
    process.env.REFRESH_TTL_DAYS = '30';
    process.env.CRON_SECRET = 'test-cron-secret';

    app = buildServer({ logger: false });
    await app.ready();
  }, 120000);

  beforeEach(async () => {
    await BudgetModel.deleteMany({});
    await TransactionModel.deleteMany({});
    await RecurringRunLogModel.deleteMany({});
    await RecurringRuleModel.deleteMany({});
    await CategoryModel.deleteMany({});
    await AccountModel.deleteMany({});
    await RefreshTokenModel.deleteMany({});
    await UserModel.deleteMany({});
  });

  afterAll(async () => {
    await app.close();

    if (mongo) {
      await mongo.stop();
    }
  }, 60000);

  async function registerUser(email: string, name = 'Fin User') {
    const response = await request(app.server).post('/auth/register').send({
      email,
      password: 'Password123',
      name,
    });

    expect(response.status).toBe(201);
    return response.body as {
      accessToken: string;
      refreshToken: string;
      user: { id: string; email: string; name: string | null };
    };
  }

  it('register -> login -> me success', async () => {
    const registerResponse = await request(app.server).post('/auth/register').send({
      email: 'user@example.com',
      password: 'Password123',
      name: 'Fin User',
    });

    expect(registerResponse.status).toBe(201);
    expect(registerResponse.body.user.email).toBe('user@example.com');
    expect(registerResponse.body.accessToken).toBeTypeOf('string');
    expect(registerResponse.body.refreshToken).toBeTypeOf('string');

    const loginResponse = await request(app.server).post('/auth/login').send({
      email: 'user@example.com',
      password: 'Password123',
    });

    expect(loginResponse.status).toBe(200);
    expect(loginResponse.body.user.email).toBe('user@example.com');

    const meResponse = await request(app.server)
      .get('/me')
      .set('Authorization', `Bearer ${loginResponse.body.accessToken}`);

    expect(meResponse.status).toBe(200);
    expect(meResponse.body).toEqual({
      user: {
        id: loginResponse.body.user.id,
        email: 'user@example.com',
        name: 'Fin User',
        baseCurrency: null,
      },
    });
  });

  it('returns invalid credentials on wrong password', async () => {
    await request(app.server).post('/auth/register').send({
      email: 'user@example.com',
      password: 'Password123',
      name: 'Fin User',
    });

    const response = await request(app.server).post('/auth/login').send({
      email: 'user@example.com',
      password: 'WrongPassword',
    });

    expect(response.status).toBe(401);
    expect(response.body).toEqual({
      error: {
        code: 'INVALID_CREDENTIALS',
        message: 'Invalid email or password',
      },
    });
  });

  it('rotates refresh token and invalidates old refresh token', async () => {
    await request(app.server).post('/auth/register').send({
      email: 'user@example.com',
      password: 'Password123',
      name: 'Fin User',
    });

    const loginResponse = await request(app.server).post('/auth/login').send({
      email: 'user@example.com',
      password: 'Password123',
    });

    const oldRefreshToken = loginResponse.body.refreshToken as string;

    const firstRefresh = await request(app.server).post('/auth/refresh').send({
      refreshToken: oldRefreshToken,
    });

    expect(firstRefresh.status).toBe(200);
    expect(firstRefresh.body.refreshToken).not.toBe(oldRefreshToken);

    const reuseOldRefresh = await request(app.server).post('/auth/refresh').send({
      refreshToken: oldRefreshToken,
    });

    expect(reuseOldRefresh.status).toBe(401);
    expect(reuseOldRefresh.body).toEqual({
      error: {
        code: 'INVALID_REFRESH_TOKEN',
        message: 'Refresh token is invalid or expired',
      },
    });
  });

  it('logout revokes refresh token', async () => {
    await request(app.server).post('/auth/register').send({
      email: 'user@example.com',
      password: 'Password123',
      name: 'Fin User',
    });

    const loginResponse = await request(app.server).post('/auth/login').send({
      email: 'user@example.com',
      password: 'Password123',
    });

    const refreshToken = loginResponse.body.refreshToken as string;

    const logoutResponse = await request(app.server).post('/auth/logout').send({ refreshToken });

    expect(logoutResponse.status).toBe(200);
    expect(logoutResponse.body).toEqual({ ok: true });

    const refreshAfterLogout = await request(app.server).post('/auth/refresh').send({ refreshToken });

    expect(refreshAfterLogout.status).toBe(401);
    expect(refreshAfterLogout.body).toEqual({
      error: {
        code: 'INVALID_REFRESH_TOKEN',
        message: 'Refresh token is invalid or expired',
      },
    });
  });

  it('logout returns INVALID_REFRESH_TOKEN for malformed refresh token', async () => {
    const response = await request(app.server).post('/auth/logout').send({
      refreshToken: 'not-a-valid-jwt',
    });

    expect(response.status).toBe(401);
    expect(response.body.error?.code).toBe('INVALID_REFRESH_TOKEN');
  });

  it('/me requires auth token', async () => {
    const response = await request(app.server).get('/me');

    expect(response.status).toBe(401);
    expect(response.body).toEqual({
      error: {
        code: 'UNAUTHORIZED',
        message: 'Missing Authorization header',
      },
    });
  });

  it('first account creation sets user baseCurrency', async () => {
    const session = await registerUser('base-currency-owner@example.com', 'Base Currency Owner');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const createAccount = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });

    expect(createAccount.status).toBe(201);

    const meResponse = await request(app.server).get('/me').set(authHeader);
    expect(meResponse.status).toBe(200);
    expect(meResponse.body.user.baseCurrency).toBe('USD');
  });

  it('creating second account with different currency fails', async () => {
    const session = await registerUser('second-account-currency@example.com', 'Currency Guard');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const firstAccount = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Primary',
      type: 'bank',
      currency: 'USD',
    });
    expect(firstAccount.status).toBe(201);

    const secondAccount = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Secondary',
      type: 'cash',
      currency: 'EUR',
    });

    expect(secondAccount.status).toBe(400);
    expect(secondAccount.body).toEqual({
      error: {
        code: 'BASE_CURRENCY_MISMATCH',
        message: 'Account currency must match your base currency',
      },
    });
  });

  it('updating account currency to a different currency fails', async () => {
    const session = await registerUser('update-currency-owner@example.com', 'Update Currency Owner');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const updateAccount = await request(app.server)
      .patch(`/accounts/${account.body.id}`)
      .set(authHeader)
      .send({ currency: 'EUR' });

    expect(updateAccount.status).toBe(400);
    expect(updateAccount.body).toEqual({
      error: {
        code: 'BASE_CURRENCY_MISMATCH',
        message: 'Account currency must match your base currency',
      },
    });
  });

  it('account CRUD', async () => {
    const session = await registerUser('account-owner@example.com', 'Account Owner');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const createAccount = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Wallet',
      type: 'cash',
      currency: 'USD',
    });

    expect(createAccount.status).toBe(201);
    expect(createAccount.body.name).toBe('Wallet');
    const accountId = createAccount.body.id as string;

    const listAccounts = await request(app.server).get('/accounts').set(authHeader);

    expect(listAccounts.status).toBe(200);
    expect(listAccounts.body.accounts).toHaveLength(1);
    expect(listAccounts.body.accounts[0].id).toBe(accountId);

    const updateAccount = await request(app.server).patch(`/accounts/${accountId}`).set(authHeader).send({
      name: 'Main Wallet',
      type: 'bank',
    });

    expect(updateAccount.status).toBe(200);
    expect(updateAccount.body.name).toBe('Main Wallet');
    expect(updateAccount.body.type).toBe('bank');

    const deleteAccount = await request(app.server).delete(`/accounts/${accountId}`).set(authHeader);

    expect(deleteAccount.status).toBe(200);
    expect(deleteAccount.body).toEqual({ ok: true });

    const listAfterDelete = await request(app.server).get('/accounts').set(authHeader);
    expect(listAfterDelete.status).toBe(200);
    expect(listAfterDelete.body.accounts).toHaveLength(0);
  });

  it('transaction CRUD', async () => {
    const session = await registerUser('tx-owner@example.com', 'Tx Owner');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const accountResponse = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Checking',
      type: 'bank',
      currency: 'USD',
    });
    expect(accountResponse.status).toBe(201);

    const categoryResponse = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Groceries',
      type: 'expense',
      color: '#12AA34',
      icon: 'cart',
    });
    expect(categoryResponse.status).toBe(201);

    const createTx = await request(app.server).post('/transactions').set(authHeader).send({
      accountId: accountResponse.body.id,
      categoryId: categoryResponse.body.id,
      type: 'expense',
      amount: 45.5,
      currency: 'USD',
      description: 'Weekly grocery',
      occurredAt: '2026-02-10T10:30:00.000Z',
    });

    expect(createTx.status).toBe(201);
    expect(createTx.body.amount).toBe(45.5);
    const transactionId = createTx.body.id as string;

    const getTx = await request(app.server).get(`/transactions/${transactionId}`).set(authHeader);
    expect(getTx.status).toBe(200);
    expect(getTx.body.description).toBe('Weekly grocery');

    const updateTx = await request(app.server).patch(`/transactions/${transactionId}`).set(authHeader).send({
      amount: 50,
      description: 'Weekly grocery updated',
    });
    expect(updateTx.status).toBe(200);
    expect(updateTx.body.amount).toBe(50);
    expect(updateTx.body.description).toBe('Weekly grocery updated');

    const deleteTx = await request(app.server).delete(`/transactions/${transactionId}`).set(authHeader);
    expect(deleteTx.status).toBe(200);
    expect(deleteTx.body).toEqual({ ok: true });

    const getAfterDelete = await request(app.server).get(`/transactions/${transactionId}`).set(authHeader);
    expect(getAfterDelete.status).toBe(404);
    expect(getAfterDelete.body.error.code).toBe('TRANSACTION_NOT_FOUND');
  });

  it('transaction listing supports pagination and filters', async () => {
    const session = await registerUser('filter-owner@example.com', 'Filter Owner');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const accountA = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Primary',
      type: 'bank',
      currency: 'USD',
    });
    const accountB = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Cash',
      type: 'cash',
      currency: 'USD',
    });
    expect(accountA.status).toBe(201);
    expect(accountB.status).toBe(201);

    const expenseCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Coffee',
      type: 'expense',
      color: '#AA2211',
      icon: 'cup',
    });
    const incomeCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Salary',
      type: 'income',
      color: '#11AA44',
      icon: 'banknote',
    });
    expect(expenseCategory.status).toBe(201);
    expect(incomeCategory.status).toBe(201);

    const txPayloads = [
      {
        accountId: accountA.body.id,
        categoryId: expenseCategory.body.id,
        type: 'expense',
        amount: 8,
        currency: 'USD',
        description: 'Morning coffee',
        occurredAt: '2026-02-11T08:00:00.000Z',
      },
      {
        accountId: accountA.body.id,
        categoryId: incomeCategory.body.id,
        type: 'income',
        amount: 1200,
        currency: 'USD',
        description: 'Monthly salary',
        occurredAt: '2026-02-09T08:00:00.000Z',
      },
      {
        accountId: accountB.body.id,
        categoryId: expenseCategory.body.id,
        type: 'expense',
        amount: 20,
        currency: 'USD',
        description: 'Coffee beans',
        occurredAt: '2026-02-12T08:00:00.000Z',
      },
    ];

    for (const payload of txPayloads) {
      const created = await request(app.server).post('/transactions').set(authHeader).send(payload);
      expect(created.status).toBe(201);
    }

    const expensePageOne = await request(app.server)
      .get('/transactions')
      .set(authHeader)
      .query({ type: 'expense', limit: 1, page: 1 });

    expect(expensePageOne.status).toBe(200);
    expect(expensePageOne.body.transactions).toHaveLength(1);
    expect(expensePageOne.body.pagination.total).toBe(2);
    expect(expensePageOne.body.pagination.totalPages).toBe(2);
    expect(expensePageOne.body.transactions[0].type).toBe('expense');

    const byAccountAndDate = await request(app.server)
      .get('/transactions')
      .set(authHeader)
      .query({
        accountId: accountA.body.id,
        from: '2026-02-10T00:00:00.000Z',
        to: '2026-02-12T23:59:59.000Z',
      });

    expect(byAccountAndDate.status).toBe(200);
    expect(byAccountAndDate.body.transactions).toHaveLength(1);
    expect(byAccountAndDate.body.transactions[0].description).toBe('Morning coffee');

    const bySearch = await request(app.server).get('/transactions').set(authHeader).query({ search: 'salary' });

    expect(bySearch.status).toBe(200);
    expect(bySearch.body.transactions).toHaveLength(1);
    expect(bySearch.body.transactions[0].description).toBe('Monthly salary');
  });

  it('cannot access another user transaction (object-level auth)', async () => {
    const owner = await registerUser('owner@example.com', 'Owner');
    const ownerHeader = { Authorization: `Bearer ${owner.accessToken}` };
    const attacker = await registerUser('attacker@example.com', 'Attacker');
    const attackerHeader = { Authorization: `Bearer ${attacker.accessToken}` };

    const ownerAccount = await request(app.server).post('/accounts').set(ownerHeader).send({
      name: 'Owner Account',
      type: 'bank',
      currency: 'USD',
    });
    const ownerCategory = await request(app.server).post('/categories').set(ownerHeader).send({
      name: 'Owner Expense',
      type: 'expense',
      color: '#334455',
      icon: 'shield',
    });

    expect(ownerAccount.status).toBe(201);
    expect(ownerCategory.status).toBe(201);

    const ownerTransaction = await request(app.server).post('/transactions').set(ownerHeader).send({
      accountId: ownerAccount.body.id,
      categoryId: ownerCategory.body.id,
      type: 'expense',
      amount: 99,
      currency: 'USD',
      description: 'Private transaction',
      occurredAt: '2026-02-12T08:00:00.000Z',
    });
    expect(ownerTransaction.status).toBe(201);

    const transactionId = ownerTransaction.body.id as string;

    const attackerGet = await request(app.server)
      .get(`/transactions/${transactionId}`)
      .set(attackerHeader);
    expect(attackerGet.status).toBe(404);
    expect(attackerGet.body.error.code).toBe('TRANSACTION_NOT_FOUND');

    const attackerPatch = await request(app.server)
      .patch(`/transactions/${transactionId}`)
      .set(attackerHeader)
      .send({ description: 'hacked' });
    expect(attackerPatch.status).toBe(404);
    expect(attackerPatch.body.error.code).toBe('TRANSACTION_NOT_FOUND');

    const attackerDelete = await request(app.server)
      .delete(`/transactions/${transactionId}`)
      .set(attackerHeader);
    expect(attackerDelete.status).toBe(404);
    expect(attackerDelete.body.error.code).toBe('TRANSACTION_NOT_FOUND');
  });

  it('analytics summary returns month totals and top categories', async () => {
    const session = await registerUser('analytics-summary@example.com', 'Analytics Summary');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const groceriesCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Groceries',
      type: 'expense',
      color: '#00AA44',
      icon: 'cart',
    });
    const rentCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Rent',
      type: 'expense',
      color: '#AA0044',
      icon: 'home',
    });
    const salaryCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Salary',
      type: 'income',
      color: '#4455AA',
      icon: 'wallet',
    });

    expect(groceriesCategory.status).toBe(201);
    expect(rentCategory.status).toBe(201);
    expect(salaryCategory.status).toBe(201);

    const payloads = [
      {
        accountId: account.body.id,
        categoryId: salaryCategory.body.id,
        type: 'income',
        amount: 3000,
        currency: 'USD',
        description: 'March salary',
        occurredAt: '2026-03-01T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: groceriesCategory.body.id,
        type: 'expense',
        amount: 200,
        currency: 'USD',
        description: 'Groceries',
        occurredAt: '2026-03-08T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: rentCategory.body.id,
        type: 'expense',
        amount: 1000,
        currency: 'USD',
        description: 'Rent',
        occurredAt: '2026-03-05T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: groceriesCategory.body.id,
        type: 'expense',
        amount: 80,
        currency: 'USD',
        description: 'Outside month',
        occurredAt: '2026-04-03T12:00:00.000Z',
      },
    ];

    for (const payload of payloads) {
      const created = await request(app.server).post('/transactions').set(authHeader).send(payload);
      expect(created.status).toBe(201);
    }

    const summary = await request(app.server)
      .get('/analytics/summary')
      .set(authHeader)
      .query({ month: '2026-03' });

    expect(summary.status).toBe(200);
    expect(summary.body.month).toBe('2026-03');
    expect(summary.body.currency).toBe('USD');
    expect(summary.body.incomeTotal).toBe(3000);
    expect(summary.body.expenseTotal).toBe(1200);
    expect(summary.body.netTotal).toBe(1800);
    expect(summary.body.transactionCount).toBe(3);

    const groceries = summary.body.topCategories.find(
      (category: { name: string }) => category.name === 'Groceries',
    );
    const salary = summary.body.topCategories.find(
      (category: { name: string }) => category.name === 'Salary',
    );

    expect(groceries).toBeDefined();
    expect(groceries.percent).toBeCloseTo((200 / 1200) * 100, 5);
    expect(salary).toBeDefined();
    expect(salary.percent).toBeCloseTo(100, 5);
  });

  it('analytics by-category returns grouped totals sorted desc', async () => {
    const session = await registerUser('analytics-category@example.com', 'Analytics Category');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const coffeeCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Coffee',
      type: 'expense',
      color: '#663300',
      icon: 'cup',
    });
    const travelCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Travel',
      type: 'expense',
      color: '#003366',
      icon: 'plane',
    });
    expect(coffeeCategory.status).toBe(201);
    expect(travelCategory.status).toBe(201);

    const payloads = [
      {
        accountId: account.body.id,
        categoryId: travelCategory.body.id,
        type: 'expense',
        amount: 900,
        currency: 'USD',
        description: 'Trip',
        occurredAt: '2026-05-01T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: coffeeCategory.body.id,
        type: 'expense',
        amount: 20,
        currency: 'USD',
        description: 'Coffee #1',
        occurredAt: '2026-05-02T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: coffeeCategory.body.id,
        type: 'expense',
        amount: 10,
        currency: 'USD',
        description: 'Coffee #2',
        occurredAt: '2026-05-03T12:00:00.000Z',
      },
    ];

    for (const payload of payloads) {
      const created = await request(app.server).post('/transactions').set(authHeader).send(payload);
      expect(created.status).toBe(201);
    }

    const byCategory = await request(app.server)
      .get('/analytics/by-category')
      .set(authHeader)
      .query({ month: '2026-05', type: 'expense' });

    expect(byCategory.status).toBe(200);
    expect(byCategory.body.month).toBe('2026-05');
    expect(byCategory.body.type).toBe('expense');
    expect(byCategory.body.currency).toBe('USD');
    expect(byCategory.body.categories).toHaveLength(2);
    expect(byCategory.body.categories[0].name).toBe('Travel');
    expect(byCategory.body.categories[0].total).toBe(900);
    expect(byCategory.body.categories[1].name).toBe('Coffee');
    expect(byCategory.body.categories[1].total).toBe(30);
    expect(byCategory.body.categories[1].count).toBe(2);
  });

  it('analytics trend includes zero-filled missing months', async () => {
    const session = await registerUser('analytics-trend@example.com', 'Analytics Trend');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const salaryCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Salary',
      type: 'income',
      color: '#11AA44',
      icon: 'wallet',
    });
    const groceriesCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Groceries',
      type: 'expense',
      color: '#AA1144',
      icon: 'cart',
    });

    expect(salaryCategory.status).toBe(201);
    expect(groceriesCategory.status).toBe(201);

    const payloads = [
      {
        accountId: account.body.id,
        categoryId: salaryCategory.body.id,
        type: 'income',
        amount: 1000,
        currency: 'USD',
        description: 'January income',
        occurredAt: '2026-01-15T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: groceriesCategory.body.id,
        type: 'expense',
        amount: 200,
        currency: 'USD',
        description: 'March expense',
        occurredAt: '2026-03-15T12:00:00.000Z',
      },
    ];

    for (const payload of payloads) {
      const created = await request(app.server).post('/transactions').set(authHeader).send(payload);
      expect(created.status).toBe(201);
    }

    const trend = await request(app.server)
      .get('/analytics/trend')
      .set(authHeader)
      .query({ from: '2026-01', to: '2026-03' });

    expect(trend.status).toBe(200);
    expect(trend.body.currency).toBe('USD');
    expect(trend.body.points).toEqual([
      {
        month: '2026-01',
        incomeTotal: 1000,
        expenseTotal: 0,
        netTotal: 1000,
      },
      {
        month: '2026-02',
        incomeTotal: 0,
        expenseTotal: 0,
        netTotal: 0,
      },
      {
        month: '2026-03',
        incomeTotal: 0,
        expenseTotal: 200,
        netTotal: -200,
      },
    ]);
  });

  it('budgets create and usage reflects month expense transactions', async () => {
    const session = await registerUser('budget-usage@example.com', 'Budget Usage');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const expenseCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Dining',
      type: 'expense',
      color: '#CC5500',
      icon: 'utensils',
    });
    expect(expenseCategory.status).toBe(201);

    const budgetCreate = await request(app.server).post('/budgets').set(authHeader).send({
      categoryId: expenseCategory.body.id,
      month: '2026-06',
      limitAmount: 100,
    });

    expect(budgetCreate.status).toBe(201);

    const payloads = [
      {
        accountId: account.body.id,
        categoryId: expenseCategory.body.id,
        type: 'expense',
        amount: 20,
        currency: 'USD',
        description: 'Meal 1',
        occurredAt: '2026-06-02T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: expenseCategory.body.id,
        type: 'expense',
        amount: 35,
        currency: 'USD',
        description: 'Meal 2',
        occurredAt: '2026-06-10T12:00:00.000Z',
      },
      {
        accountId: account.body.id,
        categoryId: expenseCategory.body.id,
        type: 'expense',
        amount: 12,
        currency: 'USD',
        description: 'Outside month',
        occurredAt: '2026-07-02T12:00:00.000Z',
      },
    ];

    for (const payload of payloads) {
      const created = await request(app.server).post('/transactions').set(authHeader).send(payload);
      expect(created.status).toBe(201);
    }

    const budgets = await request(app.server).get('/budgets').set(authHeader).query({ month: '2026-06' });

    expect(budgets.status).toBe(200);
    expect(budgets.body.budgets).toHaveLength(1);
    expect(budgets.body.budgets[0].categoryName).toBe('Dining');
    expect(budgets.body.budgets[0].spentAmount).toBe(55);
    expect(budgets.body.budgets[0].remainingAmount).toBe(45);
    expect(budgets.body.budgets[0].percentUsed).toBeCloseTo(55, 5);
  });

  it('cannot create budget for income category', async () => {
    const session = await registerUser('budget-income@example.com', 'Budget Income');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });

    const incomeCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Salary',
      type: 'income',
      color: '#00AA44',
      icon: 'wallet',
    });
    expect(incomeCategory.status).toBe(201);

    const createBudget = await request(app.server).post('/budgets').set(authHeader).send({
      categoryId: incomeCategory.body.id,
      month: '2026-06',
      limitAmount: 200,
    });

    expect(createBudget.status).toBe(400);
    expect(createBudget.body).toEqual({
      error: {
        code: 'INVALID_BUDGET_CATEGORY',
        message: 'Category must be an expense category',
      },
    });
  });

  it('budget routes enforce object-level authorization', async () => {
    const owner = await registerUser('budget-owner@example.com', 'Budget Owner');
    const ownerHeader = { Authorization: `Bearer ${owner.accessToken}` };
    const attacker = await registerUser('budget-attacker@example.com', 'Budget Attacker');
    const attackerHeader = { Authorization: `Bearer ${attacker.accessToken}` };

    await request(app.server).post('/accounts').set(ownerHeader).send({
      name: 'Owner Main',
      type: 'bank',
      currency: 'USD',
    });

    const ownerCategory = await request(app.server).post('/categories').set(ownerHeader).send({
      name: 'Owner Category',
      type: 'expense',
      color: '#2222AA',
      icon: 'shield',
    });
    expect(ownerCategory.status).toBe(201);

    const ownerBudget = await request(app.server).post('/budgets').set(ownerHeader).send({
      categoryId: ownerCategory.body.id,
      month: '2026-08',
      limitAmount: 500,
    });
    expect(ownerBudget.status).toBe(201);

    const patchByAttacker = await request(app.server)
      .patch(`/budgets/${ownerBudget.body.id}`)
      .set(attackerHeader)
      .send({ limitAmount: 900 });
    expect(patchByAttacker.status).toBe(404);
    expect(patchByAttacker.body.error.code).toBe('BUDGET_NOT_FOUND');

    const deleteByAttacker = await request(app.server)
      .delete(`/budgets/${ownerBudget.body.id}`)
      .set(attackerHeader);
    expect(deleteByAttacker.status).toBe(404);
    expect(deleteByAttacker.body.error.code).toBe('BUDGET_NOT_FOUND');

    const attackerBudgets = await request(app.server)
      .get('/budgets')
      .set(attackerHeader)
      .query({ month: '2026-08' });
    expect(attackerBudgets.status).toBe(200);
    expect(attackerBudgets.body.budgets).toEqual([]);
  });

  it('soft-deleted transaction is excluded from lists, analytics, and budget usage', async () => {
    const session = await registerUser('soft-delete-tx@example.com', 'Soft Delete');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    expect(account.status).toBe(201);

    const category = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Food',
      type: 'expense',
      color: '#AA3311',
      icon: 'utensils',
    });
    expect(category.status).toBe(201);

    const budget = await request(app.server).post('/budgets').set(authHeader).send({
      categoryId: category.body.id,
      month: '2026-09',
      limitAmount: 200,
    });
    expect(budget.status).toBe(201);

    const createdTx = await request(app.server).post('/transactions').set(authHeader).send({
      accountId: account.body.id,
      categoryId: category.body.id,
      type: 'expense',
      amount: 60,
      currency: 'USD',
      description: 'Lunch',
      occurredAt: '2026-09-07T12:00:00.000Z',
    });
    expect(createdTx.status).toBe(201);

    const deleted = await request(app.server)
      .delete(`/transactions/${createdTx.body.id}`)
      .set(authHeader);
    expect(deleted.status).toBe(200);

    const activeList = await request(app.server).get('/transactions').set(authHeader);
    expect(activeList.status).toBe(200);
    expect(activeList.body.transactions).toHaveLength(0);

    const includeDeletedList = await request(app.server)
      .get('/transactions')
      .set(authHeader)
      .query({ includeDeleted: true });
    expect(includeDeletedList.status).toBe(200);
    expect(includeDeletedList.body.transactions).toHaveLength(1);

    const analytics = await request(app.server)
      .get('/analytics/summary')
      .set(authHeader)
      .query({ month: '2026-09' });
    expect(analytics.status).toBe(200);
    expect(analytics.body.expenseTotal).toBe(0);
    expect(analytics.body.transactionCount).toBe(0);

    const budgets = await request(app.server).get('/budgets').set(authHeader).query({ month: '2026-09' });
    expect(budgets.status).toBe(200);
    expect(budgets.body.budgets).toHaveLength(1);
    expect(budgets.body.budgets[0].spentAmount).toBe(0);
  });

  it('creating a transfer creates paired in/out transactions', async () => {
    const session = await registerUser('transfer-pair@example.com', 'Transfer Pair');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const [fromAccount, toAccount] = await Promise.all([
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Checking',
        type: 'bank',
        currency: 'USD',
      }),
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Cash',
        type: 'cash',
        currency: 'USD',
      }),
    ]);

    expect(fromAccount.status).toBe(201);
    expect(toAccount.status).toBe(201);

    const transfer = await request(app.server).post('/transfers').set(authHeader).send({
      fromAccountId: fromAccount.body.id,
      toAccountId: toAccount.body.id,
      amount: 120.25,
      occurredAt: '2026-09-08T09:00:00.000Z',
      description: 'ATM cashout',
    });

    expect(transfer.status).toBe(201);
    expect(transfer.body.groupId).toBeTypeOf('string');
    expect(transfer.body.fromTransactionId).toBeTypeOf('string');
    expect(transfer.body.toTransactionId).toBeTypeOf('string');

    const transferList = await request(app.server)
      .get('/transactions')
      .set(authHeader)
      .query({ kind: 'transfer', limit: 50, page: 1 });

    expect(transferList.status).toBe(200);
    expect(transferList.body.transactions).toHaveLength(2);

    const directions = transferList.body.transactions.map(
      (transaction: { transferDirection: string | null }) => transaction.transferDirection,
    );
    expect(directions).toContain('in');
    expect(directions).toContain('out');

    const groupIds = new Set(
      transferList.body.transactions.map((transaction: { transferGroupId: string | null }) => transaction.transferGroupId),
    );
    expect(groupIds.size).toBe(1);
  });

  it('dashboard balances reflect transfer while total net stays unchanged', async () => {
    const session = await registerUser('transfer-balance@example.com', 'Transfer Balance');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const [accountA, accountB] = await Promise.all([
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Bank',
        type: 'bank',
        currency: 'USD',
      }),
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Wallet',
        type: 'cash',
        currency: 'USD',
      }),
    ]);
    expect(accountA.status).toBe(201);
    expect(accountB.status).toBe(201);

    const incomeCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Salary',
      type: 'income',
      color: '#11AA44',
      icon: 'wallet',
    });
    expect(incomeCategory.status).toBe(201);

    const seedIncome = await request(app.server).post('/transactions').set(authHeader).send({
      accountId: accountA.body.id,
      categoryId: incomeCategory.body.id,
      type: 'income',
      amount: 500,
      currency: 'USD',
      description: 'Seed funds',
      occurredAt: '2026-09-09T08:00:00.000Z',
    });
    expect(seedIncome.status).toBe(201);

    const transfer = await request(app.server).post('/transfers').set(authHeader).send({
      fromAccountId: accountA.body.id,
      toAccountId: accountB.body.id,
      amount: 200,
      occurredAt: '2026-09-09T09:00:00.000Z',
      description: 'Move to wallet',
    });
    expect(transfer.status).toBe(201);

    const dashboard = await request(app.server).get('/dashboard/recent').set(authHeader);
    expect(dashboard.status).toBe(200);
    expect(dashboard.body.totalBalance).toBe(500);

    const balanceMap = new Map(
      dashboard.body.balances.map((entry: { accountId: string; balance: number }) => [
        entry.accountId,
        entry.balance,
      ]),
    );

    expect(balanceMap.get(accountA.body.id)).toBe(300);
    expect(balanceMap.get(accountB.body.id)).toBe(200);
  });

  it('cannot transfer between accounts owned by different users', async () => {
    const owner = await registerUser('transfer-owner@example.com', 'Transfer Owner');
    const ownerHeader = { Authorization: `Bearer ${owner.accessToken}` };
    const otherUser = await registerUser('transfer-other@example.com', 'Transfer Other');
    const otherHeader = { Authorization: `Bearer ${otherUser.accessToken}` };

    const ownerAccount = await request(app.server).post('/accounts').set(ownerHeader).send({
      name: 'Owner Account',
      type: 'bank',
      currency: 'USD',
    });
    const otherAccount = await request(app.server).post('/accounts').set(otherHeader).send({
      name: 'Other Account',
      type: 'bank',
      currency: 'USD',
    });

    expect(ownerAccount.status).toBe(201);
    expect(otherAccount.status).toBe(201);

    const forbiddenTransfer = await request(app.server).post('/transfers').set(ownerHeader).send({
      fromAccountId: ownerAccount.body.id,
      toAccountId: otherAccount.body.id,
      amount: 50,
      occurredAt: '2026-09-10T12:00:00.000Z',
    });

    expect(forbiddenTransfer.status).toBe(404);
    expect(forbiddenTransfer.body.error.code).toBe('ACCOUNT_NOT_FOUND');
  });

  it('weekly recurring rule generates one transaction and advances nextRunAt', async () => {
    const session = await registerUser('recurring-weekly@example.com', 'Recurring Weekly');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    const category = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Utilities',
      type: 'expense',
      color: '#3344AA',
      icon: 'bolt',
    });
    expect(account.status).toBe(201);
    expect(category.status).toBe(201);

    const createRule = await request(app.server).post('/recurring').set(authHeader).send({
      kind: 'normal',
      accountId: account.body.id,
      categoryId: category.body.id,
      type: 'expense',
      amount: 25,
      description: 'Weekly utility',
      cadence: 'weekly',
      dayOfWeek: 1,
      startAt: new Date().toISOString(),
    });
    expect(createRule.status).toBe(201);

    const ruleId = createRule.body.id as string;
    const dueAt = new Date(Date.now() - 60 * 1000);
    await RecurringRuleModel.updateOne(
      { _id: ruleId },
      {
        $set: {
          nextRunAt: dueAt,
          lastRunAt: null,
          isPaused: false,
        },
      },
    );

    const runDue = await request(app.server)
      .post('/recurring/run-due')
      .set('x-cron-secret', 'test-cron-secret')
      .send({});

    expect(runDue.status).toBe(200);
    expect(runDue.body.processedRuns).toBe(1);
    expect(runDue.body.generatedTransactions).toBe(1);

    const rule = await RecurringRuleModel.findById(ruleId);
    expect(rule).toBeTruthy();
    expect(rule?.lastRunAt?.toISOString()).toBe(dueAt.toISOString());
    expect(rule?.nextRunAt.toISOString()).toBe(
      new Date(dueAt.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString(),
    );

    const generatedTransactions = await request(app.server)
      .get('/transactions')
      .set(authHeader)
      .query({ kind: 'normal' });
    expect(generatedTransactions.status).toBe(200);
    expect(generatedTransactions.body.transactions).toHaveLength(1);
  });

  it('monthly recurring rule generates one transaction and advances to next month', async () => {
    const session = await registerUser('recurring-monthly@example.com', 'Recurring Monthly');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    const category = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Subscription',
      type: 'expense',
      color: '#AA8844',
      icon: 'card',
    });
    expect(account.status).toBe(201);
    expect(category.status).toBe(201);

    const createRule = await request(app.server).post('/recurring').set(authHeader).send({
      kind: 'normal',
      accountId: account.body.id,
      categoryId: category.body.id,
      type: 'expense',
      amount: 15,
      description: 'Monthly plan',
      cadence: 'monthly',
      dayOfMonth: 1,
      startAt: new Date().toISOString(),
    });
    expect(createRule.status).toBe(201);

    const ruleId = createRule.body.id as string;
    const now = new Date();
    const dueAt = new Date(
      Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), 1, now.getUTCHours(), now.getUTCMinutes(), 0, 0),
    );
    await RecurringRuleModel.updateOne(
      { _id: ruleId },
      {
        $set: {
          nextRunAt: dueAt,
          lastRunAt: null,
          isPaused: false,
        },
      },
    );

    const runDue = await request(app.server)
      .post('/recurring/run-due')
      .set('x-cron-secret', 'test-cron-secret')
      .send({});

    expect(runDue.status).toBe(200);
    expect(runDue.body.processedRuns).toBe(1);
    expect(runDue.body.generatedTransactions).toBe(1);

    const expectedNextRun = new Date(
      Date.UTC(
        dueAt.getUTCFullYear(),
        dueAt.getUTCMonth() + 1,
        1,
        dueAt.getUTCHours(),
        dueAt.getUTCMinutes(),
        dueAt.getUTCSeconds(),
        dueAt.getUTCMilliseconds(),
      ),
    );

    const rule = await RecurringRuleModel.findById(ruleId);
    expect(rule).toBeTruthy();
    expect(rule?.lastRunAt?.toISOString()).toBe(dueAt.toISOString());
    expect(rule?.nextRunAt.toISOString()).toBe(expectedNextRun.toISOString());
  });

  it('transfer recurring rule generates paired transactions', async () => {
    const session = await registerUser('recurring-transfer@example.com', 'Recurring Transfer');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const [fromAccount, toAccount] = await Promise.all([
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Bank',
        type: 'bank',
        currency: 'USD',
      }),
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Cash',
        type: 'cash',
        currency: 'USD',
      }),
    ]);

    expect(fromAccount.status).toBe(201);
    expect(toAccount.status).toBe(201);

    const createRule = await request(app.server).post('/recurring').set(authHeader).send({
      kind: 'transfer',
      fromAccountId: fromAccount.body.id,
      toAccountId: toAccount.body.id,
      amount: 40,
      description: 'Weekly transfer',
      cadence: 'weekly',
      dayOfWeek: 2,
      startAt: new Date().toISOString(),
    });
    expect(createRule.status).toBe(201);

    const ruleId = createRule.body.id as string;
    const dueAt = new Date(Date.now() - 60 * 1000);
    await RecurringRuleModel.updateOne(
      { _id: ruleId },
      {
        $set: {
          nextRunAt: dueAt,
          lastRunAt: null,
          isPaused: false,
        },
      },
    );

    const runDue = await request(app.server)
      .post('/recurring/run-due')
      .set('x-cron-secret', 'test-cron-secret')
      .send({});

    expect(runDue.status).toBe(200);
    expect(runDue.body.processedRuns).toBe(1);
    expect(runDue.body.generatedTransactions).toBe(2);

    const transfers = await request(app.server)
      .get('/transactions')
      .set(authHeader)
      .query({ kind: 'transfer' });
    expect(transfers.status).toBe(200);
    expect(transfers.body.transactions).toHaveLength(2);
  });

  it('paused and soft-deleted recurring rules are not executed', async () => {
    const session = await registerUser('recurring-paused@example.com', 'Recurring Paused');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const account = await request(app.server).post('/accounts').set(authHeader).send({
      name: 'Main',
      type: 'bank',
      currency: 'USD',
    });
    const category = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Bills',
      type: 'expense',
      color: '#7733AA',
      icon: 'receipt',
    });
    expect(account.status).toBe(201);
    expect(category.status).toBe(201);

    const pausedRule = await request(app.server).post('/recurring').set(authHeader).send({
      kind: 'normal',
      accountId: account.body.id,
      categoryId: category.body.id,
      type: 'expense',
      amount: 20,
      cadence: 'weekly',
      dayOfWeek: 3,
      startAt: new Date().toISOString(),
    });
    const deletedRule = await request(app.server).post('/recurring').set(authHeader).send({
      kind: 'normal',
      accountId: account.body.id,
      categoryId: category.body.id,
      type: 'expense',
      amount: 30,
      cadence: 'weekly',
      dayOfWeek: 4,
      startAt: new Date().toISOString(),
    });
    expect(pausedRule.status).toBe(201);
    expect(deletedRule.status).toBe(201);

    const dueAt = new Date(Date.now() - 60 * 1000);
    await RecurringRuleModel.updateOne(
      { _id: pausedRule.body.id },
      {
        $set: {
          nextRunAt: dueAt,
          isPaused: true,
        },
      },
    );
    await RecurringRuleModel.updateOne(
      { _id: deletedRule.body.id },
      {
        $set: {
          nextRunAt: dueAt,
          deletedAt: new Date(),
          isPaused: false,
        },
      },
    );

    const runDue = await request(app.server)
      .post('/recurring/run-due')
      .set('x-cron-secret', 'test-cron-secret')
      .send({});

    expect(runDue.status).toBe(200);
    expect(runDue.body.processedRules).toBe(0);
    expect(runDue.body.processedRuns).toBe(0);
    expect(runDue.body.generatedTransactions).toBe(0);

    const txCount = await TransactionModel.countDocuments({});
    expect(txCount).toBe(0);
  });

  it('exports transactions csv with expected headers and rows', async () => {
    const session = await registerUser('export-csv@example.com', 'CSV Export');
    const authHeader = { Authorization: `Bearer ${session.accessToken}` };

    const [bank, wallet] = await Promise.all([
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Bank',
        type: 'bank',
        currency: 'USD',
      }),
      request(app.server).post('/accounts').set(authHeader).send({
        name: 'Wallet',
        type: 'cash',
        currency: 'USD',
      }),
    ]);
    expect(bank.status).toBe(201);
    expect(wallet.status).toBe(201);

    const expenseCategory = await request(app.server).post('/categories').set(authHeader).send({
      name: 'Groceries',
      type: 'expense',
      color: '#22AA66',
      icon: 'cart',
    });
    expect(expenseCategory.status).toBe(201);

    const normalTx = await request(app.server).post('/transactions').set(authHeader).send({
      accountId: bank.body.id,
      categoryId: expenseCategory.body.id,
      type: 'expense',
      amount: 35,
      currency: 'USD',
      description: 'Grocery run',
      occurredAt: '2026-09-10T08:00:00.000Z',
    });
    expect(normalTx.status).toBe(201);

    const transfer = await request(app.server).post('/transfers').set(authHeader).send({
      fromAccountId: bank.body.id,
      toAccountId: wallet.body.id,
      amount: 20,
      occurredAt: '2026-09-10T09:00:00.000Z',
      description: 'Cash move',
    });
    expect(transfer.status).toBe(201);

    const csvResponse = await request(app.server)
      .get('/export/transactions.csv')
      .set(authHeader)
      .query({
        from: '2026-09-01T00:00:00.000Z',
        to: '2026-09-30T23:59:59.000Z',
      });

    expect(csvResponse.status).toBe(200);
    expect(csvResponse.headers['content-type']).toContain('text/csv');

    const lines = csvResponse.text.trim().split('\n');
    expect(lines[0]).toBe(
      'occurredAt,type,kind,accountName,categoryName,amount,currency,description',
    );
    expect(lines.length).toBeGreaterThan(1);
    expect(csvResponse.text).toContain(',normal,');
    expect(csvResponse.text).toContain(',transfer,');
  });
});

### /Users/umutugur/finsight/apps/mobile/src/api/queryKeys.ts
import type { CategoryType } from '@finsight/shared';

export const financeQueryKeys = {
  dashboard: {
    recent: () => ['dashboard', 'recent'] as const,
  },
  accounts: {
    all: () => ['accounts'] as const,
    list: () => ['accounts', 'list'] as const,
  },
  categories: {
    all: () => ['categories'] as const,
    list: () => ['categories', 'list'] as const,
  },
  transactions: {
    all: () => ['transactions'] as const,
    list: (filters: Record<string, unknown>) => ['transactions', 'list', filters] as const,
  },
  recurring: {
    all: () => ['recurring'] as const,
    list: (filters: Record<string, unknown>) => ['recurring', 'list', filters] as const,
  },
  analytics: {
    all: () => ['analytics'] as const,
    month: (month: string) => ['analytics', month] as const,
    summary: (month: string) => ['analytics', month, 'summary'] as const,
    byCategory: (month: string, type: CategoryType) =>
      ['analytics', month, 'by-category', type] as const,
    trend: (month: string, from: string, to: string) =>
      ['analytics', month, 'trend', { from, to }] as const,
  },
  budgets: {
    all: () => ['budgets'] as const,
    month: (month: string) => ['budgets', month] as const,
    list: (month: string) => ['budgets', month, 'list'] as const,
  },
};

### /Users/umutugur/finsight/apps/mobile/src/navigation/stacks/TransactionsStack.tsx
import { createNativeStackNavigator } from '@react-navigation/native-stack';

import { RecurringScreen } from '../../screens/finance/RecurringScreen';
import { TransferScreen } from '../../screens/finance/TransferScreen';
import { TransactionsScreen } from '../../screens/finance/TransactionsScreen';

const Stack = createNativeStackNavigator();

export function TransactionsStack() {
  return (
    <Stack.Navigator>
      <Stack.Screen name="Transactions" component={TransactionsScreen} options={{ title: 'Transactions' }} />
      <Stack.Screen name="Transfer" component={TransferScreen} options={{ title: 'Transfer' }} />
      <Stack.Screen name="Recurring" component={RecurringScreen} options={{ title: 'Recurring' }} />
    </Stack.Navigator>
  );
}

### /Users/umutugur/finsight/apps/mobile/src/components/ui/TransactionRow.tsx
import { StyleSheet, Text, View } from 'react-native';

import { colors, radius, spacing, typography } from '../../theme';

import { Card } from './Card';

interface TransactionRowProps {
  title: string;
  date: string;
  amount: string;
  type: 'income' | 'expense';
  kind?: 'normal' | 'transfer';
  dark?: boolean;
}

export function TransactionRow({ title, date, amount, type, kind = 'normal', dark = false }: TransactionRowProps) {
  return (
    <Card dark={dark} style={styles.card}>
      <View style={[styles.badge, { backgroundColor: type === 'income' ? '#E7F9EF' : '#FEECEE' }]}>
        <Text style={[styles.badgeText, { color: type === 'income' ? colors.income : colors.expense }]}>
          {type === 'income' ? '+' : '-'}
        </Text>
      </View>

      <View style={styles.meta}>
        <View style={styles.titleRow}>
          <Text style={[styles.title, { color: dark ? colors.dark.text : colors.text }]}>{title}</Text>
          {kind === 'transfer' ? (
            <View style={styles.kindBadge}>
              <Text style={styles.kindBadgeText}>TRANSFER</Text>
            </View>
          ) : null}
        </View>
        <Text style={[styles.date, { color: dark ? colors.dark.textMuted : colors.textMuted }]}>{date}</Text>
      </View>

      <Text style={[styles.amount, { color: type === 'income' ? colors.income : colors.expense }]}>{amount}</Text>
    </Card>
  );
}

const styles = StyleSheet.create({
  card: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.sm,
  },
  badge: {
    width: 36,
    height: 36,
    borderRadius: radius.full,
    alignItems: 'center',
    justifyContent: 'center',
  },
  badgeText: {
    ...typography.subheading,
  },
  meta: {
    flex: 1,
    gap: spacing.xxs,
  },
  titleRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.xs,
  },
  title: {
    ...typography.body,
    fontWeight: '600',
    flexShrink: 1,
  },
  kindBadge: {
    paddingHorizontal: spacing.xs,
    paddingVertical: 2,
    borderRadius: radius.full,
    backgroundColor: colors.primaryMuted,
  },
  kindBadgeText: {
    ...typography.caption,
    color: colors.primary,
    fontWeight: '700',
    fontSize: 10,
  },
  date: {
    ...typography.caption,
  },
  amount: {
    ...typography.subheading,
  },
});

### /Users/umutugur/finsight/apps/mobile/src/screens/finance/DashboardScreen.tsx
import { useMemo } from 'react';
import { ActivityIndicator, StyleSheet, Text, View } from 'react-native';

import { useQuery } from '@tanstack/react-query';

import { useAuth } from '../../auth/AuthProvider';
import { apiClient } from '../../api/client';
import { financeQueryKeys } from '../../api/queryKeys';
import {
  Card,
  CategoryRow,
  Chip,
  PrimaryButton,
  ScreenContainer,
  Section,
  StatCard,
  TransactionRow,
} from '../../components/ui';
import { colors, spacing, typography } from '../../theme';
import { apiErrorText } from '../../utils/apiErrorText';

function formatAmount(amount: number, currency: string, type?: 'income' | 'expense') {
  const formatter = new Intl.NumberFormat(undefined, {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  });
  const rendered = formatter.format(amount);

  if (!type) {
    return rendered;
  }

  return `${type === 'expense' ? '-' : '+'}${rendered}`;
}

function formatDateLabel(value: string) {
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return value;
  }

  return date.toLocaleDateString(undefined, {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
  });
}

export function DashboardScreen() {
  const { withAuth, user } = useAuth();

  const dashboardQuery = useQuery({
    queryKey: financeQueryKeys.dashboard.recent(),
    queryFn: () => withAuth((token) => apiClient.getDashboardRecent(token)),
  });

  const currency = useMemo(() => {
    if (dashboardQuery.data?.balances[0]?.currency) {
      return dashboardQuery.data.balances[0].currency;
    }

    return user?.baseCurrency ?? 'USD';
  }, [dashboardQuery.data?.balances, user?.baseCurrency]);

  if (dashboardQuery.isLoading) {
    return (
      <ScreenContainer>
        <View style={styles.centerState}>
          <ActivityIndicator size="large" color={colors.primary} />
          <Text style={styles.stateText}>Loading dashboard...</Text>
        </View>
      </ScreenContainer>
    );
  }

  if (dashboardQuery.isError) {
    return (
      <ScreenContainer>
        <Card style={styles.errorCard}>
          <Text style={styles.errorTitle}>Dashboard unavailable</Text>
          <Text style={styles.errorText}>{apiErrorText(dashboardQuery.error)}</Text>
          <PrimaryButton label="Try again" onPress={() => void dashboardQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  const data = dashboardQuery.data;
  if (!data) {
    return (
      <ScreenContainer>
        <Card>
          <Text style={styles.emptyText}>No dashboard data available.</Text>
        </Card>
      </ScreenContainer>
    );
  }

  return (
    <ScreenContainer>
      <Section title="Total Balance" subtitle="Single base currency assumption">
        <View style={styles.heroWrap}>
          <StatCard
            label="Portfolio Total"
            value={formatAmount(data.totalBalance, currency)}
            detail={`Base currency: ${user?.baseCurrency ?? currency}`}
            tone="primary"
          />
          <View style={styles.heroChips}>
            <Chip label={`${data.balances.length} accounts`} tone="primary" />
            <Chip label={`${data.recentTransactions.length} recent tx`} />
          </View>
        </View>
      </Section>

      <Section title="Account Balances">
        {data.balances.length === 0 ? (
          <Card>
            <Text style={styles.emptyText}>No accounts yet. Create your first account from Profile tab.</Text>
          </Card>
        ) : (
          data.balances.map((balance) => (
            <CategoryRow
              key={balance.accountId}
              title={balance.name}
              subtitle={balance.type.toUpperCase()}
              amount={formatAmount(balance.balance, balance.currency)}
              amountTone={balance.balance < 0 ? 'expense' : 'neutral'}
            />
          ))
        )}
      </Section>

      <Section title="Recent Transactions" subtitle="Last 10">
        {data.recentTransactions.length === 0 ? (
          <Card>
            <Text style={styles.emptyText}>No transactions yet.</Text>
          </Card>
        ) : (
          data.recentTransactions.map((transaction) => (
            <TransactionRow
              key={transaction.id}
              title={transaction.description ?? 'Untitled transaction'}
              date={formatDateLabel(transaction.occurredAt)}
              amount={formatAmount(transaction.amount, transaction.currency, transaction.type)}
              type={transaction.type}
              kind={transaction.kind}
            />
          ))
        )}
      </Section>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  centerState: {
    alignItems: 'center',
    justifyContent: 'center',
    gap: spacing.sm,
    paddingVertical: spacing.xxl,
  },
  stateText: {
    ...typography.body,
    color: colors.textMuted,
  },
  heroWrap: {
    gap: spacing.sm,
  },
  heroChips: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  emptyText: {
    ...typography.body,
    color: colors.textMuted,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
    color: colors.text,
  },
  errorText: {
    ...typography.body,
    color: colors.expense,
  },
});

### /Users/umutugur/finsight/apps/mobile/src/screens/finance/TransactionsScreen.tsx
import { useMemo, useState } from 'react';
import {
  ActivityIndicator,
  FlatList,
  Pressable,
  RefreshControl,
  StyleSheet,
  Text,
  TextInput,
  View,
} from 'react-native';

import { useNavigation } from '@react-navigation/native';
import { useInfiniteQuery, useQuery } from '@tanstack/react-query';
import type { NativeStackNavigationProp } from '@react-navigation/native-stack';

import { useAuth } from '../../auth/AuthProvider';
import { apiClient } from '../../api/client';
import { financeQueryKeys } from '../../api/queryKeys';
import { Card, Chip, PrimaryButton, ScreenContainer, Section, TransactionRow } from '../../components/ui';
import { colors, radius, spacing, typography } from '../../theme';
import { apiErrorText } from '../../utils/apiErrorText';

type TypeFilter = 'all' | 'income' | 'expense';
type KindFilter = 'all' | 'normal' | 'transfer';

type TransactionsStackParamList = {
  Transactions: undefined;
  Transfer: undefined;
  Recurring: undefined;
};

interface FilterDraft {
  accountId: string;
  type: TypeFilter;
  kind: KindFilter;
  search: string;
  from: string;
  to: string;
}

const DEFAULT_FILTERS: FilterDraft = {
  accountId: '',
  type: 'all',
  kind: 'all',
  search: '',
  from: '',
  to: '',
};

function toStartOfDayIso(value: string) {
  if (!value.trim()) {
    return undefined;
  }

  const date = new Date(`${value.trim()}T00:00:00.000Z`);
  if (Number.isNaN(date.getTime())) {
    return undefined;
  }

  return date.toISOString();
}

function toEndOfDayIso(value: string) {
  if (!value.trim()) {
    return undefined;
  }

  const date = new Date(`${value.trim()}T23:59:59.999Z`);
  if (Number.isNaN(date.getTime())) {
    return undefined;
  }

  return date.toISOString();
}

function formatAmount(amount: number, currency: string, type: 'income' | 'expense') {
  const formatter = new Intl.NumberFormat(undefined, {
    style: 'currency',
    currency,
    maximumFractionDigits: 2,
  });

  return `${type === 'expense' ? '-' : '+'}${formatter.format(amount)}`;
}

function formatDate(value: string) {
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return value;
  }

  return date.toLocaleDateString(undefined, {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
  });
}

export function TransactionsScreen() {
  const { withAuth } = useAuth();
  const navigation = useNavigation<NativeStackNavigationProp<TransactionsStackParamList>>();

  const [draftFilters, setDraftFilters] = useState<FilterDraft>(DEFAULT_FILTERS);
  const [activeFilters, setActiveFilters] = useState<FilterDraft>(DEFAULT_FILTERS);

  const accountQuery = useQuery({
    queryKey: financeQueryKeys.accounts.list(),
    queryFn: () => withAuth((token) => apiClient.getAccounts(token)),
  });

  const queryFilters = useMemo(
    () => ({
      accountId: activeFilters.accountId || undefined,
      type: activeFilters.type === 'all' ? undefined : activeFilters.type,
      kind: activeFilters.kind === 'all' ? undefined : activeFilters.kind,
      search: activeFilters.search.trim() || undefined,
      from: toStartOfDayIso(activeFilters.from),
      to: toEndOfDayIso(activeFilters.to),
    }),
    [activeFilters],
  );

  const transactionsQuery = useInfiniteQuery({
    queryKey: financeQueryKeys.transactions.list(queryFilters),
    initialPageParam: 1,
    queryFn: ({ pageParam }) =>
      withAuth((token) =>
        apiClient.listTransactions(
          {
            ...queryFilters,
            page: pageParam,
            limit: 20,
          },
          token,
        ),
      ),
    getNextPageParam: (lastPage) => {
      if (lastPage.pagination.page >= lastPage.pagination.totalPages) {
        return undefined;
      }

      return lastPage.pagination.page + 1;
    },
  });

  const transactions = useMemo(
    () => transactionsQuery.data?.pages.flatMap((page) => page.transactions) ?? [],
    [transactionsQuery.data?.pages],
  );

  const renderHeader = () => (
    <View style={styles.headerWrap}>
      <Section title="Filters" subtitle="Apply to refresh paginated results">
        <Card style={styles.filterCard}>
          <View style={styles.quickActions}>
            <PrimaryButton label="New Transfer" onPress={() => navigation.navigate('Transfer')} />
            <Pressable style={styles.secondaryAction} onPress={() => navigation.navigate('Recurring')}>
              <Text style={styles.secondaryActionText}>Recurring Rules</Text>
            </Pressable>
          </View>

          <Text style={styles.fieldLabel}>Search</Text>
          <TextInput
            style={styles.input}
            value={draftFilters.search}
            onChangeText={(search) => setDraftFilters((prev) => ({ ...prev, search }))}
            placeholder="Description contains..."
            placeholderTextColor={colors.textMuted}
          />

          <Text style={styles.fieldLabel}>Type</Text>
          <View style={styles.chipWrap}>
            <Pressable onPress={() => setDraftFilters((prev) => ({ ...prev, type: 'all' }))}>
              <Chip label="ALL" tone={draftFilters.type === 'all' ? 'primary' : 'default'} />
            </Pressable>
            <Pressable onPress={() => setDraftFilters((prev) => ({ ...prev, type: 'income' }))}>
              <Chip label="INCOME" tone={draftFilters.type === 'income' ? 'income' : 'default'} />
            </Pressable>
            <Pressable onPress={() => setDraftFilters((prev) => ({ ...prev, type: 'expense' }))}>
              <Chip label="EXPENSE" tone={draftFilters.type === 'expense' ? 'expense' : 'default'} />
            </Pressable>
          </View>

          <Text style={styles.fieldLabel}>Kind</Text>
          <View style={styles.chipWrap}>
            <Pressable onPress={() => setDraftFilters((prev) => ({ ...prev, kind: 'all' }))}>
              <Chip label="ALL" tone={draftFilters.kind === 'all' ? 'primary' : 'default'} />
            </Pressable>
            <Pressable onPress={() => setDraftFilters((prev) => ({ ...prev, kind: 'normal' }))}>
              <Chip label="NORMAL" tone={draftFilters.kind === 'normal' ? 'primary' : 'default'} />
            </Pressable>
            <Pressable onPress={() => setDraftFilters((prev) => ({ ...prev, kind: 'transfer' }))}>
              <Chip label="TRANSFER" tone={draftFilters.kind === 'transfer' ? 'primary' : 'default'} />
            </Pressable>
          </View>

          <Text style={styles.fieldLabel}>Account</Text>
          <View style={styles.chipWrap}>
            <Pressable onPress={() => setDraftFilters((prev) => ({ ...prev, accountId: '' }))}>
              <Chip label="ALL ACCOUNTS" tone={draftFilters.accountId === '' ? 'primary' : 'default'} />
            </Pressable>
            {accountQuery.data?.accounts.map((account) => (
              <Pressable
                key={account.id}
                onPress={() => setDraftFilters((prev) => ({ ...prev, accountId: account.id }))}
              >
                <Chip
                  label={account.name}
                  tone={draftFilters.accountId === account.id ? 'primary' : 'default'}
                />
              </Pressable>
            ))}
          </View>

          <View style={styles.dateRow}>
            <View style={styles.dateField}>
              <Text style={styles.fieldLabel}>From (YYYY-MM-DD)</Text>
              <TextInput
                style={styles.input}
                value={draftFilters.from}
                onChangeText={(from) => setDraftFilters((prev) => ({ ...prev, from }))}
                placeholder="2026-02-01"
                autoCapitalize="none"
                placeholderTextColor={colors.textMuted}
              />
            </View>
            <View style={styles.dateField}>
              <Text style={styles.fieldLabel}>To (YYYY-MM-DD)</Text>
              <TextInput
                style={styles.input}
                value={draftFilters.to}
                onChangeText={(to) => setDraftFilters((prev) => ({ ...prev, to }))}
                placeholder="2026-02-28"
                autoCapitalize="none"
                placeholderTextColor={colors.textMuted}
              />
            </View>
          </View>

          <View style={styles.actionRow}>
            <PrimaryButton
              label="Apply Filters"
              onPress={() => {
                setActiveFilters(draftFilters);
              }}
            />
            <Pressable
              style={styles.secondaryAction}
              onPress={() => {
                setDraftFilters(DEFAULT_FILTERS);
                setActiveFilters(DEFAULT_FILTERS);
              }}
            >
              <Text style={styles.secondaryActionText}>Reset</Text>
            </Pressable>
          </View>
        </Card>
      </Section>

      <Section title="Transactions" subtitle={`${transactions.length} loaded`}>
        {transactions.length === 0 && !transactionsQuery.isFetching ? (
          <Card>
            <Text style={styles.emptyText}>No transactions match current filters.</Text>
          </Card>
        ) : null}
      </Section>
    </View>
  );

  if (transactionsQuery.isLoading) {
    return (
      <ScreenContainer>
        <View style={styles.centerState}>
          <ActivityIndicator size="large" color={colors.primary} />
          <Text style={styles.stateText}>Loading transactions...</Text>
        </View>
      </ScreenContainer>
    );
  }

  if (transactionsQuery.isError) {
    return (
      <ScreenContainer>
        <Card style={styles.errorCard}>
          <Text style={styles.errorTitle}>Could not load transactions</Text>
          <Text style={styles.errorText}>{apiErrorText(transactionsQuery.error)}</Text>
          <PrimaryButton label="Retry" onPress={() => void transactionsQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  return (
    <ScreenContainer scrollable={false} contentStyle={styles.containerContent}>
      <FlatList
        data={transactions}
        keyExtractor={(item) => item.id}
        ListHeaderComponent={renderHeader}
        ListFooterComponent={
          transactionsQuery.hasNextPage ? (
            <View style={styles.footer}>
              <PrimaryButton
                label={transactionsQuery.isFetchingNextPage ? 'Loading...' : 'Load more'}
                onPress={() => {
                  void transactionsQuery.fetchNextPage();
                }}
              />
            </View>
          ) : (
            <View style={styles.footerSpacer} />
          )
        }
        renderItem={({ item }) => (
          <TransactionRow
            title={item.description ?? (item.kind === 'transfer' ? 'Account transfer' : 'Untitled transaction')}
            date={formatDate(item.occurredAt)}
            amount={formatAmount(item.amount, item.currency, item.type)}
            type={item.type}
            kind={item.kind}
          />
        )}
        ItemSeparatorComponent={() => <View style={styles.separator} />}
        contentContainerStyle={styles.listContent}
        refreshControl={
          <RefreshControl
            refreshing={transactionsQuery.isRefetching && !transactionsQuery.isFetchingNextPage}
            onRefresh={() => {
              void transactionsQuery.refetch();
            }}
            tintColor={colors.primary}
          />
        }
      />
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  containerContent: {
    flex: 1,
    paddingTop: 0,
  },
  listContent: {
    gap: spacing.xs,
    paddingBottom: spacing.xl,
  },
  headerWrap: {
    gap: spacing.sm,
    marginBottom: spacing.sm,
  },
  centerState: {
    alignItems: 'center',
    justifyContent: 'center',
    gap: spacing.sm,
    paddingVertical: spacing.xxl,
  },
  stateText: {
    ...typography.body,
    color: colors.textMuted,
  },
  filterCard: {
    gap: spacing.sm,
  },
  quickActions: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.xs,
  },
  fieldLabel: {
    ...typography.caption,
    color: colors.textMuted,
  },
  input: {
    height: 44,
    borderWidth: 1,
    borderColor: colors.border,
    borderRadius: radius.md,
    backgroundColor: colors.surface,
    paddingHorizontal: spacing.sm,
    color: colors.text,
    ...typography.body,
  },
  chipWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  dateRow: {
    flexDirection: 'row',
    gap: spacing.sm,
  },
  dateField: {
    flex: 1,
    gap: spacing.xxs,
  },
  actionRow: {
    gap: spacing.xs,
  },
  secondaryAction: {
    height: 40,
    borderWidth: 1,
    borderColor: colors.border,
    borderRadius: radius.md,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: colors.surface,
  },
  secondaryActionText: {
    ...typography.caption,
    color: colors.textMuted,
    fontWeight: '600',
  },
  separator: {
    height: spacing.xs,
  },
  footer: {
    marginTop: spacing.md,
  },
  footerSpacer: {
    height: spacing.xl,
  },
  emptyText: {
    ...typography.body,
    color: colors.textMuted,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorTitle: {
    ...typography.subheading,
    color: colors.text,
  },
  errorText: {
    ...typography.caption,
    color: colors.expense,
  },
});

### /Users/umutugur/finsight/apps/mobile/src/screens/finance/TransferScreen.tsx
import { Alert, Pressable, StyleSheet, Text, TextInput, View } from 'react-native';

import { zodResolver } from '@hookform/resolvers/zod';
import { transferCreateInputSchema } from '@finsight/shared';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { Controller, useForm } from 'react-hook-form';
import { z } from 'zod';

import { useAuth } from '../../auth/AuthProvider';
import { apiClient } from '../../api/client';
import { financeQueryKeys } from '../../api/queryKeys';
import { Card, Chip, PrimaryButton, ScreenContainer, Section } from '../../components/ui';
import { colors, radius, spacing, typography } from '../../theme';
import { apiErrorText } from '../../utils/apiErrorText';

const transferFormSchema = z
  .object({
    fromAccountId: z.string().trim().min(1, 'Select source account'),
    toAccountId: z.string().trim().min(1, 'Select destination account'),
    amount: z
      .string()
      .trim()
      .min(1, 'Amount is required')
      .refine((value) => {
        const parsed = Number(value);
        return Number.isFinite(parsed) && parsed > 0;
      }, 'Amount must be a positive number'),
    occurredAt: z
      .string()
      .trim()
      .min(1, 'Date/time is required')
      .refine((value) => !Number.isNaN(Date.parse(value)), 'Enter a valid ISO datetime'),
    description: z.string().trim().max(500).optional(),
  })
  .refine((value) => value.fromAccountId !== value.toAccountId, {
    path: ['toAccountId'],
    message: 'Source and destination must be different',
  });

type TransferFormValues = z.infer<typeof transferFormSchema>;

export function TransferScreen() {
  const { withAuth } = useAuth();
  const queryClient = useQueryClient();

  const accountsQuery = useQuery({
    queryKey: financeQueryKeys.accounts.list(),
    queryFn: () => withAuth((token) => apiClient.getAccounts(token)),
  });

  const form = useForm<TransferFormValues>({
    resolver: zodResolver(transferFormSchema),
    defaultValues: {
      fromAccountId: '',
      toAccountId: '',
      amount: '',
      occurredAt: new Date().toISOString(),
      description: '',
    },
  });

  const createTransferMutation = useMutation({
    mutationFn: (values: TransferFormValues) =>
      withAuth((token) =>
        apiClient.createTransfer(
          transferCreateInputSchema.parse({
            fromAccountId: values.fromAccountId,
            toAccountId: values.toAccountId,
            amount: Number(values.amount),
            occurredAt: new Date(values.occurredAt).toISOString(),
            description: values.description?.trim() || undefined,
          }),
          token,
        ),
      ),
    onSuccess: async () => {
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.transactions.all() }),
        queryClient.invalidateQueries({ queryKey: financeQueryKeys.dashboard.recent() }),
      ]);

      form.reset({
        fromAccountId: '',
        toAccountId: '',
        amount: '',
        occurredAt: new Date().toISOString(),
        description: '',
      });
      Alert.alert('Transfer created', 'Funds were moved successfully.');
    },
    onError: (error) => {
      Alert.alert('Transfer failed', apiErrorText(error));
    },
  });

  if (accountsQuery.isLoading) {
    return (
      <ScreenContainer>
        <Card style={styles.stateCard}>
          <Text style={styles.helperText}>Loading accounts...</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (accountsQuery.isError) {
    return (
      <ScreenContainer>
        <Card style={styles.stateCard}>
          <Text style={styles.errorText}>{apiErrorText(accountsQuery.error)}</Text>
          <PrimaryButton label="Retry" onPress={() => void accountsQuery.refetch()} />
        </Card>
      </ScreenContainer>
    );
  }

  const accounts = accountsQuery.data?.accounts ?? [];

  if (accounts.length < 2) {
    return (
      <ScreenContainer>
        <Section title="Transfer">
          <Card style={styles.stateCard}>
            <Text style={styles.helperText}>
              Create at least two accounts before making a transfer.
            </Text>
          </Card>
        </Section>
      </ScreenContainer>
    );
  }

  return (
    <ScreenContainer>
      <Section title="Transfer Funds" subtitle="Creates paired in/out transfer transactions">
        <Card style={styles.formCard}>
          <Text style={styles.fieldLabel}>From account</Text>
          <Controller
            control={form.control}
            name="fromAccountId"
            render={({ field: { value, onChange } }) => (
              <View style={styles.chipWrap}>
                {accounts.map((account) => (
                  <Pressable key={`from-${account.id}`} onPress={() => onChange(account.id)}>
                    <Chip
                      label={`${account.name} (${account.currency})`}
                      tone={value === account.id ? 'expense' : 'default'}
                    />
                  </Pressable>
                ))}
              </View>
            )}
          />
          {form.formState.errors.fromAccountId ? (
            <Text style={styles.errorText}>{form.formState.errors.fromAccountId.message}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>To account</Text>
          <Controller
            control={form.control}
            name="toAccountId"
            render={({ field: { value, onChange } }) => (
              <View style={styles.chipWrap}>
                {accounts.map((account) => (
                  <Pressable key={`to-${account.id}`} onPress={() => onChange(account.id)}>
                    <Chip
                      label={`${account.name} (${account.currency})`}
                      tone={value === account.id ? 'income' : 'default'}
                    />
                  </Pressable>
                ))}
              </View>
            )}
          />
          {form.formState.errors.toAccountId ? (
            <Text style={styles.errorText}>{form.formState.errors.toAccountId.message}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>Amount</Text>
          <Controller
            control={form.control}
            name="amount"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                keyboardType="decimal-pad"
                placeholder="0.00"
                placeholderTextColor={colors.textMuted}
              />
            )}
          />
          {form.formState.errors.amount ? (
            <Text style={styles.errorText}>{form.formState.errors.amount.message}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>Occurred At (ISO)</Text>
          <Controller
            control={form.control}
            name="occurredAt"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                autoCapitalize="none"
                placeholder="2026-02-17T10:30:00.000Z"
                placeholderTextColor={colors.textMuted}
              />
            )}
          />
          {form.formState.errors.occurredAt ? (
            <Text style={styles.errorText}>{form.formState.errors.occurredAt.message}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>Description</Text>
          <Controller
            control={form.control}
            name="description"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                placeholder="Optional note"
                placeholderTextColor={colors.textMuted}
              />
            )}
          />

          <PrimaryButton
            label={createTransferMutation.isPending ? 'Saving...' : 'Create Transfer'}
            onPress={form.handleSubmit((values) => {
              createTransferMutation.mutate(values);
            })}
          />
        </Card>
      </Section>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  formCard: {
    gap: spacing.sm,
  },
  stateCard: {
    gap: spacing.sm,
  },
  fieldLabel: {
    ...typography.caption,
    color: colors.textMuted,
  },
  chipWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  input: {
    height: 44,
    borderWidth: 1,
    borderColor: colors.border,
    borderRadius: radius.md,
    backgroundColor: colors.surface,
    paddingHorizontal: spacing.sm,
    color: colors.text,
    ...typography.body,
  },
  helperText: {
    ...typography.body,
    color: colors.textMuted,
  },
  errorText: {
    ...typography.caption,
    color: colors.expense,
  },
});

### /Users/umutugur/finsight/apps/mobile/src/screens/finance/RecurringScreen.tsx
import { useMemo } from 'react';
import { Alert, Pressable, StyleSheet, Text, TextInput, View } from 'react-native';

import { zodResolver } from '@hookform/resolvers/zod';
import {
  recurringCreateInputSchema,
  type RecurringRule,
} from '@finsight/shared';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { Controller, useForm } from 'react-hook-form';
import { z } from 'zod';

import { useAuth } from '../../auth/AuthProvider';
import { apiClient } from '../../api/client';
import { financeQueryKeys } from '../../api/queryKeys';
import { Card, Chip, PrimaryButton, ScreenContainer, Section } from '../../components/ui';
import { colors, radius, spacing, typography } from '../../theme';
import { apiErrorText } from '../../utils/apiErrorText';

const recurringFormSchema = z
  .object({
    kind: z.enum(['normal', 'transfer']),
    type: z.enum(['expense', 'income']),
    accountId: z.string().trim().optional(),
    categoryId: z.string().trim().optional(),
    fromAccountId: z.string().trim().optional(),
    toAccountId: z.string().trim().optional(),
    amount: z
      .string()
      .trim()
      .min(1, 'Amount is required')
      .refine((value) => {
        const parsed = Number(value);
        return Number.isFinite(parsed) && parsed > 0;
      }, 'Amount must be a positive number'),
    cadence: z.enum(['weekly', 'monthly']),
    dayOfWeek: z.string().trim().optional(),
    dayOfMonth: z.string().trim().optional(),
    startAt: z
      .string()
      .trim()
      .min(1, 'Start date/time is required')
      .refine((value) => !Number.isNaN(Date.parse(value)), 'Enter a valid ISO datetime'),
    description: z.string().trim().max(500).optional(),
  })
  .superRefine((value, ctx) => {
    if (value.kind === 'normal') {
      if (!value.accountId) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['accountId'],
          message: 'Select an account',
        });
      }
      if (!value.categoryId) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['categoryId'],
          message: 'Select a category',
        });
      }
    } else {
      if (!value.fromAccountId) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['fromAccountId'],
          message: 'Select source account',
        });
      }
      if (!value.toAccountId) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['toAccountId'],
          message: 'Select destination account',
        });
      }
      if (value.fromAccountId && value.toAccountId && value.fromAccountId === value.toAccountId) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['toAccountId'],
          message: 'Source and destination must differ',
        });
      }
    }

    if (value.cadence === 'weekly') {
      const parsed = Number(value.dayOfWeek);
      if (!Number.isInteger(parsed) || parsed < 0 || parsed > 6) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['dayOfWeek'],
          message: 'dayOfWeek must be 0-6',
        });
      }
    }

    if (value.cadence === 'monthly') {
      const parsed = Number(value.dayOfMonth);
      if (!Number.isInteger(parsed) || parsed < 1 || parsed > 28) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          path: ['dayOfMonth'],
          message: 'dayOfMonth must be 1-28',
        });
      }
    }
  });

type RecurringFormValues = z.infer<typeof recurringFormSchema>;

function formatDateTime(value: string): string {
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return value;
  }

  return date.toLocaleString();
}

export function RecurringScreen() {
  const { withAuth } = useAuth();
  const queryClient = useQueryClient();

  const recurringQuery = useQuery({
    queryKey: financeQueryKeys.recurring.list({}),
    queryFn: () => withAuth((token) => apiClient.listRecurring({}, token)),
  });

  const accountsQuery = useQuery({
    queryKey: financeQueryKeys.accounts.list(),
    queryFn: () => withAuth((token) => apiClient.getAccounts(token)),
  });

  const categoriesQuery = useQuery({
    queryKey: financeQueryKeys.categories.list(),
    queryFn: () => withAuth((token) => apiClient.getCategories(token)),
  });

  const form = useForm<RecurringFormValues>({
    resolver: zodResolver(recurringFormSchema),
    defaultValues: {
      kind: 'normal',
      type: 'expense',
      accountId: '',
      categoryId: '',
      fromAccountId: '',
      toAccountId: '',
      amount: '',
      cadence: 'monthly',
      dayOfWeek: '1',
      dayOfMonth: '1',
      startAt: new Date().toISOString(),
      description: '',
    },
  });

  const kind = form.watch('kind');
  const type = form.watch('type');
  const cadence = form.watch('cadence');

  const categories = useMemo(
    () => categoriesQuery.data?.categories.filter((item) => item.type === type) ?? [],
    [categoriesQuery.data?.categories, type],
  );

  const accounts = accountsQuery.data?.accounts ?? [];

  const accountNameById = useMemo(
    () => new Map(accounts.map((account) => [account.id, account.name])),
    [accounts],
  );
  const categoryNameById = useMemo(
    () =>
      new Map((categoriesQuery.data?.categories ?? []).map((category) => [category.id, category.name])),
    [categoriesQuery.data?.categories],
  );

  async function refreshRecurringList(): Promise<void> {
    await queryClient.invalidateQueries({ queryKey: financeQueryKeys.recurring.all() });
  }

  const createRecurringMutation = useMutation({
    mutationFn: (values: RecurringFormValues) =>
      withAuth((token) => {
        const amount = Number(values.amount);
        const basePayload = {
          kind: values.kind,
          amount,
          description: values.description?.trim() || undefined,
          cadence: values.cadence,
          startAt: new Date(values.startAt).toISOString(),
          ...(values.cadence === 'weekly'
            ? { dayOfWeek: Number(values.dayOfWeek) }
            : { dayOfMonth: Number(values.dayOfMonth) }),
        } as const;

        if (values.kind === 'normal') {
          return apiClient.createRecurring(
            recurringCreateInputSchema.parse({
              ...basePayload,
              kind: 'normal',
              accountId: values.accountId ?? '',
              categoryId: values.categoryId ?? '',
              type: values.type,
            }),
            token,
          );
        }

        return apiClient.createRecurring(
          recurringCreateInputSchema.parse({
            ...basePayload,
            kind: 'transfer',
            fromAccountId: values.fromAccountId ?? '',
            toAccountId: values.toAccountId ?? '',
          }),
          token,
        );
      }),
    onSuccess: async () => {
      await refreshRecurringList();
      form.reset({
        kind: 'normal',
        type: 'expense',
        accountId: '',
        categoryId: '',
        fromAccountId: '',
        toAccountId: '',
        amount: '',
        cadence: 'monthly',
        dayOfWeek: '1',
        dayOfMonth: '1',
        startAt: new Date().toISOString(),
        description: '',
      });
      Alert.alert('Recurring rule created', 'The rule is now active.');
    },
    onError: (error) => {
      Alert.alert('Create recurring failed', apiErrorText(error));
    },
  });

  const togglePausedMutation = useMutation({
    mutationFn: (rule: RecurringRule) =>
      withAuth((token) =>
        apiClient.updateRecurring(
          rule.id,
          {
            isPaused: !rule.isPaused,
          },
          token,
        ),
      ),
    onSuccess: refreshRecurringList,
    onError: (error) => {
      Alert.alert('Update recurring failed', apiErrorText(error));
    },
  });

  const deleteMutation = useMutation({
    mutationFn: (ruleId: string) => withAuth((token) => apiClient.deleteRecurring(ruleId, token)),
    onSuccess: refreshRecurringList,
    onError: (error) => {
      Alert.alert('Delete recurring failed', apiErrorText(error));
    },
  });

  if (recurringQuery.isLoading || accountsQuery.isLoading || categoriesQuery.isLoading) {
    return (
      <ScreenContainer>
        <Card>
          <Text style={styles.helperText}>Loading recurring data...</Text>
        </Card>
      </ScreenContainer>
    );
  }

  if (recurringQuery.isError || accountsQuery.isError || categoriesQuery.isError) {
    const error = recurringQuery.error ?? accountsQuery.error ?? categoriesQuery.error;
    return (
      <ScreenContainer>
        <Card style={styles.errorCard}>
          <Text style={styles.errorText}>{apiErrorText(error)}</Text>
          <PrimaryButton
            label="Retry"
            onPress={() => {
              void recurringQuery.refetch();
              void accountsQuery.refetch();
              void categoriesQuery.refetch();
            }}
          />
        </Card>
      </ScreenContainer>
    );
  }

  const rules = recurringQuery.data?.rules ?? [];

  return (
    <ScreenContainer>
      <Section title="Recurring Rules" subtitle="Create scheduler-ready rules">
        <Card style={styles.formCard}>
          <Text style={styles.fieldLabel}>Kind</Text>
          <Controller
            control={form.control}
            name="kind"
            render={({ field: { value, onChange } }) => (
              <View style={styles.chipWrap}>
                <Pressable onPress={() => onChange('normal')}>
                  <Chip label="NORMAL" tone={value === 'normal' ? 'primary' : 'default'} />
                </Pressable>
                <Pressable onPress={() => onChange('transfer')}>
                  <Chip label="TRANSFER" tone={value === 'transfer' ? 'primary' : 'default'} />
                </Pressable>
              </View>
            )}
          />

          {kind === 'normal' ? (
            <>
              <Text style={styles.fieldLabel}>Type</Text>
              <Controller
                control={form.control}
                name="type"
                render={({ field: { value, onChange } }) => (
                  <View style={styles.chipWrap}>
                    <Pressable onPress={() => onChange('expense')}>
                      <Chip label="EXPENSE" tone={value === 'expense' ? 'expense' : 'default'} />
                    </Pressable>
                    <Pressable onPress={() => onChange('income')}>
                      <Chip label="INCOME" tone={value === 'income' ? 'income' : 'default'} />
                    </Pressable>
                  </View>
                )}
              />

              <Text style={styles.fieldLabel}>Account</Text>
              <Controller
                control={form.control}
                name="accountId"
                render={({ field: { value, onChange } }) => (
                  <View style={styles.chipWrap}>
                    {accounts.map((account) => (
                      <Pressable key={account.id} onPress={() => onChange(account.id)}>
                        <Chip label={account.name} tone={value === account.id ? 'primary' : 'default'} />
                      </Pressable>
                    ))}
                  </View>
                )}
              />
              {form.formState.errors.accountId ? (
                <Text style={styles.errorText}>{form.formState.errors.accountId.message}</Text>
              ) : null}

              <Text style={styles.fieldLabel}>Category ({type})</Text>
              <Controller
                control={form.control}
                name="categoryId"
                render={({ field: { value, onChange } }) => (
                  <View style={styles.chipWrap}>
                    {categories.map((category) => (
                      <Pressable key={category.id} onPress={() => onChange(category.id)}>
                        <Chip
                          label={category.name}
                          tone={value === category.id ? 'primary' : 'default'}
                        />
                      </Pressable>
                    ))}
                  </View>
                )}
              />
              {form.formState.errors.categoryId ? (
                <Text style={styles.errorText}>{form.formState.errors.categoryId.message}</Text>
              ) : null}
            </>
          ) : (
            <>
              <Text style={styles.fieldLabel}>From account</Text>
              <Controller
                control={form.control}
                name="fromAccountId"
                render={({ field: { value, onChange } }) => (
                  <View style={styles.chipWrap}>
                    {accounts.map((account) => (
                      <Pressable key={`from-${account.id}`} onPress={() => onChange(account.id)}>
                        <Chip
                          label={account.name}
                          tone={value === account.id ? 'expense' : 'default'}
                        />
                      </Pressable>
                    ))}
                  </View>
                )}
              />
              {form.formState.errors.fromAccountId ? (
                <Text style={styles.errorText}>{form.formState.errors.fromAccountId.message}</Text>
              ) : null}

              <Text style={styles.fieldLabel}>To account</Text>
              <Controller
                control={form.control}
                name="toAccountId"
                render={({ field: { value, onChange } }) => (
                  <View style={styles.chipWrap}>
                    {accounts.map((account) => (
                      <Pressable key={`to-${account.id}`} onPress={() => onChange(account.id)}>
                        <Chip
                          label={account.name}
                          tone={value === account.id ? 'income' : 'default'}
                        />
                      </Pressable>
                    ))}
                  </View>
                )}
              />
              {form.formState.errors.toAccountId ? (
                <Text style={styles.errorText}>{form.formState.errors.toAccountId.message}</Text>
              ) : null}
            </>
          )}

          <Text style={styles.fieldLabel}>Amount</Text>
          <Controller
            control={form.control}
            name="amount"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                keyboardType="decimal-pad"
                placeholder="0.00"
                placeholderTextColor={colors.textMuted}
              />
            )}
          />
          {form.formState.errors.amount ? (
            <Text style={styles.errorText}>{form.formState.errors.amount.message}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>Cadence</Text>
          <Controller
            control={form.control}
            name="cadence"
            render={({ field: { value, onChange } }) => (
              <View style={styles.chipWrap}>
                <Pressable onPress={() => onChange('weekly')}>
                  <Chip label="WEEKLY" tone={value === 'weekly' ? 'primary' : 'default'} />
                </Pressable>
                <Pressable onPress={() => onChange('monthly')}>
                  <Chip label="MONTHLY" tone={value === 'monthly' ? 'primary' : 'default'} />
                </Pressable>
              </View>
            )}
          />

          {cadence === 'weekly' ? (
            <>
              <Text style={styles.fieldLabel}>Day of week (0=Sun ... 6=Sat)</Text>
              <Controller
                control={form.control}
                name="dayOfWeek"
                render={({ field: { value, onChange, onBlur } }) => (
                  <TextInput
                    style={styles.input}
                    value={value}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    keyboardType="number-pad"
                    placeholder="1"
                    placeholderTextColor={colors.textMuted}
                  />
                )}
              />
              {form.formState.errors.dayOfWeek ? (
                <Text style={styles.errorText}>{form.formState.errors.dayOfWeek.message}</Text>
              ) : null}
            </>
          ) : (
            <>
              <Text style={styles.fieldLabel}>Day of month (1-28)</Text>
              <Controller
                control={form.control}
                name="dayOfMonth"
                render={({ field: { value, onChange, onBlur } }) => (
                  <TextInput
                    style={styles.input}
                    value={value}
                    onChangeText={onChange}
                    onBlur={onBlur}
                    keyboardType="number-pad"
                    placeholder="1"
                    placeholderTextColor={colors.textMuted}
                  />
                )}
              />
              {form.formState.errors.dayOfMonth ? (
                <Text style={styles.errorText}>{form.formState.errors.dayOfMonth.message}</Text>
              ) : null}
            </>
          )}

          <Text style={styles.fieldLabel}>Start At (ISO)</Text>
          <Controller
            control={form.control}
            name="startAt"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                autoCapitalize="none"
                placeholder="2026-02-17T10:30:00.000Z"
                placeholderTextColor={colors.textMuted}
              />
            )}
          />
          {form.formState.errors.startAt ? (
            <Text style={styles.errorText}>{form.formState.errors.startAt.message}</Text>
          ) : null}

          <Text style={styles.fieldLabel}>Description</Text>
          <Controller
            control={form.control}
            name="description"
            render={({ field: { value, onChange, onBlur } }) => (
              <TextInput
                style={styles.input}
                value={value}
                onChangeText={onChange}
                onBlur={onBlur}
                placeholder="Optional note"
                placeholderTextColor={colors.textMuted}
              />
            )}
          />

          <PrimaryButton
            label={createRecurringMutation.isPending ? 'Saving...' : 'Create Rule'}
            onPress={form.handleSubmit((values) => {
              createRecurringMutation.mutate(values);
            })}
          />
        </Card>
      </Section>

      <Section title="Existing Rules" subtitle={`${rules.length} rules`}>
        {rules.length === 0 ? (
          <Card>
            <Text style={styles.helperText}>No recurring rules yet.</Text>
          </Card>
        ) : null}

        {rules.map((rule) => (
          <Card key={rule.id} style={styles.ruleCard}>
            <View style={styles.ruleHeader}>
              <Text style={styles.ruleTitle}>
                {rule.kind === 'transfer' ? 'Transfer rule' : 'Normal rule'}
              </Text>
              <Chip label={rule.isPaused ? 'PAUSED' : 'ACTIVE'} tone={rule.isPaused ? 'default' : 'primary'} />
            </View>

            <Text style={styles.ruleText}>Amount: {rule.amount}</Text>
            <Text style={styles.ruleText}>Cadence: {rule.cadence.toUpperCase()}</Text>
            <Text style={styles.ruleText}>Next run: {formatDateTime(rule.nextRunAt)}</Text>
            {rule.kind === 'normal' ? (
              <>
                <Text style={styles.ruleText}>Type: {rule.type?.toUpperCase() ?? 'N/A'}</Text>
                <Text style={styles.ruleText}>
                  Account: {rule.accountId ? accountNameById.get(rule.accountId) ?? rule.accountId : 'N/A'}
                </Text>
                <Text style={styles.ruleText}>
                  Category:{' '}
                  {rule.categoryId ? categoryNameById.get(rule.categoryId) ?? rule.categoryId : 'N/A'}
                </Text>
              </>
            ) : (
              <>
                <Text style={styles.ruleText}>
                  From:{' '}
                  {rule.fromAccountId
                    ? accountNameById.get(rule.fromAccountId) ?? rule.fromAccountId
                    : 'N/A'}
                </Text>
                <Text style={styles.ruleText}>
                  To: {rule.toAccountId ? accountNameById.get(rule.toAccountId) ?? rule.toAccountId : 'N/A'}
                </Text>
              </>
            )}

            {rule.description ? <Text style={styles.ruleText}>Note: {rule.description}</Text> : null}

            <View style={styles.actionRow}>
              <Pressable
                onPress={() => {
                  togglePausedMutation.mutate(rule);
                }}
              >
                <Text style={styles.linkText}>{rule.isPaused ? 'Resume' : 'Pause'}</Text>
              </Pressable>
              <Pressable
                onPress={() => {
                  Alert.alert('Delete recurring rule', 'Delete this recurring rule?', [
                    { text: 'Cancel', style: 'cancel' },
                    {
                      text: 'Delete',
                      style: 'destructive',
                      onPress: () => {
                        deleteMutation.mutate(rule.id);
                      },
                    },
                  ]);
                }}
              >
                <Text style={styles.deleteText}>Delete</Text>
              </Pressable>
            </View>
          </Card>
        ))}
      </Section>
    </ScreenContainer>
  );
}

const styles = StyleSheet.create({
  formCard: {
    gap: spacing.sm,
  },
  fieldLabel: {
    ...typography.caption,
    color: colors.textMuted,
  },
  chipWrap: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: spacing.xs,
  },
  input: {
    height: 44,
    borderWidth: 1,
    borderColor: colors.border,
    borderRadius: radius.md,
    backgroundColor: colors.surface,
    paddingHorizontal: spacing.sm,
    color: colors.text,
    ...typography.body,
  },
  helperText: {
    ...typography.body,
    color: colors.textMuted,
  },
  errorCard: {
    gap: spacing.sm,
  },
  errorText: {
    ...typography.caption,
    color: colors.expense,
  },
  ruleCard: {
    gap: spacing.xs,
  },
  ruleHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    gap: spacing.sm,
  },
  ruleTitle: {
    ...typography.subheading,
    color: colors.text,
  },
  ruleText: {
    ...typography.caption,
    color: colors.textMuted,
  },
  actionRow: {
    marginTop: spacing.xs,
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  linkText: {
    ...typography.caption,
    color: colors.primary,
    fontWeight: '600',
  },
  deleteText: {
    ...typography.caption,
    color: colors.expense,
    fontWeight: '600',
  },
});

